<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从0开始的JavaWeb---java篇]]></title>
    <url>%2F2018%2F10%2F13%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb-java%E7%AF%87%2F</url>
    <content type="text"><![CDATA[软件系统体系结构B/S1. B/S结构即浏览器/服务器（Browser/Server） 优点只需要编写服务器端程序 缺点安全性差 C/S1. C/S 结构即 客户端/服务器（Client/Server），例如QQ 2. 需要编写服务器程序，以及客户端程序，例如我们安装的就是QQ的客户端 缺点软件更新时需要同时更新客户端和服务器两端，比较麻烦 优点安全性比较好 Web资源Web资源介绍1. html：静态资源 2. Jsp/Servlet：动态资源 当然除了JavaWeb程序，还有其他Web程序，例如：ASP，PHP等。 静态资源和动态资源的区别 访问Web资源打开浏览器，输入URL： 协议名：//域名：端口/路径，例如：https://www.baidu.com:8080/index.html Web服务器Web服务器的作用时接收客户端的请求，给客户端做出响应。 对于JavaWeb程序而言，还需要有Jsp/Servlet容器，Jsp/Servlet容器的基本功能是把动态资源转会为静态资源，当然Jsp/Servlet容器不知这些功能。 我们需要使用的是Web服务器和Jsp/Servlet容器，通常这两者会集于一身。下面是对JavaWeb的服务器： 1. Tomcat(Apache):当前应用最广的JavaWeb服务器 2. JBoss(RedHat红帽):支持JavaEE，应用比较广 3. GlassFlsh(Orcale):ORacle开发JavaWeb服务器，应用不是很广 4. Resin(Caucho)：支持JavaEE，应用越来越广 5. Weblogic(Orcale):要钱的！支持JavaEE，适合大型项目 6. Websphere（IBM）：要钱的！支持JavaEE，适合大型项目 TomcatTomcat简述Tomcat服务器由Apache提供，开源免费。由于Sun和其他公司参与到了Tomcat的开放中，所以最新的Jsp/Servlet规范总是能在Tomcat中体现出来。 配置Tomcattomcat的安装自行百度 tomcat端口改变自行百度 tomcat配置自行百度 Tomcat目录结构 /work tomcat把由jsp生成的servlet放于目录下 /webapps 当发布web应用时，默认情况下把web应用文件放于次目录下 /logs 存放tomcat的日志文件 /share/lib 存放所有web应用都可以访问的jar文件 /common/lib 存放tomcat服务器以及所有web应用都可以访问的jar应用 /server/webapps 存放tomcat自带的两个web应用：admin应用和manager应用 /server/lib 存放tomcat服务器所需的jar文件 /server 包含三个子目录：classes。lib和webapps /conf 存放tomcat服务器的各种配置文件，其中最重要的文件是server.xml /bin 存放Windows平台以及linux平台上启动和关闭tomcat的脚本文件 Web应用创建一个静态网站1. 在webapps目录下创建一个目录（命名必须不包含中文和空格），这个目录则为项目目录 2. 在项目目录下创建一个html文件 创建一个动态网站1. 在webapps目录下创建一个项目目录 2. 在项目目录下创建如下内容 1. WEB-INF目录 1. WEB-INF目录下创建web.xml文件 1. xml文件中的内容，可以从其他的项目中复制 2. 创建一个lib目录，用户存放jar包 3. classes目录，用于存放自己写的class 2. 创建静态或动态页面 WEB-INF下的项目，浏览器是不能访问的，所以为了安全起见，所以一些文件必须放到WEB-INF文件 配置外部应用方法一conf/server.xml:打开server.xml文件，找到&lt;Host&gt;元素，在其中添加&lt;Context&gt;元素： &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeplay=&quot;true&quot;&gt; &lt;Context path=&quot;hello&quot; docBase=&quot;C:/hello&quot;/&gt; &lt;/Host&gt; 1. path：制定当前应用的名称 2. docBase：指定应用的物理位置 3. 浏览器访问路径：http://localhost:8080/hello/index.xml 方法二conf/catalana/localhost：在该目录下创建hello.xml文件，在该文件编写&lt;Context&gt;元素 &lt;Context docBase=&quot;C:/hello&quot;&gt; 1. 文件名：指定当前应用的名称 2. docBase：指定应用的物理位置 3. 浏览器访问路径：http://localhost:8080/hello/index.xml servet.xml的配置1. &lt;Service name=&quot;Catalina&quot;&gt; 服务，名字为catalina 服务中又有很多连接 &lt;Connector&gt; 2. &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt; 用于接待HTTP/1.1的服务，端口是80端口，不处理请求 3. &lt;Engine&gt; 引擎，用于处理请求，引擎下又分很多主机&lt;Host&gt; 4. &lt;Host name=&quot;主机名&quot; appBase=&quot;基础目录&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;主机下又有&lt;Context&gt;上下文 5. &lt;Context&gt; 上下文，对应的就是一个项目 6. servet.xml中还有很多监听器 7. 引擎唯一的，Service唯一的，Host可以多个，Context可以多个 Servlet什么是ServletServlet是javaWeb的三大组件之一，它属于动态资源。 Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 1. 接收请求数据 2. 处理请求 3. 完成响应 例如客户端发出登陆亲求，或者输出注册请求，这些请求都应该由Servlet来完成处理！ Servlet需要我们自己来编写，每个Servlet必须实现javax.servlet.Servlet接口 实现Servlet的方式实现Servlet的三种方式： 1. 实现javax.servlet.Servket接口 2. 继承javax.servlet.GenericServlet类 3. 继承javax.servlet.http.HttpServlet类 我们通常会去继承HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口开始 使用Servlet servlet的方法是由tomcat调用的方法 1. init() 1. 在Servlet对象创建之后马上执行，并且只执行一次 2. service() 1. 会被调用多次，每次处理请求都是调用这个方法 3. destroy() 1. 在Servlet被销毁之前调用，并且它只会被调用一次 4. getServletConfig() 1. 获取Servlet的配置信息（从init函数中，可以获得Servlet的配置信息） 5. getServletInfo() 1. 获取Servlet的信息（没什么用） 浏览器访问Servlet1. 给Servlet指定一个Servlet路径（让Servlet与一个路径绑定在一起） 1. 需要在web.xml中对Servlet配置 2. &lt;servlet&gt; &lt;servlet-name&gt;XXX随意&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet的路径&lt;servlet-class&gt; &lt;/servlet&gt; 3. &lt;servlet-mapping&gt; &lt;servlet-name&gt;与上面的name相同&lt;/servlet-name&gt; &lt;url-pattern&gt;/虚拟路径 例如：/aa/b/c&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2. 浏览器访问Servlet路径 1. localhost:8080/项目名/虚拟路径名 特性1. 单例，一个类只有一个对象；当然可能存在多个Servlet类 2. 线程不安全的，效率高 3. Servlet由程序员写，但对象由服务器创建，调用响应的方法 Servlet细节Servlet与线程安全因为一个类型的Servlet只有一个实例对象，那么就有可能会出现同一个时间一个Servlet同属处理多个请求 那么Servlet是否为线程安全呢？ 答案是“不是线程安全的” 这说明Servlet的工作效率很高，但也存在线程安全问题 所以我们不应该在Servlet中随意创建成员变量 因为可能会存在一个线程这个成员变量进行写操作，另一个线程对这个成员变量进行读操作 1. 不要在Servlet中创建成员！创建局部变量即可 2. 可创建无状态成员 3. 可以创建有状态成员，但是状态必须为只读的 让服务器在启动时就创建Servlet默认情况下，服务器在某个Servlet第一次收到请求时创建它，也可以在web.xml中进行配置，使服务器启动的时候就创建Servlet &lt;servlet&gt; &lt;servlet-name&gt;hello1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.servlet.HelloWorld&lt;servlet-class&gt; &lt;load-on-startup&gt;非负整数&lt;/load-on-startup&gt; &lt;!-- 非负数，越小越先创建 --&gt; &lt;servlet&gt; &lt;url-pattern&gt;是&lt;servlet-mapping&gt;的子元素，用来指定Servlet的访问路径，即URL 它必须是以 &quot;/&quot; 开头 &lt;servlet-mapping&gt; &lt;servlet-name&gt;text&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;url-pattern&gt;/b&lt;/url-pattern&gt; &lt;url-pattern&gt;/c&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 那么说明这个Servlet绑定了多个url，一般也就一个，你设置多个也没什么用 ServletContext一个项目只有一个ServletContext对象！application 我们可以在N个Servlet中获取这个唯一的对象，使用它可以给多个Servlet传递数据 Servlet之间互不一般是互不联系的，所以信息传递只能通过ServletContext servletContext概述服务器会为每个应用创建一个ServletContext对象： 1. ServletContext 对象的创建时在服务器启动时完成 2. ServletContext 对象的销毁时在服务器关闭时完成 ServletContext对象的作用是在整个Web应用的动态资源之间共享数据！ 例如： 在A_Servlet中项 ServletContext对象中保存一个值，然后再B_Servlet中就可以获取这个值，这就是共享数据 获取ServletContext在Servlet获取ServletContext对象： 1. 在 void init(ServletConfig config)中：ServletContext context = config.getServletContext(); 在GenericeServlet 或 HttpServlet 中获取ServletContext对象： 1. GenericSeriet类中由getServletContext()方法，所以可以直接使用this.getServletContext()来获取 2. HttpServlet中有getServletContext()方法获取 在ServletContextEvent中 1. getServletContext()方法获取 在HttpSession中 1. getServletContext()方法获取 设置，获取对象1. void serAttribute(String name,Objcet value): 这是一个键值对，name与value对应 2. Object getAttribute(String name): 通过名为name 的键，去获得object类型的值 3. void removeAttribute(String name): 移除名为name 的键值对 4. Enumeration getAttributeNames(): 获取所有域属性的名称 获取资源获取真实路径使用ServletContext对象来获取web应用下的资源 例如在hello应用的根目录下出创建a.txt文件，获取方法： String realpath = servletContext.getRealPath(&quot;/a,txt&quot;),realpath的为a.txt的绝对路径 获取资源流可以通过ServletContext获取资源流，即把资源以输入流的方式获取： 1. 获取a.txt资源流 InputStream in = ServletContext.getResourceAsStream(&quot;/a.txt&quot;); 获取指定目录下所有资源路径通过ServletContext获取指定目下所有资源路径 例如获取/WEB-INF下所有的资源路径： Set set = context.getResourcePaths(&quot;/WEB-INF&quot;); Java画图（可用于验证码）BufferedImage bi = new BufferedImage(150, 35, BufferedImage.TYPE_INT_RGB); //得到图片缓冲区，这是长宽，图片格式RGB还是RGBA //得到它的绘制环境（画这张图片的笔） Graphics2D g2 = (Graphics2D) bi.getGraphics(); g2.setColor(Color.WHITE);//设置颜色 g2.fillRect(0,0,79,35);//填充图片，就是设置背景色 g2.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 25));//设置字体 //Font.BLOD 为字体格式，比如blod就是粗体 g2.setColor(Color.BLACK);//设置颜色 ge.drawString(&quot;hell0&quot;, point.x, point.y);//向图片区域中写String的内容 ImageIO.write(bi, &quot;JPEG&quot;, new FileOutputStream(&quot;F:/a.jpg&quot;));//输出流，bi为图片缓冲区，&quot;JPEG&quot;为图片格式 response和request都是由服务器产生 服务器每次收到请求时，都会为这个请求开辟一个新的线程 服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体 服务器还会创建response对象，这个对象和客户端连接在一起，他可以用来向客户端发送响应 responseServletResponse ---&gt; 与协议无关的类型 HtppServletResponse ----&gt; 与http协议相关的类型 二者无关，传入到Servlet中的时HttpServletResponse，所以可以强转为response http协议中响应内容包括什么呢？ 状态码200 表示成功， 302 表示重定向， 404 表示客户端错误， 500表示服务器端错误 1. sendError(int sc) 2. sendError(int sc, String msg) 3. setStatus(int sc) 例如： 发送404 response.sendError(404, &quot;您访问的资源存在，就是不给你看&quot;); 响应头响应头：Content-Type,Refresh,Location等 1. setHeader(String name, String value):适用于单值的响应头 2. addHeader(String name, String value):适用于多值的响应头 3. setIntHeader(String name, String Value):适用于单值的int类型的响应头 4. addIntHeader(String name, String value):适用于多值int类型的响应头 5. setDateHeader(String name, long value):适用于单值的毫秒类型的响应头 6. addDaTeHeader(String name, long value):适用于多值的毫秒类型的响应头；long型值为 毫秒值，代表过期时间， 例如： 发送302，设置location头，完成重定向 response.setHeader(&quot;Location&quot;,&quot;/项目名/servlet路径&quot;); response.setStatus(302); 定时刷新，设置Refresh头，其实就是定时重定向 PrintWriter write = rsponse.getWriter(); writer.print(&quot;欢迎登陆，5秒后自动跳转到主页&quot;); response.setHeader(&quot;Redresh&quot;, &quot;5;URL=/项目名/重定向的servlet或jsp&quot;); 禁用浏览器缓存：Cache-Control, prama, expires response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); response.setHeader(&quot;prame&quot;,&quot;no-cache&quot;); response.setDateHeader(&quot;expires&quot;,-1);//过期时间-1，立马过期 &lt;meta&gt;标签可以代替响应头 响应体通常是html，也可以是图片 response的两个流： 1. ServletOutPutStream,用来向客户端发送字节数据 ServletOutputStream out = response.getOutputStream(); 2. PrintWriter,用来向客户端发送字符数据!需要设置编码 PrintWriter writer = response.getWriter(); 两个流不能同时使用 发送字节流： String s = &quot;hello world&quot;; byte[] bytes = s.getBytes(); response.getOutputStream().write(bytes); 发送字节图片： //运用commons-io库 String path = &quot;a.jpg&quot;; FileInputStream in = new FileInputStream(); //读取输入流内容的字节到字节数组中 byte[] bytes = IOUtils.toByteArray(int); response.getOutputStream().write(bytes); 重定向这个重定向不同与上面的重定向，这个更快 sendRedirect(String location)方法 response.sendRedirect(&quot;/项目名/servlet虚拟路径或jsp名&quot;); request封装了客户端所有的请求数据 Http协议中的数据都可以通过request对象来获取 获取常用信息获取客户端Ip，请求方式 Ip：request.getRemoteAddr(); 请求方式：request.getMethod(); 获取请求头String getHeader(String name),适用于单值头 int getIntHeader(String name),适用于单值int类型的请求头 long getDateHeader(String name),适用于单值毫秒类型的请求头 Enumeration&lt;String&gt; getHeaders(String name),适用于多值请求头 例如： 通过user-agent识别用户浏览器类型 request.getHeader(&quot;User-Agent&quot;); 防盗链：如果请求不是通过本站发出的超链接发出的，发送错误状态码404 Refere这个请求头，表示请求的来源 String referer = req.getHeader(&quot;Rederer&quot;); if(referer == null || referer.contains(&quot;localhost&quot;)){ resp.sendRedirect(&quot;https://www.baidu.com&quot;); System.out.println(&quot;baidu&quot;); } else{ System.out.println(&quot;hello&quot;); } 获取请求URLString getScheme();获取协议 String getServerName();获取服务器名 String getServerPort();获取服务器端口 String getContextPath();获取项目名 String getServletPath();获取Servlet路径 String getQueryString();获取参数部分，即问好后面的部分 String getRequestURI();获取请求URI，等于项目名+Servlet路径 String getRequestURL();获取请求URL，等于不包含参数的整个请求路径 获取请求参数请求参数时由客户端发送给服务器的 1. 有可能在请求体中（post） 2. 可能在URL中（get） 1. String getParameter(String name):获取指定名称的请求参数值，适用于单值请求 2. String[] getParameterValues(String name);获取指定名称的请求参数值，适用于多值请求参数 3. Map&lt;String, String[]&gt; getParameterMap():获取所有请i去参数，其中key为参数名，value为参数值， 例如： 超链接参数 表单数据 请求转发和请求包含RequestDispatcher rd = request.getRequestDispatcher(&quot;/MyServlet&quot;);//参数是被包含或被转发的Servlet虚拟路径 请求转发：rd.forward(request,response);（常用） 请求包含：rd.include(request,response); 有时一个请求需要多个Servlet协作才能完成，所以需要一个Servlet跳到另一个Servlet 1. 一个请求跨多个Servlet，需要使用转发和包含 2. 请求转发：由下一个Servlet完成相应体，当前Servlet可以设置响应头（留头不留体） 1. 即request.setHeader()中的内容，可以传递到第二个servlet 2. response.write()这类的内容不会传递回去，即第一个Servlet的内容不会输出浏览器 3. 请求包含：由两个Servlet共同完成相应体（都留） 4. 物理是请求转发还是请求包含，都在一个请求范围内，使用同一个resquest和response 请求转发与重定向不同1. 请求转发是一次请求，重定向是两次转发 2. 请求转发地址栏不变，重定向后会显示一个请求的地址 3. 请求转发只能转发到本项目其他servet，而重定向哪都能去 4. 请求转发为服务端行为，重定向是客户端行为 request域Servlet中三大域对象：request,session,application, 1. void setAttribute(String name); 2. Object getAttribute(String name); 3. void removeAttribute(String name); 同一个请求范围内使用request.getAttribute()和request.setAttribute()可以使用 但是如果是重定向则不能获取，因为不是同一个请求 编码常见字符编码：iso-8859-1（不支持中文），gbk（系统默认编码，中国的国标码），utf-8（万国码，支持全世界的编码，所以我们要使用这个） 响应编码1. 当使用response.getWriter()来向客户端发送字符数据时 如果在之前没有设置编码，那么默认使用iso，以为不支持中文，所以一定是乱码 2. 在使用response.getWriter()之前可以使用response.setCharaceterEncoding() 来设置字符流的编码为gbk或utf-8 3. 在使用response.getWriter()之前可以使用resonse.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;) 来设置响应头，通知浏览器服务器这边使用的utf-8 4. serHeader(&quot;Content-Type&quot;,&quot;text/html;charset=utf-8&quot;)的快捷方式是:setContentType(&quot;text/html;charset=utf-8&quot;); 请求编码1. 客户端发送给服务器的请求参数是什么编码： 请求页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是是什么 2. 服务器默认使用ISO-8859-1来解码，所以中文肯定出现乱码 3. 请求编码处理分为两种：get，post：get请求参数不再请求体中，而post请求参数在请求体中，所以处理方式不同 GET请求编码处理1. Sting username = request.getParameter(&quot;name&quot;); 2. byte[] bytes = name.getBytes(&quot;ISO-8859-1&quot;); 3. name = new String(bytes, &quot;utf-8&quot;); 4. 在server.xml中配置URIEncoding=utf-8 POST请求编码处理1. String usernmae = new String(request.getParameter(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); 2. 在获取参数之前调用request.setCharacterEncoding(&quot;utf-8&quot;); URL编码表单的类型：Content-Type:application/x-www-form-urlencoded 就是把中文转换为%后面跟随两位16进制 1. 他不是字符编码 2. 它是用来在客户端和服务器之间传递参数用的一种方式 3. URL编码需要先指定一种字符编码，把字符串解码后得到byte[], 然后把小于0的字节+256，再转换为16进制，前面再加% 4. POST请求默认就是使用URL编码，tomcat会自动使用URL编码 5. URL编码：String name = URLEncoder.encode(name, &quot;utf-8&quot;); 6. URL解码：String name = URLDecoder.decode(name,&quot;utf-8&quot;); 路径1.web.xml中&lt;url-pattern&gt;路径 要么以“*”开头要么以&quot;/&quot;开头 2. 转发和包含路径 1. 以&quot;/&quot;开头：相对当前项目路径 2. 不以&quot;/&quot;开头：相对当前Servlet路径 3. 重定向路径（客户端路径） 1. 以&quot;/&quot;开头：相对当前主机，所以必须后面自己加上项目名 4. 页面中超链接和表单路径 1. 与重定向相同，都是客户端路径，需要添加项目名 2. &lt;form action=&quot;/项目/servlet&quot;&gt; 3. 如果不已&quot;/&quot;开头，那么相对当前页面所在路径 4. 建议使用以&quot;/&quot;开头的路径，因为如果页面路径改变，那么servlet就找不到了 5. ServletContext获取资源路径 1. 相对于当前项目目录，即index.jsp所在路径 6. ClassLoader获取资源路径 1. 相对classes目录 7. Class获取资源路径 1. 以&quot;/&quot;开头，相对Classes目录 2. 不以&quot;/&quot;开头，相对当前.class文件所在目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门 嘤嘤嘤]]></title>
    <url>%2F2018%2F10%2F12%2F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%98%A4%E5%98%A4%E5%98%A4%2F</url>
    <content type="text"><![CDATA[学习算法的建议必备条件1. 数理基础，着力加强 2. 兴趣爱好，能否持久的喜欢它 3. 做事有系统，规范，着眼于大的方面 C++或Java熟练掌握C++或者Java，语言作为基础，即使算法能理解，也无法表示出来 数理基础对于数学定理，公式推导等，要熟悉 数据结构对于数据结构，吃透了能够受益终身。不要指望数据结构，这个东西方面太广，不要只去看你有什么没学，你更要看你学了什么 计算思维思维方式在前人的基础上，形成自己的方式；同时学习一些套路，解题的套路，等等 算法几何In-Triangle Test(判断点是否在三角形内) 只要点在直线 PQ，QR，RP 的左边，那么点就在三角形内部。 计算几何中，一般以逆时针方向 bool InTriangle(P, Q, R, S){ bool a = ToLeft(P, Q, S); bool b = ToLeft(Q, R, S); bool c = ToLeft(Q, R, S); return a == b &amp;&amp; b == c; } //因为不知道PQR的排列顺序，虽然图片上是逆时针，但是实际中可能是逆时针可能是顺时针，所以全为True和全为False都成立]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2018%2F10%2F08%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫的实际例子：1. 搜索引擎（百度、谷歌、360搜索等）。 2. 伯乐在线。 3. 惠惠购物助手。 4. 数据分析与研究（数据冰山知乎专栏）。 5. 抢票软件等。 什么是网络爬虫：通俗理解爬虫是一个模拟人类请求网站行为的程序。可以自动请求网页、并数据抓取下来 然后使用一定的规则提取有价值的数据。 专业介绍：百度百科。 通用爬虫和聚焦爬虫： 通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。 主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。 聚焦爬虫：是面向特定需求的一种网络爬虫程序,他与通用爬虫的区别在于： 聚焦爬虫在实施网页抓取的时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。 为什么用Python写爬虫程序：PHP：PHP是世界是最好的语言，但他天生不是做这个的 而且对多线程、异步支持不是很好，并发处理能力弱。爬虫是工具性程序，对速度和效率要求比较高。 Java：生态圈很完善，是Python爬虫最大的竞争对手。 但是Java语言本身很笨重，代码量很大。重构成本比较高，任何修改会导致代码大量改动。爬虫经常要修改采集代码。 C/C++：运行效率是无敌的。但是学习和开发成本高。写个小爬虫程序可能要大半天时间。 Python：语法优美、代码简洁、开发效率高、支持的模块多。 相关的HTTP请求模块和HTML解析模块非常丰富。还有Scrapy和Scrapy-redis框架让我们开发爬虫变得异常简单。 准备工具：Python3.6开发环境。 Pycharm 2017 professional版。 虚拟环境。`virtualenv/virtualenvwrapper`。 http协议和Chrome抓包工具什么是http和https协议：HTTP协议：全称是HyperText Transfer Protocol，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是80端口。 HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是443端口。 在浏览器中发送一个http请求的过程：当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。 当我们在浏览器输入URL http://www.baidu.com 的时候，浏览器发送一个Request请求去获取 http://www.baidu.com 的html文件，服务器把Response文件对象发送回给浏览器。 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。 当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。 url详解：URL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成： scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。 常用的请求方法：在Http协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是get请求和post请求。 get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用get请求。 post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。 以上是在网站开发中常用的两种方法。 并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌， 有可能一个应该使用get方法的请求就一定要改成post请求，这个要视情况而定。 请求头常见参数：在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在body中（在post请求中），第三个就是把数据放在head中。 这里介绍在网络爬虫中经常会用到的一些请求头参数： User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。 如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。 因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。 Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。 Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。 一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。 常见响应状态码：200：请求正常，服务器正常的返回数据。 301：永久重定向。比如在访问www.jingdong.com的时候会重定向到www.jd.com。 302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。 400：请求的url在服务器上找不到。换句话说就是请求url错误。 403：服务器拒绝访问，权限不够。 500：服务器内部错误。可能是服务器出现bug了。 Chrome抓包工具： Chrome浏览器Chrome浏览器是一个非常亲近开发者的浏览器。可以方便的查看网络请求以及发送的参数。 对着网页右键-&gt;检查。然后就可以打开开发者选项。以下用图片来说明。 urllib库urllib库是Python中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。 urlopen函数：在Python3的urllib库中，所有和网络请求相关的方法，都被集到urllib.request模块下面了，以先来看下urlopen函数基本的使用： from urllib import request resp = request.urlopen(&apos;http://www.baidu.com&apos;) print(resp.read()) 实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。 也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。 以下对urlopen函数的进行详细讲解：url：请求的url。 data：请求的data，如果设置了这个值，那么将变成post请求。 返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。 urlretrieve函数：这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地： from urllib import request request.urlretrieve(&apos;http://www.baidu.com/&apos;,&apos;baidu.html&apos;) urlencode函数：用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。 而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据。 示例代码如下： from urllib import parse data = {&apos;name&apos;:&apos;爬虫基础&apos;,&apos;greet&apos;:&apos;hello world&apos;,&apos;age&apos;:100} qs = parse.urlencode(data) print(qs) parse_qs函数：可以将经过编码后的url参数进行解码。示例代码如下： from urllib import parse qs = &quot;name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100&quot; print(parse.parse_qs(qs)) urlparse和urlsplit： 有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用urlparse或者是urlsplit来进行分割。示例代码如下： from urllib import request,parse url = &apos;http://www.baidu.com/s?username=zhiliao&apos; result = parse.urlsplit(url) # result = parse.urlparse(url) print(&apos;scheme:&apos;,result.scheme) print(&apos;netloc:&apos;,result.netloc) print(&apos;path:&apos;,result.path) print(&apos;query:&apos;,result.query) urlparse和urlspliturlparse和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。 比如有一个url为：url = &apos;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&apos;， 那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。 request.Request类：如果想要在请求的时候增加一些请求头，那么就必须使用request.Request类来实现。比如要增加一个User-Agent，示例代码如下： from urllib import request headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos; } req = request.Request(&quot;http://www.baidu.com/&quot;,headers=headers) resp = request.urlopen(req) print(resp.read()) ProxyHandler处理器（代理设置）很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。 所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。 urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理： from urllib import request # 这个是没有使用代理的 # resp = request.urlopen(&apos;http://httpbin.org/get&apos;) # print(resp.read().decode(&quot;utf-8&quot;)) # 这个是使用了代理的 handler = request.ProxyHandler({&quot;http&quot;:&quot;218.66.161.88:31769&quot;}) opener = request.build_opener(handler) req = request.Request(&quot;http://httpbin.org/ip&quot;) resp = opener.open(req) print(resp.read()) 常用的代理有：西刺免费代理IP：http://www.xicidaili.com/ 快代理：http://www.kuaidaili.com/ 代理云：http://www.dailiyun.com/ 什么是cookie：在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。 cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地， 当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。 cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。 cookie的格式：Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE 参数意义： NAME：cookie的名字。 VALUE：cookie的值。 Expires：cookie的过期时间。 Path：cookie作用的路径。 Domain：cookie作用的域名。 SECURE：是否只在https协议下起作用。 使用cookielib库和HTTPCookieProcessor模拟登录：Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。 这里以人人网为例。 人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。 解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下： from urllib import request headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;, &apos;Cookie&apos;: &apos;anonymid=jacdwz2x-8bjldx; depovince=GW; _r01_=1; _ga=GA1.2.1455063316.1511436360; _gid=GA1.2.862627163.1511436360; wp=1; JSESSIONID=abczwY8ecd4xz8RJcyP-v; jebecookies=d4497791-9d41-4269-9e2b-3858d4989785|||||; ick_login=884e75d4-f361-4cff-94bb-81fe6c42b220; _de=EA5778F44555C091303554EBBEB4676C696BF75400CE19CC; p=61a3c7d0d4b2d1e991095353f83fa2141; first_login_flag=1; ln_uact=970138074@qq.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn121/20170428/1700/main_nhiB_aebd0000854a1986.jpg; t=3dd84a3117737e819dd2c32f1cdb91d01; societyguester=3dd84a3117737e819dd2c32f1cdb91d01; id=443362311; xnsid=169efdc0; loginfrom=syshome; ch_id=10016; jebe_key=9c062f5a-4335-4a91-bf7a-970f8b86a64e%7Ca022c303305d1b2ab6b5089643e4b5de%7C1511449232839%7C1; wp_fold=0&apos; } url = &apos;http://www.renren.com/880151247/profile&apos; req = request.Request(url,headers=headers) resp = request.urlopen(req) with open(&apos;renren.html&apos;,&apos;w&apos;) as fp: fp.write(resp.read().decode(&apos;utf-8&apos;)) 但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储cookie的对象。而HTTPCookieProcessor处理器主要作用是处理这些cookie对象，并构建handler对象。 http.cookiejar模块：该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下： CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。 FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。 MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。 LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。 登录人人网： 利用http.cookiejar和request.HTTPCookieProcessor登录人人网。相关示例代码如下： from urllib import request,parse from http.cookiejar import CookieJar headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos; } def get_opener(): cookiejar = CookieJar() handler = request.HTTPCookieProcessor(cookiejar) opener = request.build_opener(handler) return opener def login_renren(opener): data = {&quot;email&quot;: &quot;970138074@qq.com&quot;, &quot;password&quot;: &quot;pythonspider&quot;} data = parse.urlencode(data).encode(&apos;utf-8&apos;) login_url = &quot;http://www.renren.com/PLogin.do&quot; req = request.Request(login_url, headers=headers, data=data) opener.open(req) def visit_profile(opener): url = &apos;http://www.renren.com/880151247/profile&apos; req = request.Request(url,headers=headers) resp = opener.open(req) with open(&apos;renren.html&apos;,&apos;w&apos;) as fp: fp.write(resp.read().decode(&quot;utf-8&quot;)) if __name__ == &apos;__main__&apos;: opener = get_opener() login_renren(opener) visit_profile(opener) 保存cookie到本地：保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名： from urllib import request from http.cookiejar import MozillaCookieJar cookiejar = MozillaCookieJar(&quot;cookie.txt&quot;) handler = request.HTTPCookieProcessor(cookiejar) opener = request.build_opener(handler) headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos; } req = request.Request(&apos;http://httpbin.org/cookies&apos;,headers=headers) resp = opener.open(req) print(resp.read()) cookiejar.save(ignore_discard=True,ignore_expires=True) 从本地加载cookie：从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法： from urllib import request from http.cookiejar import MozillaCookieJar cookiejar = MozillaCookieJar(&quot;cookie.txt&quot;) cookiejar.load(ignore_expires=True,ignore_discard=True) handler = request.HTTPCookieProcessor(cookiejar) opener = request.build_opener(handler) headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos; } req = request.Request(&apos;http://httpbin.org/cookies&apos;,headers=headers) resp = opener.open(req) print(resp.read()) requests库虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。 安装和文档地址：利用pip可以非常方便的安装： pip install requests 中文文档：http://docs.python-requests.org/zh_CN/latest/index.html github地址：https://github.com/requests/requests 发送GET请求：最简单的发送get请求就是通过requests.get来调用： response = requests.get(&quot;http://www.baidu.com/&quot;) 添加headers和查询参数：如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下： import requests kw = {&apos;wd&apos;:&apos;中国&apos;} headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;} # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode() response = requests.get(&quot;http://www.baidu.com/s&quot;, params = kw, headers = headers) # 查看响应内容，response.text 返回的是Unicode格式的数据 print(response.text) # 查看响应内容，response.content返回的字节流数据 print(response.content) # 查看完整url地址 print(response.url) # 查看响应头部字符编码 print(response.encoding) # 查看响应码 print(response.status_code) 发送POST请求：最基本的POST请求可以使用post方法： response = requests.post(&quot;http://www.baidu.com/&quot;,data=data) 传入data数据：这时候就不要再使用urlencode进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码： import requests url = &quot;https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0&quot; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&apos; } data = { &apos;first&apos;: &apos;true&apos;, &apos;pn&apos;: 1, &apos;kd&apos;: &apos;python&apos; } resp = requests.post(url,headers=headers,data=data) # 如果是json数据，直接可以调用json方法 print(resp.json()) 使用代理：使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。示例代码如下： import requests url = &quot;http://httpbin.org/get&quot; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;, } proxy = { &apos;http&apos;: &apos;171.14.209.180:27829&apos; } resp = requests.get(url,headers=headers,proxies=proxy) with open(&apos;xx.html&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as fp: fp.write(resp.text) cookie：如果在一个响应中包含了cookie，那么可以利用cookies属性拿到这个返回的cookie值： import requests url = &quot;http://www.renren.com/PLogin.do&quot; data = {&quot;email&quot;:&quot;970138074@qq.com&quot;,&apos;password&apos;:&quot;pythonspider&quot;} resp = requests.get(&apos;http://www.baidu.com/&apos;) print(resp.cookies) print(resp.cookies.get_dict()) session：之前使用urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。 那么如果使用requests，也要达到共享cookie的目的，那么可以使用requests库给我们提供的session对象。 注意，这里的session不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用requests来实现。 示例代码如下： import requests url = &quot;http://www.renren.com/PLogin.do&quot; data = {&quot;email&quot;:&quot;970138074@qq.com&quot;,&apos;password&apos;:&quot;pythonspider&quot;} headers = { &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot; } # 登录 session = requests.session() session.post(url,data=data,headers=headers) # 访问大鹏个人中心 resp = session.get(&apos;http://www.renren.com/880151247/profile&apos;) print(resp.text) 处理不信任的SSL证书：对于那些已经被信任的SSL整数的网站，比如https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下： resp = requests.get(&apos;http://www.12306.cn/mormhweb/&apos;,verify=False) print(resp.content.decode(&apos;utf-8&apos;))]]></content>
  </entry>
  <entry>
    <title><![CDATA[web安全]]></title>
    <url>%2F2018%2F10%2F03%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[安全问题： 1. 用户身份被盗用 2. 用户密码泄露 3. 用户资料被盗取 4. 网站数据库是否泄露 5. 其他 攻击种类： 1. 跨站脚本攻击XSS 2. 跨站请求伪造攻击 3. 前端Cookies安全性 4. 点击劫持攻击 5. 传输过程安全问题 6. 用户密码安全问题 7. SQL注入攻击 8. 信息泄露和社会工程学 配置环境： 1. 安装npm 2. 安装node.js 3. npm install nodemon -g（一旦更改代码就自动重启，不用手动重启了 -g 是global全局的意思） 4. 安装mysql XSSCross Site Scripting ：跨站脚本攻击 跨站：我的网站，自然希望网站里面所有的逻辑都来自自己写的代码。如果我的网站运行了来自其他网站的脚本，就叫跨站。 这样一来人为的给网页一个脚本，一般来说只要是网页脚本能做的事情，xss注入的脚本都能做。 1. 获取页面数据 2. 获取Cookies 3. 劫持前端逻辑（改变原有的逻辑） 4. 发送请求（通过图片，form等方式发送到攻击者指定的网站） 5. 偷取网站的用户数据 6. 偷取网站任意数据 7. 欺骗用户 8. ...... 例如，我在QQ空间内一个说说内混杂了XSS，所有访问的我空间的看到那篇说说的人都会在不知情的情况下向我规定的地方发送我想要的数据 XSS攻击分类反射型直接由url带过去的，页面直接显示这段代码 写好url，再发给别人访问，以此获取访问者数据。 但是可能网址很长，或者一眼能看出 网址包含的脚本，所以用长网址生成短网址这改一下 https://dwz.cn/#/?_k=uu9n2n 存储型XSS被保存在网站数据中，在其他用户访问的时候被其他用户执行 XSS攻击注入点1. HTML节点内容 1. 标签内内容是由用户输入，动态生成的 2. HTML属性 1. 某个标签的属性是由用户输入，定义的 3. JavaScript代码 1. js代码中存在由后台注入的变量，或者用户的输入的数据，有可能导致js代码的逻辑改变 4. 富文本 1. 有各式的html文本 2. qq空间发的说说这种就叫富文本 例如： &lt;img src=&quot;&quot; /&gt; 其中src是用户上传或者输入的 这时，我们上传一个名为 1&quot; onerror=&quot;alert(0) 的文件，这样原本的src就被替换成 &lt;img src=&quot;1&quot; onerror=&quot;alert(0)&quot; /&gt; 例如： js代码从后台拿用户数据，但是用户数据是XSS的脚本 var data = &quot;hello &quot;;alert(1);&quot;&quot;; 例如： qq邮箱中，有文本编辑器，即为富文本。富文本传输的其实就是一堆复杂的html代码，也就是说可以人为的修改其原本想表达的东西 防御XSS1. 浏览器自动拦截 当你的js参数出现在连接中，浏览器会进行自动拦截。 但是防御极其有限，只能防御注入在html和属性中的部分XSS，而js中的和富文本中的并不能拦截 2. 对文本中进行转义 当XSS注入的时候，对 &quot;&lt;&quot; 和 &quot;&gt;&quot;进行转义，使之失去标签的作用 &quot;&lt;&quot; ——&gt; &amp;lt; &quot;&gt;&quot; ——&gt; &amp;gt; 除此之外，html的属性需要 双引号，单引号，或者不需要引号，所以继续转义 &quot; &quot; &quot; ——&gt; &amp;quto; &quot; &apos; &quot; ——&gt; &amp;apos; &quot; &quot; ——&gt; &amp;#32; 3. 对js从后台数据库提取的数据进行转义 转义字符 或者 转换成 json 4. 对于富文本设置 黑名单 或者 白名单 黑名单：禁止某些属性或者标签的出现 优点：好写，只需要进行正则 缺点：html标签属性繁杂，一不小心就容易疏忽某些标签属性 白名单：只允许某些标签或者属性的出现 优点：完全防止禁用标签或者属性的出现 缺点：不好写 CSPContent Security Policy 内容安全策略，用于指定哪些内容可执行 CSP是http的头，规定了有哪些来源，可以限制 1. child-src(页面的自内容), connect-src(网络连接，如ajax), default-src(当其他没指定，就用default) 2. font-src(字体), frame-src(框架), img-src(图片) 3. manifest-src9Webapp的信息), media-src(视频音频), object-src(插件) 4. script-src(脚本), style-src(css), worker-src(servers work等) 定义了一些来源： 1. &lt;host-source&gt;(host规定信任域名)&lt;scheme-source&gt;(根据信任协议判断是否信任) &apos;self&apos;(同域可信任) 2. &apos;unsage-inline&apos;(指定是否信任直接插入页面的内容) &apos;unsafe-eval&apos; (是否调用eval，函数)&apos;none&apos;(不信任任何内容) 3. &apos;nonce-&lt;base64-value&gt;&apos;(指定一个一次性的内容，) &lt;hash-source&gt;(后台定义hash表，前端计算跟hash相同的才会执行) 4. &apos;strict-dynamic&apos;(信任脚本之后，脚本新链接的网站或者其他脚本是否信任) 基本格式： Content-security-Policy:default-src &apos;self&apos; http://example.com;connect-src &apos;non1&apos;; Content-Security-Policy:connect-src http://example.com;script-src http://example.com/ &lt;meta http-equiv=&quot;Content-Srcurity-Policy&quot; content=&quot;default-src https;&quot;&gt; CSRFCross Site Request Forgy 跨站请求伪造 例如： 我在A网站登陆了A网站的账号，我打开了B网站，B网站有脚本可以让我在不知情的情况下对A网站进行了操作，比如获取隐私数据，转账等 CSRF的运行顺序1. B网站向A网站 2. 带A网站的Cookies 3. 不访问A网站前端 4. referer为B网站 CSRF的特征1. 利用用户登陆态 2. 用户不知情 3. 完成业务请求 4. ...... CSRF的危害1. 盗取用户资金（转账，消费） 2. 冒充用户发帖背锅 3. 损害网站名誉 4. ...... CSRF的防御进制第三方网站带CookiesCookies新带了 same-site属性，也就是说只有来自同一网站的请求才能带Cookies Cookies添加SameSite属性： SameSite = Strict：不允许任何链接带Cookies SameSite = Lax：允许部分带Cookies，但是像ajax这种不能带Cookies SameSite = true 在前端页面加入验证信息既然CSRF不经过前端，那么设置一下，只有你经过前端才能访问到数据，那么也许可以拦截CSRF的攻击 验证码通过图形验证码的方式，攻击者网站是无法知道随机的验证码是多少的 缺点： 1. 有局限性，毕竟不能给所有操作加上验证码 2. 用户体验不好 tokentoken是服务端生成的一串字符串，以作用户端进行请求的一个令牌，当第一次登陆之后，服务器生成一个token并将此返回给客户端。 以后客户端只要带上这个token就行了，不需要带上用户密码 提交的时候必须加上token信息才能生效，而只有经过前端才能获得token，也就是说通过这种方式可以防止第三方平台的不知情操作 什么是referer上面 &quot;CSRF的运行顺序&quot; 中提到了referer是什么呢？ referer是HTTP协议中的一个请求头，包含了请求时来自哪里的信息。 所以CSRF中的referer中的请求位置时 攻击者 网站 很容易的我们可以想到，验证请求位置是否是正常用户端来防止CSRF的发生 其实 referer 的拼写应该是 referrer，所以这个是为数不多的错误拼写的单词 前端Cookies问题Cookies是什么？ 1. 它是一个前端数据的存储，它的存储是放在前端的。 2. 后端可以通过http头设置Cookies的值。 3. 请求时通过http头传给后端 4. 前端也可以读写Cookies 5. 遵守同源策略：当协议，域名，端口全部一致的时候才能读写 前端只要通过 &quot;document.cookie&quot; 就可以取到Cookies了，追加可以直接 &quot; document.cookie = &quot;userId=2&quot; &quot; Cookies 可以修改原来的值，也能追加新的值，而且Cookies有自己的结构 Cookies 的特性1. Cookies 有一个域名，表明在哪些地方可以使用 2. Cookies 有一个有效期，表明在那段时间可以用 3. Cookies 有一个路径，表明用在网络的哪一级，就像url层级一样 4. Cookies 只能被http协议使用，即http-only 5. secure 指定Cookies能否在 https中使用 以上都可以在开发者工具中看到，可以通过js查看： document.cookie 在 父路径中无法查看 子路径的Cookies 例如： 127.0.0.1:8080 界面无法看到 127.0.0.1:8080/user/login 中的Cookies，但反过来就可以 Cookies没有删除方法，想删除Cookies只有设置Cookies的有效期为过去的时间，才能删除Cookies Cookies作用1. 存储个性化设置 1. 用户在我的网站用的什么皮肤 2. 用户上次浏览到那个界面 3. 某个菜单是打开还是关闭 2. 存储未登录时用户唯一标识 3. 存储已登录用户的凭证 4. 存储其他业务数据 Cookies-登陆用户凭证1. 前端提交用户名和密码 2. 后端验证用户名和密码 3. 后端设置http头，设置用户凭证 1. 用户ID（不安全，容易被篡改） 2. 用户ID+签名（签命通过自己的算法算出，安全性高） 3. SessionID（随机的字符串） Cookies 和 CSS的关系XSS可能偷取Cookies http-only的Cookies有几率避免Cookies被盗 Cookies 和 CSRF的关系CSRF利用了用户的Cookies发送数据等 但是攻击站点无法读写Cookies 最好能阻止第三方使用Cookies Cookies-安全策略1. 加签命放篡改（数据是明文，只是验证有没有被修改） 2. 私有变换（加密） 3. http-only（防止XSS） 4. secure 5. same-site 点击劫持操作是用户完成，但是并不是用于自主意愿完成的 通过用户的点击完成某个操作，但是用户并不知情。 例如： 用户登录网站A，此时打开网站B，在网站B上的点击操作，实际上应用在的网站A中 B网站里面其实是一个&lt;iframe&gt;，将A网站的架构放在了&lt;iframe&gt;中，然后通过设置opcity来隐藏这个&lt;iframe&gt;，再然后就给&lt;body&gt;一个背景贴图 贴图中有按钮样子的图片，也有其他的图片，混淆视听，当用于点击贴图中的图片的时候，其实点的是&lt;iframe&gt;中的按钮 点击劫持的特征1. 用户亲手操作 2. 用户不知情 3. ...... 点击劫持的危害1. 盗取用户资金（转账，消费） 2. 获取用户敏感信息 3. ...... 点击劫持的防御点击劫持攻击的前提是 通过&lt;iframe&gt;将目标网站嵌套到自己网站 用Javascript禁止内嵌在js中，如果没有内嵌那么 top === window 如果被内嵌了，top 并不是 === window，&lt;iframe&gt;中的window就是&lt;iframe&gt;的window 但是 top 指的是 &lt;body&gt;的window if(top.location != window.location){ top.location = window.location } 通过上面的代码，窗口会进行跳转，跳转到&lt;iframe&gt;的界面，也就是原界面 但是 &lt;iframe&gt;中，有一个sandbox属性来限制&lt;iframe&gt;的功能，例如禁掉js的能力，所以js并不能百分百解决点击劫持 X-FRAME-OPTIONS 直接禁止内嵌ctx.set(&apos;X-FRAME-OPTIONS&apos;, &apos;DEMY&apos;); DENY 禁止内嵌 SAME-ORIGIN 同一个网站可以使用 SAMEORIIN 嵌入页和被嵌入页在同一域下 ALLOW-FROM+网站 允许指定网址内嵌 其他辅助手段1. 验证码 2. ...... HTTP传输窃听HTTP是一个明文协议，也就是说不会对数据进行加密 客户端和服务器的发送都是明文的 而数据包会经过很多中间节点，而这些节点愿意的话可以修改这些数据 1. 窃听 开启服务器代理，http请求可以直接查看文件请求头，响应头，响应body。 2. 篡改 在代理软件中，修改资源文件为我电脑中的资源文件，那么在客户端看到或显示的我的资源 窃听和篡改窃听：你传输过程中的所有数据可以直接被别人看到 1. 窃听用户密码 2. 切丁患处敏感信息 3. 非法获取个人资料 篡改：在传输过程中，修改或者插入信息 1. 插入广告 2. 重定向网站 3. 无法防御的XSS和CSRF攻击（如果修改了html或者js，那么我们做的防御没有任何意义） HTTPSHTTP协议是明文协议，中间方就可以直接查看篡改。 HTTPS TLS(SSL)加密 在 传输层加密 TLS 就是 SSL，现在称之为TLS，以前是SSL 中间人攻击中间人对客户端来说是服务器，对服务器来说是客户端，它是一个伪装的设备 也就是说，中间人可以查看客户端与服务器之间的通信，而不受TLS加密的影响 确认服务器身份CA：数字证书中心 保证安全的点： 1. 证书无法被伪造 2. 证书私钥不被泄露（恶意攻击者盗用私钥，可以查看篡改） 3. 域名管理权不能泄露（一旦泄露，被恶意攻击者指向自己的服务器，证书就会给攻击者的服务器而不给你） 4. CA坚守原则（验证不通过，不给证书） 密码安全密码的作用&quot;证明你是你&quot;，说白了就是证明一下登陆操作的人是合法用户 原理很简单，就是申请账号的时候是你最开始设置的密码和你现在使用的密码相同，对比一下就是了 密码泄露渠道1. 数据库被偷 2. 服务器被入侵 3. 通讯过程被窃听 4. 内部人员泄露数据 5. 其他网站（撞库，A网站的数据泄露，攻击者拿着用户的密码试用户在其他网站的密码） 6. ...... 密码存储1. 严禁密码的明文存储（防泄露，数据库中存储不用明文，加密） 2. 单向变换（一个密码对应一个密文） 3. 变化复杂度要求（防猜解） 4. 密码复杂度要求（防猜解） 5. 加盐（放猜解） 哈希算法——信息摘要算法明文-密文 一一对应 雪崩效应 只要明文有一点不一样，密文完全不一样 密文-明文 无法反推 密文固定长度 一般来说32为字符串 常见哈希算法 md5, sha1, sha256 密码单项变化彩虹表以md5为例，先暴力出所有的可能的明文的密文，然后根据窃听得到的密文去反过来查明文。这样子存着所有结果的密文表就被成为彩虹表 1. 混合加密 但是我们可以 混合多种加密算法，例如： md5(明文) = 密文 md5(md5(明文)) = 密文 md2(sha1(明文)) = 密文 md5(sha256(sha1(明文))) = 密文 这样子就算是查彩虹表，最后得到的可能很难是正确的 2. 复杂密码 虽然可以用算密文反过去映射明文，但是位数越多，越复杂的密码，破解所需的时间和内存就越大，一个20为的密码需要900G的硬盘来存储密码 加盐md5（ID + 原始密码 + 盐（随机生成的字符串） + 固定随机串（服务器一开始就定义的不变的字符串）*N个（顺序随意））= 最终密码 就是自动的给原始密码一个复杂的字符串，让其安全 密码变化次数越安全1. 加密成本几乎不变（生成密码时速度慢一些，但是只生成一次） 1. 对使用者来说，这点时间几乎是小事 2. 对解密者来说，破解时间成倍增加 2. 彩虹表失效（数量太大，无法建立链接） 3. 解密成本增加N倍 密码传输的安全性1. https传输 2. 频率限制（限制固定时间内只能登陆多少次） 3. 前端加密意义有限（传输层窃听并不知道明文密码，但是攻击者也可以传输你传输的密文） 生物特征密码1. 指纹（唇纹） 2. 声纹 3. 虹膜 4. 人脸 缺陷1. 私密性-容易泄露（指纹随时可以提取，圣文也是，人脸也是） 2. 安全性-碰撞（可能出现识别错误） 3. 唯一性-终身唯一 无法修改（如果别人获取了你的密码，你不能去改你的指纹密码对吧） 接入层注入问题关系型数据库1. 存放结构化数据 2. 可搞笑操作大量数据（维护，查询） 3. 方便处理数据之间的关联关系 4. 常见的：access/sqlite/mysql/mssql server SQL语言数据库查询语言 1. 被广泛接受的语言，各大数据库都能接受，已经被标准化 2. 但是标准话并不代表完全语言，每个数据库的SQL都有一点不一样 3. 类似自然语言 4. 用于关系型数据库 SQL注入在web中，数据库操作都是通过事先定义的代码实现的，毕竟用户不可能直接操作数据库 例如： select * from table where id = ${id}; 什么是注入如果用户传入的是一个 &quot; 1 or 1 = 1 &quot;，这个是一个id 但是插入到sql中变成了： select * from table where id = 1 or 1 = 1; 类似于XSS，去用传入的数据修改原本的逻辑结构 例如： select * from user where username = &apos;${data.username}&apos; and password = &apos;${data.password}&apos; 这个时候，用户传入的是 &quot;username&quot; &quot;1&apos; or &apos;1&apos;=&apos;1&quot; 那么原本的查询语句就变成了： select * from user where username=&apos;username&apos; and password = &apos;1&apos;or&apos;1&apos;=&apos;1&apos; 那么很容易发现， &quot; or &quot;这个关键字 否认了前面所有的判断，导致攻击者随便找个账户都能登陆 注入方法1. 在网址后加上 &quot; and 1=1 &quot;网页不会产生变化 2. 但是加上 &quot; and 1=0 &quot; 网页就变化报错了，通过这个可以检查是否有sql注入的危险 3. 或者插入 &quot; or 1=1 &quot;访问一些当前用户没有权限访问的页面 4. 同理通过 &quot;and union(version(), 1, 1)=6&quot;来判断数据库的版本位数第一位是否是6，这种方式获得数据库信息 5. 知道数据库的信息，可以查看该版数据库的漏洞 6. 还有通过其他的sql语句可以探测到 数据库的字段，例如ID，password是否存在，来推测表的结构 7. 这里只介绍了很小很小的一部分，还有很多可以去搜索 sql注入的危害1. 猜解密码（用工具很快） 2. 获取数据（信息泄露） 3. 删库删表 4. 拖库 5. ...... SQL注入防御1. 关闭错误输出 1. 攻击者通过错误输出信息来判断注入方向是否正确 2. 检查数据类型 例如： 120.0.0.1/post/10中10是页面的id 但是 攻击者通过 120.0.0.1/post/100 or 1=1来随机的查看页面 这个时候只要判断后面的值是否是数字，就能判断出是否是攻击者，我们只接收前面的10，不接受后面的字符串 3. 对数据进行转义（escape()模块） 因为上面只是简单的id，但是有的时候搜索需要字符，所以不能一棒子打死 对于某些情况，可以通过转义来限制用户输入的意思，防止注入语句 4. 使用参数化查询（需要安装mysql2） 先告诉数据库，我要传一个id，你帮我找一下 再传一个id过去，不管这个id是什么，数据库只会查找id而不会执行这个id 先给个意图，再给参数 npm install mysql2 --save 5. 使用ORM（对象关系映射） 把数据库的数据，通过代码的对象映射出来，一个对象就是一个记录 一般语言都有人写好了ORM npm install sequelize --save（node.js的ORM） NoSQL非关系型数据库，不同于sql，一定程度上可以防御sql注入 但是也是可以sql注入的 防御方式1. 检查数据类型 2. 类型转换 3. 写完整条件 接入层上传问题上传问题1. 上传文件 2. 再次访问上传的文件 3. 上传的文件被当成程序解析 如果上传的文件只是图片，音频就还行，但是如果是可执行文件就会出现大问题，因为攻击者的逻辑会被执行 所以需要判断上传文件的后缀等，防止不符合要求的文件上传 社会工程学信息泄露1. 泄露系统敏感信息 2. 泄露用户敏感信息 3. 泄露用户密码 信息泄露的途径1. 错误信息失控 2. sql注入 3. 水平权限控制不当 4. XSS/CSRF 5. 快递单/房产中介 6. ...... 社会工程学通过渠道挖出你的个人信息 仅仅通过你的昵称，查出你的姓名，进而查到更多隐私信息，然后建立出一个个人数据模型 你的身份由你掌握的资料确定，当你的个人信息被别人掌握，别人就可以伪装成你的身份，然后用你的身份去做坏事 社会工程学案例电信诈骗（徐玉玉案件）为什么会出现电信诈骗，因为骗子通过掌握的关于你的信息去获取你的信任 高考录取之后，成绩公示，报纸公示，让徐玉玉的个人信息被不法分子获取，并且利用这些信息进行诈骗 伪装公检法处于对公检法的信任，外加对方可以报出你的个人信息，甚至一些私人信息，你不会怀疑对方 QQ视频借钱伪装好友，发送QQ视频，由于信息泄露可以获取一个人的视频，声音 微信伪装好友就算一开始你不信，但是久而久之你就以为她是你的好友 OAuth思想即 现在网站的 授权登陆 的思想 access Token为每个用户对应的那一个Token，所以每次查询，只能查一个人，一定范围内保护用户资料 特点： 1. 一切行为由用户授权 2. 授权行为不泄露敏感信息 3. 授权会过期 利用OAuth思想防止资料泄露 1. 用户授权读取票据 2. 无授权的资料不能读取（防止一个人查询其他人的资料） 3. 不允许批量获取数据、 4. 数据接口可风控审计（获取查询数据的时间，位置等） 其他安全问题拒绝服务 DOS模拟正常用户访问网站，但是访问量成千上万甚至过亿，来占用服务器大量的资源，以至于网站不能正常打开访问 攻击方式1. TCP半连接 TCP的三次握手，我们只发送第一次请求，让服务器处于准备好并等待我们第三次握手的状态，这个时候就会影响服务器工作 2. HTTP链接 3. DNS 当TCP和HTTP的潮水攻击都被防下来的时候，转而攻击你的DNS（域名解析服务器） 大范围分布式拒绝服务攻击DDOS在DOS的基础上，用大范围的机器攻击网站服务器 1. 流量可达几十到上百G 2. 分布式（肉鸡，代理） 3. 极难防御（无法辨别正常用户和恶意用户） DOS攻击防御1. 防火墙（防火墙有办法尝试过滤恶意流量） 2. 交换机，路由器（只能防护小范围） 3. 流量清洗（对流量进行分析，找出特征，分辨正常访问） 4. 高防IP（云服务提供的，当面对DOS攻击时，把IP转为服务器提供商提供的另一个IP，而另一个IP拥有大规模的流量清洗服务） 5. 编写代码时 避免重逻辑业务 6. 快速失败快速返回 7. 防雪崩机制 8. 有损服务 9. CDN（静态网页发送到CDN上，减少服务器的压力） 重放攻击请求被窃听或记录，再次发送相同的请求，产生意外的结果 例如： 1. 用户被多次消费 2. 用户登陆态被盗取（重新发送之后，伪装成原用户） 3. 多次抽奖 重放冲击防御1. 加密（HTTPS） 2. 请求加时间戳（防止二次发送） 3. 加上token（session，每次发送的token都会变化，那么同样的请求 token就会很容易识别出来） 4. nonce（num+once，是只用一次的数字，就像ID一样） 5. 数字签名]]></content>
  </entry>
  <entry>
    <title><![CDATA[从0开始的JavaWeb---H5篇]]></title>
    <url>%2F2018%2F09%2F29%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%2F</url>
    <content type="text"><![CDATA[Html什么是Html？HyperText Markup Language：超文本标记语言 ** 超文本：超出文本的范畴，使用html可以轻松实现 ** 标记：html所有的操作都是通过标记实现的。标记，就是标签 ** 网页语言：超文本标记语言 第一个html程序：例如：创建Java文件 后缀名为.java **先编译，后运行（jvm） 同理：html文件后缀是.html **直接通过浏览器就可以运行 html规范：1. 一个html文件开始标签和结束的标签&lt;html&gt;&lt;/html&gt; 2. html包含两个部分内容： &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; 3. html的标签有开始标签，也要有结束标签 4. html的代码不区分大小写&lt;font&gt; == &lt;FONT&gt; 5. 部分标签没有结束标签： 例如：&lt;br /&gt;//内部加个&quot;/&quot;，标签内结束 *html的操作思想：网页中有很多的数据，不同的数据可能需要不同的显示效果，这个时候需要使用标签把要操作的数据封装起来，通过修改标签的属性值实现标签内数据样式的变化。 一个标签就像等于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内的数据样式的变化。 html中常用的标签文字标签和注释标签*文字标签：修改文字的样式例如：&lt;font&gt; &lt;/font&gt; 属性：color : 文字颜色(颜色的英文单词，或者十六进制rgb) size : 文字大小（1~7） 注释标签Java的注释有三种：&quot;//&quot; , &quot;/* */&quot; &quot;/*****/&quot; html的注释: &lt;!-- 注释内容 --&gt;(源文件可以查看的注释) 标题标签，水平线标签和特殊字符标题标签&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt; ~~~~ &lt;h6&gt;&lt;/h6&gt; 文字大小 从h1 到 h6 以此变小，并且每个标签都会自动换行 水平线标签&lt;hr /&gt; 标签内结束 属性： **size：水平线的粗细 **color：水平线的颜色 特殊字符想在网页中显示 &quot;&lt;html&gt;是一个特殊标签&quot; 如果直接写 &quot;&lt;html&gt;是一个特殊标签&quot;，则只会显示 &quot;是一个特殊标签&quot; 需要转义&quot;&lt;html&gt;&quot;： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 &amp;nbsp; ---&gt; &quot; &quot; 空格转义 列表标签如果想在网页显示 列表的效果。 &lt;dl&gt;&lt;/dl&gt;：表示列表的范围 在&lt;dl&gt;里面 &lt;dt&gt;&lt;/dt&gt;：上层内容 在&lt;dl&gt;里面 &lt;dd&gt;&lt;/dd&gt;：下层内容 例如： &lt;dl&gt; &lt;dt&gt;学习内容&lt;/dt&gt; &lt;dd&gt;java&lt;/dd&gt; &lt;dd&gt;C++&lt;/dd&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dt&gt;学习进度&lt;/dt&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;/dl&gt; 学习内容javaC++Python学习进度没学没学没学 &lt;ol&gt;&lt;ol&gt;：有序列表的范围 在&lt;ol&gt;&lt;/ol&gt;标签内部：&lt;li&gt; 属性： type：这是排序方式 默认（缺省）为 1. 2. 3.... type = &quot;a&quot; type = &quot;i&quot; 例如： &lt;ol type=&quot;a&quot;&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;/ol&gt; javaC++Python &lt;ul&gt;&lt;/ul&gt;：无序列表的范围属性： type： circle 空心圆 disc 实心圆（默认） square 实心方块 &lt;ol type=&quot;a&quot;&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;/ol&gt; java C++ Python &lt;img&gt;图像标签（重点）&lt;img src=&quot;a.jpg&quot; width=&quot;宽像素&quot; height=&quot;高像素&quot; alt=&quot;显示的文字&quot;/&gt; --src：图片的路径 --width：图片的宽度 --height：图片的高度 --alt：图片上显示的文字，把鼠标移动到图片上面，停留片刻显示内容 路径的介绍第一类：绝对路径D:\blog\lc_love_hehe\source\_posts\p.jpg http://www.baidu.com/b.jag 第二类：相对路径一个文件相对于另外一个文件的位置 三种写法： 当图片与html在同一个文件夹内，直接使用 b.jpg 当图片在html的同级文件夹img中，使用img/b.jpg 当图片在html的上级文件夹中，../b.jpg 超链接连接资源&lt;a href=&quot;连接到资源的路径&quot;&gt;显示在页面上的内容&lt;/a&gt; href：连接的资源的地址 target：设置打开的方式，默认是当前页打开。 _blank：在新窗口打开 _self：当前页打开 当超链接不需要到任何地址的时候，href=&quot;#&quot; &lt;a href=&quot;https://usuiforhe.github.io/&quot; target=&quot;_blank&quot;&gt;test&lt;/a&gt; 定位资源&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;//定义顶部的位置 &lt;a name=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;//定位到网页中name为top的位置，记得加上# &lt;pre&gt;原样输出 例如： public static void main(String[] args){ Syste.out.println(&quot;hello world&quot;); } &amp;lt;pre&amp;gt; public static void main(String[] args){ Syste.out.println(&quot;hello world&quot;); } &amp;lt;/pre&amp;gt; public static void main(String[] args){ Syste.out.println(“hello world”);} public static void main(String[] args){ Syste.out.println(“hello world”);}加上了 &lt;pre&gt; 标签后，原本一行的代码，变成了我们要的换行的效果 表格标签可以对数据进行格式化，使数据显示更加清晰 &lt;table&gt;&lt;/table&gt;:表示表格的范围 在&lt;table&gt;里面： &lt;caption&gt;表格标题 在&lt;table&gt;里面： &lt;tr&gt; 在&lt;tr&gt;里面：&lt;td&gt; 画图分析表格的写法： 首先定义一个表格的范围使用table 定义一行使用 tr 定义一个单元格使用 td 操作技巧： 首先数有多少行，数每行里有多少个单元格 例如： &lt;table&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;学习进度&lt;/td&gt; &lt;td&gt;梦想&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;python&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;td rowspan=&quot;3&quot;&gt;想学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C++&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 属性： &lt;table&gt;中： border：表格线的粗细 bordercolor：表格线的颜色 cellspacing：表格之间的距离 align：left center right 框中文字的位置 &lt;td&gt;中： colspan：0~无穷大，跨列 rowspan：0~无穷大，跨行 学科 学习进度 梦想 python 没学 想学 C++ 没学 Java 没学 表单标签可以提交数据到服务器的标签，这个过程可以使用表单标签实现 &lt;form&gt;&lt;/form&gt;：定义表单范围输入项：可以输入内容或者选择内容的部分 大部分的输入项 使用 &lt;input type = “输入类型” /&gt; Input 类型：type = &quot;email/url/number/range/date picker/search/color/tel&quot; &lt;input type=&quot;password&quot;&gt;密码框 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男 单选框 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;苹果&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;香蕉&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;栗子 多选框 &lt;input type = &quot;url&quot; name = &quot;url&quot;&gt; 手机端弹出字母键盘，电脑端无差别 &lt;input type = &quot;email&quot; name = &quot;email&quot;&gt; 手机端弹出字母键盘，电脑端无差别 &lt;input type = &quot;tel&quot; name = &quot;tel&quot;&gt; 手机端弹出数字键盘，电脑端无差别 &lt;input type = &quot;number&quot; name = &quot;number&quot;&gt; 手机端弹出数字键盘，电脑端右边多处两个按钮控制加减，只能输入参与运算的内容“+ - . 1 2 3 4 5 6 7 9 e” data picker input类型: date —— 选取 日， 月， 年 month —— 选取月，年 week —— 选取 周和年 time —— 选取时间（小时和分钟） datetime —— 选取时间，日，月，年（utc时间） datetime-local —— 选取时间，日，月， 年（本地时间） 使用方法一样 &lt;input type = &quot;date&quot; name = &quot;date&quot; &gt; 手机端显示的是 日期键盘 &lt;input type = &quot;range&quot; name = &quot;range&quot; min = &quot;最小值&quot; max = &quot;最大值&quot;&gt; &lt;input type = &quot;image&quot; src=&quot;a.jpg&quot;/&gt;设置按钮为图片，作用是提交 &lt;input type = &quot;search&quot; name = &quot;search&quot; &gt; &lt;input type = &quot;color&quot; name = &quot;color&quot;&gt;弹出颜色选择 &lt;input type = &quot;hidden&quot;/&gt; 隐藏项，不会显示在页面中的 &lt;input type = &quot;button&quot; /&gt; 普通按钮 &lt;input type = &quot;submit&quot; /&gt; 提交按钮 &lt;input type = &quot;reset&quot; value=&quot;你想显示的文字&quot;/&gt; 重置按钮 &lt;selsect&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt;下拉选项 &lt;textarea cols=&quot;列数&quot; rows=&quot;行数&quot;&gt;&lt;/textarea&gt; 文本域 最好每个输入项都有个name属性，方便后台提取数据。后台通过name属性获取对应输入的值 表单属性： autocomplete/autofocus/multiple/placeholder/required/action/method action 是提交数据到的那个页面 method 常用的就两种“get”“post”，默认get enctype 关于文件上传的属性 &lt;form autocomplete = &quot;on&quot;（#自动完成功能，存下之前提交过的字段#）action = &quot;****&quot; ausofocous = &quot;&quot;&gt; &lt;input type = &quot;text&quot; name = &quot;text&quot; autofocus = &quot;autofocus&quot;&gt;(#不写 autocomplete 默认开启存储 autofocus 光标自动确定该input#) &lt;input type = &quot;email&quot; name = &quot;email&quot; autocomplete = &quot;off&quot;&gt;（#关闭自动存储#） &lt;input type = &quot;file&quot; multiple = &quot;muliple&quot; / &gt;(#muliple 是乘法，代表多个的意思，同时上传多个文件#) ps. multiple 在类型为type的时候，也可以用，多个邮箱之间用 分号 隔开。 如果没有multiple ，email类型也可以传多个email，但是用了multiple 的 input，会传出一个数组到后台，而没有用的则会传出一整个字符串，难以操作。 &lt;input type = &quot;text&quot; placeholder = &quot;用户名&quot; /&gt;(#提示输入用户名，开始输入时提示消失#) ps. placeholder 适用于： text, search, url, tel, email, password。 &lt;input type = &quot;text&quot; required = &quot;required&quot; /&gt; （#required 规定必须在提交之前填写输入域（不能为空）#） &lt;input type = &quot;submit&quot;&gt; &lt;/form&gt;` 其他标签&lt;b&gt; 加粗 &lt;s&gt; 删除线 &lt;u&gt; 下划线 &lt;i&gt; 斜体 &lt;pre&gt; 原样输出 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;div&gt; 盒子，自带换行 &lt;span&gt; 盒子，不带换行 html的头标签html由两部分组成 head 和 body 在head里面的标签就是头标签 title：显示在标签上显示的内容 base：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标（target属性） 例如： &lt;base target=&quot;_blank&quot;&gt; //这是所有的超链接都是新窗口打开 meta：可以提供有关页面的基本信息 例如： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=01-hello.html&quot;&gt; // refresh 模拟页面请求， 3 3秒后， url 跳转的目标页面 link：定义文档与外部资源的关系 框架标签（过时）&lt;frameset&gt; 属性： rows：按行进行划分 cols：按列进行划分 &lt;frameset rows=&quot;80,*&quot;&gt;划分为两行，第一行高80 &lt;frame&gt; 具体显示的页面 &lt;frame name = &quot;lower_left&quot; src=&quot;b.html&quot;&gt; 使用框架标签时候，不能写在body里面，需要把body去掉。 HTML样例&lt;body&gt; &lt;header&gt; &lt;div&gt;logo&lt;/div&gt; &lt;nav&gt; &lt;a href=&quot;test.html&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;介绍&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;案例&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section&gt; &lt;aside&gt; &lt;a href=&quot;#se1&quot;&gt;setcion1&lt;/a&gt; &lt;a href=&quot;#se2&quot;&gt;section2&lt;/a&gt; &lt;a href=&quot;#se3&quot;&gt;section3&lt;/a&gt; &lt;/aside&gt; &lt;article&gt; Today, Rikka is going to learn how to use BIT to solve some simple data structure tasks. While studying, She finds there is a magic expression x&amp;(−x) in the template of BIT. After searching for some literature, Rikka realizes it is the implementation of the function lowbit(x). lowbit(x) is defined on all positive integers. Let a1...am be the binary representation of x while a1 is the least significant digit, k be the smallest index which satisfies ak = 1. The value of lowbit(x) is equal to 2 k−1 . After getting some interesting properties of lowbit(x), Rikka sets a simple data structure task for you: At first, Rikka defines an operator f(x), it takes a non-negative integer x. If x is equal to 0, it will return 0. Otherwise it will return x − lowbit(x) or x + lowbit(x), each with the probability of 1 2 . Then, Rikka shows a positive integer array A of length n, and she makes m operations on it. There are two types of operations: • 1 L R, for each index i ∈ [L, R], change Ai to f(Ai). • 2 L R, query for the expectation value of ∑R i=L Ai . (You may assume that each time Rikka calls f, the random variable used by f is independent with others.) Input The first line contains a single integer t(1 ≤ t ≤ 3), the number of the testcases. The first line of each testcase contains two integers n, m(1 ≤ n, m ≤ 105 ). The second line contains n integers Ai(1 ≤ Ai ≤ 108 ). And then m lines follow, each line contains three integers t, L, R(t ∈ {1, 2}, 1 ≤ L ≤ R ≤ n). Output For each query, let w be the expectation value of the interval sum, you need to output (w × 2 nm) mod 998244353. It is easy to find that w × 2 nm must be an integer. &lt;/article&gt; &lt;/section&gt; &lt;input placeholder=&quot;选择手机品牌&quot; list=&quot;phtonlist&quot; /&gt;&lt;!--input的list 必须和datalist的id相同--&gt; &lt;datalist id=&quot;phtonlist&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;/datalist&gt; &lt;meter value=&quot;220&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt;&lt;!-- 当前值为220 最低为20 最高为380 标准在200~240之间 最好的取值为220--&gt; &lt;meter value=&quot;180&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt; &lt;meter value=&quot;260&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt; &lt;meter value=&quot;0.75&quot;&gt;75%&lt;/meter&gt; &lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;progress max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;details&gt; &lt;summary&gt;你要显示的标题&lt;/summary&gt; 内容：。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 &lt;/details&gt; &lt;menu type=&quot;toolbar&quot;&gt; &lt;li&gt; &lt;menu aria-label=&quot;File&quot;&gt; &lt;button type=&quot;button&quot;&gt;new1&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new2&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new3&lt;/button&gt; &lt;/menu&gt; &lt;/li&gt; &lt;li&gt; &lt;button type=&quot;button&quot;&gt;new4&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new5&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new6&lt;/button&gt; &lt;/li&gt; &lt;/menu&gt; &lt;footer&gt; copyright...... &lt;/footer&gt; &lt;p&gt;我们来&lt;ruby&gt;聊&lt;rt&gt;liao&lt;/rt&gt;&lt;/ruby&gt;天&lt;/p&gt; &lt;/body&gt; CSS-层叠样式表解释层叠一层一层的，与优先级有关 样式表有很多的属性和属性值，改变标签的属性值，是标签变换 作用CSS将网页内容和显示样式进行分离，提高了显示功能，解决了html代码对样式定义的重复，提高了后期样式代码的可维护性。 CSS和Html的结合方式1. 在每个html标签上都有一个style属性。通过style属性修改标签样式 &lt;span style=&quot;background-color:red; color=green;&quot;&gt;测试&lt;/span&gt; 2. 使用html的一个标签实现 &lt;style&gt; 标签，写在head里面 &lt;style type=&quot;text/css&quot;&gt; div{ background-color:red; color = green }//所有div的样式都这样 &lt;/style&gt; 3. 在&lt;style&gt;标签中使用语句 @import url (css文件的路径) &lt;style type=&quot;text/css&quot;&gt; @import url(div.css) &lt;/style&gt; 4. 使用头标签&lt;link&gt;,引入外部css文件 &lt;link rel=&quot;srtlesheet&quot; type=&quot;text/css&quot; href=&quot;css_3.css&quot; /&gt; Ps.第三种结合方式，缺点：在某些浏览器下不支持。一般来说，是用第四种结合方式。 CSS的优先级从上到下，从外到内，CSS的优先级从低到高。后加载的优先级高。 CSS书写规范1. 选择器名称{ 属性名：属性值； 属性名：属性值； } 2. 属性与属性之间用分号隔开 3. 属性与属性值之间用冒号链接 4. 如果一个属性有多个属性值的话，那么多个值用空格隔开 选择器id选择器&lt;标签 id=&quot;test&quot;&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 #test{ background-color: red; }来选择 id 为test的标签。也就是说 id 前面加上 &quot; # &quot; 类选择器&lt;标签 class=&quot;test&quot;&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 .test{ background-color:red; }来选择 class 为test的标签。也就是说 class 前面加上 &quot; . &quot; 标签选择器&lt;标签&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 标签{ background-color:red; }来选择 标签 class 选择器的优先级 &gt; 标签选择器的优先级id选择器的优先级 &gt; class选择器的优先级标签内部的style属性的优先级 &gt; id 选择器的优先级 关联选择器&lt;div&gt;&lt;p&gt;test&lt;/p&gt;&lt;/div&gt; 要选中 p 标签 那么CSS这样写 div p{ background-color:red; }两个中间一个空格，这样就选中 div 子标签中的 p 标签 组合选择器&lt;div&gt;test111&lt;/div&gt; &lt;p&gt;test222&lt;/p&gt; 想把div和p设置成一样的样式，那么CSS中这么写 div,p{ background-color:red; }中间用逗号连接，表示两个都选中 伪类元素选择器CSS里面提供了一些定义好的样式，可以拿过来使用 原始状态 鼠标放上去的状态 点击 点击之后 ：link ：hover ：active visited 例如CSS文件中： a:link{ background-color: red; } a:hover{ background-color: blue; } a:active{ background-color: black; } 第一个字符 第一行 在文字标签前面加上 :first-letter :first-line ：before 例如CSS文件中： p:before { content:&quot;台词：&quot;; }那么 所有的 p 标签前面 都会加上 &quot;台词&quot; 这两个字 选择符类型 表达式 描述子串匹配的属性选择符 E[att^=”val”] 匹配具有att属性、且值以val开头的E元素 子串匹配的属性选择符 E[att$=”val”] 匹配具有att属性、且值以val结尾的E元素 子串匹配的属性选择符 E[att*=”val”] 匹配具有att属性、且值中含有val的E元素 结构性伪类 E:root 匹配文档的根元素。在HTML中，根元素永远是HTML 结构性伪类 E:nth-child(n) 匹配父元素中的第n个子元素E 结构性伪类 E:nth-last-child(n) 匹配父元素中的倒数第n个结构子元素E 结构性伪类 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E 结构性伪类 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E 结构性伪类 E:last-child 匹配父元素中最后一个E元素 结构性伪类 E:first-of-type 匹配同级兄弟元素中的第一个E元素 结构性伪类 E:only-child 匹配属于父元素中唯一子元素的E 结构性伪类 E:only-of-type 匹配属于同类型中唯一兄弟元素的E 结构性伪类 E:empty 匹配没有任何子元素（包括text节点）的元素E 目标伪类 :target 匹配相关URL指向的E元素 UI元素状态伪类 E:enabled 匹配所有用户界面（form表单）中处于可用状态的E元素 UI元素状态伪类 E:disabled 匹配所有用户界面（form表单）中处于不可用状态的E元素 UI元素状态伪类 E:checked 匹配所有用户界面（form表单）中处于选中状态的元素E UI元素状态伪类 E::selection 匹配E元素中被用户选中或处于高亮状态的部分 否定伪类 E:not(s) 匹配所有不匹配简单选择符s的元素E 通用兄弟元素选择器 E ~ F 匹配E元素之后的F元素 盒子模型div+CSS，给div一个样式，设置它的位置以及外观。又因为这div就像一个盒子一样，所以也叫做盒子模型。 在进行布局前需要把数据封装到一块一块的区域内 边框属性： border：统一设置 none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset 无边框| 隐藏边框|点线或实线|虚线或实线| 实线 |双线边框 | 3D凹槽 | 3D凸槽 |3D凹边 |3D凸边 border-top：上边框 border-bottom：下边框 border-left：左边框 border-right：右边框 border: 粗细（px） 样式（上述）颜色； 内边距padding：length（px）//统一设置 padding-bottom : 文字内容距离下边框的距离 padding-left : 文字内容距离左边框的距离 padding-right : 文字内容距离有边框的距离 padding-top : 文字内容距离上边框的距离 外边距margin：外边距，边框距离外边框的距离 margin：length（px）//统一设置 margin-top : 边框距离上外边框的距离 margin-bottom : 边框距离下外边框的距离 margin-right : 边框距离右外边框的距离 margin-left : 边框距离左外边框的距离 CSS的布局的漂浮float：none | left | right none ：默认值。对象不漂浮 left ：文本流向对象的右边 right ：文本流向对象的左边 CSS的布局的定位Position 属性： static:默认值。无特殊定位，对象遵循HTML定位规则 absolute：将对象从文档流中脱出，使用left,right,top,bottom等属性相对于其进行绝对定位 ——————即，这个盒子独立出来，不由html自动按文档流分配位置，后面的盒子自动补齐该和自动空位 relative：对象不可层叠，但将依据left,right,top,bottom等属性在正常文档流中偏移位置。 ——————即，这个盒子没有从文档流中拖出，位置还在，但是可以移动而不影响其他的盒子的原有位置 JavascriptJavaScript简介JavaScript是基于对象和时间驱动的脚本语言，主要应用在客户端 基于对象提供好了很多对象，可以直接拿过来使用 事件驱动html做网站是静态效果，加入了js后就可以完成动态的效果 特点1. 交互性（信息的动态交互） 2. 安全性（不可以直接访问本地磁盘） 3. 跨平台性（只要是可以解析js的浏览器都可以执行，与平台无关） JavaScript的组成三部分： 1. ECMAScript ECMA：欧洲计算机协会 由ECMA组织指定的js语法，语句...... 2. BOM broswer object model：浏览器对象模型 3. DOM document object model：文档对象模型 JavaScript与HTML的结合1. 使用一个标签 &lt;script type=&quot;text/javascript&quot;&gt;JavaScript代码&lt;/script&gt; 2. 使用script引入外部标签文件 创建一个js文件，写js代码 &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt; 这样写的话 &lt;script&gt;&lt;/script&gt;中间的代码不会执行 JavaScript基本语法js的原始类型和声明变量1. string：字符串 var str=&quot;abc&quot;; 2. number：数字类型 var m = 123; 3. boolean：数字类型 var flag=true; 4. null:对象引用为空 5. undifined：定义了一个变量，但是这个变量没有赋值 var aa； 用typeof（变量名）；查看当前变量的数据类型 js的语句1.判断语句： 1. if语句 if(a == 5){ alert(&quot;5&quot;); }else{ alert(&quot;不是5&quot;) } 2. switch语句（支持所有的数据类型） switch(变量){ case 5:操作;break; case 6:操作;break; case 7:操作;breal; default:操作;break; } 2. 循环语句 1. for循环 for(var i=0; i&lt;10; i++){ alert(i); } 2. whilt循环 var i=4; whilt(i--){ alert(i); } js的运算符1. - 2. + 3. * 4. / 5. &amp; 6. ++ 7. -- 8. += 9. -= 字符串加减j=123 alert(j/1000*1000) java中输出的 0； 但是JavaScript中输出的 123； js中不区分整形浮型点 var str = &quot;457&quot; alert(str+1); Java和JavaScript中输出的都是4571; 加法做的是字符串相见 alert(str-1); JavaScript输出的是 456，即进行了减法运算 alert(&quot;abc&quot;-1); JavaScript输出NAN，提示错误，不是一个数字。 Boolean的操作var flag=true; alert(flag+1); JavaScript中输出的是 2。也就是说 true = 1； 反之，flase = 0。 === 和 == 的区别JavaScript中， == 用于判断两个参数的值是否相等 === 用于判断两个参数 类型和值是否都相等 例如： var x = &quot;5&quot;, y = 5; x == y 则为 true x === y 则为false 引入知识直接向页面输出的语句（可以直接把内容显示在页面上） document.write(&quot;aaa&quot;); document.write(&quot;&lt;hr /&gt;&quot;); 可以直接写入数据，也可以写入html代码，当然也可以混合都写 js的数组js数组中，写什么都可以,可以是数据的混合，可以同时包括int，string或者其他类型 定义数组的三种方式1. var arr=[1,2,&quot;34&quot;]; 2. 使用内置的对象 Array对象 var arr = new Array(5);//定义一个数组，数组长度是5 3. 使用内置对象 Array对象 var arr2 = new Array(3,4,5);//定义一个数组，数组里面的元素为 3，4，5 数组的属性length：表示数组的长度 var len = arr.length; 数组的长度是可以变的 数组可以存放不同的数据类型的数据 js的函数在js里面定义函数有三种定义方式1. 关键字：function funciton 方法名（参数列表）{ 方法体； 返回值；（返回值可有可无） } 2. 匿名函数：function var func = funtion （参数列表）{ 方法体和返回值； } 调用直接 func(); 3. 内部对象：Function（用的少，了解就行）`动态函数` var func = new Function(&quot;参数列表&quot;，“方法体和返回值”); var test = new Function(&quot;x,y&quot;,&quot;var sum;sum=x+y;return sum;&quot;); js的全局变量和局部变量全局变量在script标签内部顶一个变量，这个变量在页面中js部分都可以使用 局部变量在方法内部定义一个变量，只能在方法内部使用 测试全局变量： &lt;script&gt; var a = 10; function func(){ alert(a); } func(); &lt;/script&gt; &lt;script&gt; alert(a); &lt;/script&gt; 可以跨script标签使用的变量。称之为全局变量 局部变量： &lt;script&gt; function func(){ var a = 10; alert(a); } func(); alert(a);//报错 &lt;/script&gt; 局部变量只能在方法内部使用 script应该放的位置位置差别&lt;script&gt;原则上放任意位置都可以执行，但是还是要注意位置 html文档是从上到下解析的，如果用js去获得html的标签，一定要在获取标签的后面，不然会得到一个 null 的变量，导致错误。 建议把script标签放到&lt;/body&gt;后面，&lt;/html&gt;前面 js的重载function add1(a, b){ return a+b } function add1(a, b, c){ return a+b+c } function add1(a, b, c, d){ return a+b+c+d } add1(2,3) add(2,2,3) add(2,2,3,3) 第一个得出结果NAN，第二个得出结果NAN，第三个得出正确结果 为什么呢？JavaScript基础DOMjs的String对象方法属性属性只有一个需要注意：length 字符串的长度 方法####### 与html相关的方法 设置数据样式的方法 1. bold() 使用粗体显示字符串 document.write(str.bold()); 2. fontcolor() 使用指定的颜色来显示字符串 document.write(str.fontcolor(&quot;red&quot;)); 3. fontsize() 使用指定的尺寸来显示字符串 document.wirte(str.fontsize(1));//参数值为1~7 4. link() 将字符串显示为链接 document.write(str.link(www.baidu.com));//即字符串成为一个超链接 5. big() 用大号字体显示字符串 document.write(str.big()); 6. blink() 显示闪动字符串 document.write(str.blink()); 7. sup() 把字符串显示为上标 8. sub() 把字符串显示为下标 9. small() 使用小字号来显示字符串 10. strike() 使用删除线来显示字符串 ####### 与Java相似的方法 对数据进行操作的方法 1. split() 把字符串分割为字符串数组 2. charAt() 返回在指定位置的字符 str.cjarAt(1); 3. concat() 连接字符串 str.concat(str2); 4. indexOf() 检索字符串 str.indexof(&quot;as&quot;);//不存在返回-1 5. charCodeAt() 返回在指定的位置的字符的 Unicode 编码 6. fixed() 以打字机文本显示字符串 7. fromCharCode() 从字符编码创建一个字符串 8. italics() 使用斜体显示字符串 9. lastIndexOf() 从后向前搜索字符串 10. localeCompare() 用本地特定的顺序来比较两个字符串 11. match() 找到一个或多个正则表达式的匹配 12. replace() 替换与正则表达式匹配的子串 str.replace(&quot;a&quot;, &quot;c&quot;);//把a替换成c 13. search() 检索与正则表达式相匹配的值 14. slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 15. substr() 从起始索引号提取字符串中指定数目的字符 str.substr(start, length);截取从start开始长度为length的字符串 16. substring() 提取字符串中两个指定的索引号之间的字符 str.substring(start, end);截取从start开始 end 截至的字符串 17. toLocaleLowerCase() 把字符串转换为小写 18. toLocaleUpperCase() 把字符串转换为大写 19. toLowerCase() 把字符串转换为小写 20. toUpperCase() 把字符串转换为大写 21. toSource() 代表对象的源代码 22. toString() 返回字符串 23. valueOf() 返回某个字符串对象的原始值 js的Date对象js获取当前事件 var date = new Date(); Date对象的方法1. toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串 date.toLocaleString(); 2. toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串 3. toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串 4. setFullYear() 设置 Date 对象中的年份（四位数字） 5. setMonth() 设置 Date 对象中月份 (0 ~ 11) 注意是 0~11，而不是1~12 ！！！！ 6. setHours() 设置 Date 对象中的小时 (0 ~ 23) 7. setMinutes() 设置 Date 对象中的分钟 (0 ~ 59) 8. setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59) 9. setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999) 10. getFullYear() 从 Date 对象以四位数字返回年份 11. getMonth() 返回 Date 对象的月份 (0~11) setMonth() 设置 Date 对象中月份 (0 ~ 11)。 12. getHours() 返回 Date 对象的小时 (0 ~ 23) 13. getMinutes() 返回 Date 对象的分钟 (0 ~ 59) 14. getSeconds() 返回 Date 对象的秒数 (0 ~ 59) 15. getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999) 16. getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 js的Math对象全都是静态方法，调用函数时直接 Math.方法名（参数） Math对象的方法1. abs(x) 返回数的绝对值 2. acos(x) 返回数的反余弦值 3. asin(x) 返回数的反正弦值 4. atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 5. atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） 6. ceil(x) 对数进行上舍入 7. cos(x) 返回数的余弦 8. exp(x) 返回 e 的指数 9. floor(x) 对数进行下舍入 10. log(x) 返回数的自然对数（底为e） 11. max(x,y) 返回 x 和 y 中的最高值 12. min(x,y) 返回 x 和 y 中的最低值 13. pow(x,y) 返回 x 的 y 次幂 14. random() 返回 0 ~ 1 之间的随机数 15. round(x) 把数四舍五入为最接近的整数 16. sin(x) 返回数的正弦 17. sqrt(x) 返回数的平方根 18. tan(x) 返回角的正切 19. toSource() 返回该对象的源代码 20. valueOf() 返回 Math 对象的原始值 Math对象的属性1. E 返回算术常量 e，即自然对数的底数（约等于2.718） 2. LN2 返回 2 的自然对数（约等于0.693） 3. LN10 返回 10 的自然对数（约等于2.302） 4. LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） 5. LOG10E 返回以 10 为底的 e 的对数（约等于0.434） 6. PI 返回圆周率（约等于3.14159） 7. SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） 8. SQRT2 返回 2 的平方根（约等于 1.414） js的全局函数由于不属于任何一个对象，直接名称使用 1. decodeURI() 解码某个编码的URI 2. decodeURIComponent() 解码一个编码的URI组件 3. encodeURI() 把字符串编码为URI 4. encodeURIComponent() 把字符串编码为URI组件 5. escape() 对字符串进行编码 6. eval() 计算JavaScript字符串，并把它作为脚本代码来执行 7. getClass() 返回一个javaObject的JavaClass 8. isFinite() 检查某个值是否为有穷大的数 9. isNaN（） 检查某个值是否是数字 10. parseFloat() 解析一个字符串并返回一个浮点数 11. parseInt() 解析一个字符串并返回一个整数 12. unescape() 对由escape()编码的字符串进行解码 js函数的重载js的重载是否存在？不存在重载。函数名相同的以后定义的为准。也就是说方法名相同的情况下，后定义的会覆盖掉先定义的方法。 js可以通过其他的方式去模拟重载在js的函数中，传入的参数列表，可以通过一个js自带的 aruguments[]数组去访问传入的参数。 例如： function add(a, b, c){ arguments[0] == a; arguments[1] == b; arguments[2] == c; } js的函数你可以传入多个参数，例如 add(1,2,3,4,5,6)，虽然定义的 add函数只有三个参数， 但是通过arguments可以获得 传入的所有参数 1,2,3,4,5,6 只是 a=1,b=2,c=3 罢了 通过arguments.length 判断传入参数大小，以此来手动进行重载 js的bom对象bom：broswer object model 浏览器对象模型 通过bom对象，可以直接对浏览器进行操作。 有哪些对象navigatorNavigator 对象包含有关浏览器的信息。 对象属性1. appCodeName 返回浏览器的代码名 2. appMinorVersion 返回浏览器的次级版本 3. appName 返回浏览器的名称 alert(navigator.appName); 4. appVersion 返回浏览器的平台和版本信息 5. browserLanguage 返回当前浏览器的语言 6. cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 7. cpuClass 返回浏览器系统的 CPU 等级 8. onLine 返回指明系统是否处于脱机模式的布尔值 9. platform 返回运行浏览器的操作系统平台 10. systemLanguage 返回 OS 使用的默认语言 11. userAgent 返回由客户机发送服务器的 user-agent 头部的值 12. userLanguage 返回 OS 的自然语言设置 对象方法1. javaEnabled() 规定浏览器是否启用 Java 2. taintEnabled() 规定浏览器是否启用数据污点 (data tainting) screen（屏幕对象）Screen 对象包含有关客户端显示屏幕的信息。 对象属性1. availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外) 2. availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外) 3. bufferDepth 设置或返回调色板的比特深度 4. colorDepth 返回目标设备或缓冲器上的调色板的比特深度 5. deviceXDPI 返回显示屏幕的每英寸水平点数 6. deviceYDPI 返回显示屏幕的每英寸垂直点数 7. fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑 8. height 返回显示屏幕的高度 9. logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数 10. logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数 11. pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）9 12. updateInterval 设置或返回屏幕的刷新率 13. width 返回显示器屏幕的宽度。 location对象包含有关当前 URL 的信息。 对象属性1. ash 设置或返回从井号 (#) 开始的 URL（锚） 2. host 设置或返回主机名和当前 URL 的端口号 3. hostname 设置或返回当前 URL 的主机名 4. href 设置或返回完整的 URL`(重点)` 1. location.href;//得到当前请求的url地址。 2. location.href=&quot;你要跳转的地址,例如：www.baidu.com&quot;这样就会跳转页面 5. pathname 设置或返回当前 URL 的路径部分 6. port 设置或返回当前 URL 的端口号 7. protocol 设置或返回当前 URL 的协议 8. search 设置或返回从问号 (?) 开始的 URL（查询部分） 对象方法1. assign() 加载新的文档 2. reload() 重新加载当前文档 3. replace() 用新的文档替换当前文档。 history（历史）请求的url的历史记录 对象属性1. length 返回浏览器历史列表中的 URL 数量 对象方法1. back() 加载 history 列表中的前一个 URL history.back() 2. forward() 加载 history 列表中的下一个 URL history.forward() 3. go() 加载 history 列表中的某个具体页面 windowWindow 对象表示浏览器中打开的窗口。包含location,navicator,history,screen对象 它是一个顶层对象 属性opener 获得创建窗口的窗口 即用a.html打开b.html，在b.html中通过window.opener获得a.html的窗口对象 对象方法（都要记住）1. alert() 显示带有一段消息和一个确认按钮的警告框 2. blur() 把键盘焦点从顶层窗口移开 3. clearInterval() 取消由 setInterval() 设置的 timeout 1. window.clearInterval(id); 2. id为 setInterval()返回的id值 4. clearTimeout() 取消由 setTimeout() 方法设置的 timeout 1. window.clearTimeout(id); 2. id为 setTimeout()返回的id值 5. close() 关闭浏览器窗口 1. windown.close(); 2. 浏览器兼容性差 6. confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 1. window.confirm(&quot;传入的消息&quot;) 2. 返回一个Boolean类型值。确定为ture，取消为false 7. createPopup() 创建一个 pop-up 窗口 8. focus() 把键盘焦点给予一个窗口 9. moveBy() 可相对窗口的当前坐标把它移动指定的像素 10. moveTo() 把窗口的左上角移动到一个指定的坐标 11. open() 打开一个新的浏览器窗口或查找一个已命名的窗口 1. window.open(URL, name, features, replace); 2. url 要打开页面的url name 自己定,可以不要 features 窗口特征 宽高 3. window.open(&quot;www.baodu.com&quot;,&quot;&quot;,&quot;width=200,height=200&quot;); 12. print() 打印当前窗口的内容 13. prompt() 显示可提示用户输入的对话框 1. window.prompt(&quot;提示输入的值&quot;,&quot;默认的文本框的内容&quot;)； 2. 现在用的少，因为不好看，还不能改样式表 14. resizeBy() 按照指定的像素调整窗口的大小 15. resizeTo() 把窗口的大小调整到指定的宽度和高度 16. scrollBy() 按照指定的像素值来滚动内容 17. scrollTo() 把内容滚动到指定的坐标 18. setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 1. 一般用来做定时器,有一个返回值ID，代表这个定时器 2. window.setInterval(&quot;js代码&quot;,毫秒数); 3. 1s = 1000ms 4. 例如：window.setInterval(&quot;alert(&apos;123&apos;);&quot;, 3000); 19. setTimeout() 在指定的毫秒数后调用函数或计算表达式 1. 一般用来做定时器，但是只会执行一次。返回一个ID值，代表这个定时器 2. 例如：window.setTimeout(&quot;alert(&apos;123&apos;);&quot;, 4000); js的dom对象什么是domdom：document object model：文档对象模型 文档：超文本标记文档：html，xml 对象：提供了属性和方法 模型：使用属性和方法操作超文本标记型文档 可以使用js里面的dom里面提供的对象，使用这些对象的属性和方法，对标记型文档进行操作 想要对标记型文档进行操作，首先需要 对标记型文档里面的所有内容封装成对象，需要把HTML里面的标签，属性，文本内容都封装成对象 要想对标记型文档进行操作，解析标记型文档 解析过程根据html的层级结构，在内存中分配一个属性结构，需要把html中的每部分封装成对象 1. 上图中，整个蓝色框住的可以当成一个document对象，表示整个HTML文档 2. 同时一个标签/元素也是一个对象，我们成为标签对象 element 3. 属性对象（id属性之类的） 4. 文本对象（标签括起来的数据） 5. Node（节点）对象是属性，文本，标签对象的父对象 常用方法nodeName String 节点的名字：根据节点的类型定义 nodeValue String 节点的值：根据节点的类型而定义 nodeType Number 节点的类型常量值之一 ownerDocument Document 指向整个节点所属的文档 firstChild Node 指向在childNodes列表中的第一个节点 lastChild Node 指向在childNodes列表中的最后一个节点 childNodes NodeList 所有子节点的列表 parentNode Node 返回一个给定节点的父亲节点 previousSibling Node 指向前一个兄弟节点：如果这个节点就是第一个兄弟节点，那么值为null nextSibling Node 指向后一个兄弟节点 hasChildNodes() Boolean 当childNodes包含一个或多个节点时，返回真 attributes NameNodeMap 包含了代表一个元素的特性的Attr对象，仅用于Element节点 appendChild(node) Node 将node添加到childNodes的末尾 removeChild(node) Node 从childNodes中删除node replaceChild(newnode, node) Node 替换 insertBefore(newnode, refnode) Node 在ChildNodes中的refnode之前插入newnode DHTMLDHTML是很多技术的简称 DHTML=html+css+dom+javascript html：封装数据 css：使用属性和属性值设置样式 dom：操作html文档 JavaScript：专门指的是js的语法语句 document对象每个载入浏览器的HTML文档都会成为document对象 属性1. cookie 设置或返回与当前文档有关的所有 cookie 2. domain 返回当前文档的域名 3. lastModified 返回文档被最后修改的日期和时间 4. referrer 返回载入当前文档的文档的 URL 5. title 返回当前文档的标题 6. URL 返回当前文档的 URL 方法1. close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据 2. getElementById() 返回对拥有指定 id 的第一个对象的引用 3. getElementsByName() 返回带有指定名称的对象集合 4. getElementsByTagName() 返回带有指定标签名的对象集合 5. open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出 6. write() 向文档写 HTML 表达式 或 JavaScript 代码 7. writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符 案例：在末尾添加节点&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1();&quot; /&gt; &lt;script&gt; //任务是，点击按钮，添加一行 555 在 444 后面 function add1(){ var ul = document.getElementById(&quot;ulid&quot;); var text = document.createTextNode(&quot;555&quot;); var li = document.createElement(&quot;li&quot;); li.appendChild(text); ul.appendChild(li); } &lt;/script&gt; 元素对象-element对象在 HTML DOM 中，Element 对象表示 HTML 元素。 Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。 NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。 要操作element对象，首先必须要获取到element，使用document里面对应的方法获取 操作element对象的属性1. 获取属性：getAttribute(name)方法 2. 设置属性：setAttribute(name, valure)方法 例如：input1.setAttribute(&quot;class&quot;,&quot;haha&quot;); 这是 input1元素的class为haha 3. 删除属性：removeAttribute(name)方法 不能删除value属性 获得element中的element对象&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var ull = document.getElementById(&quot;ulid&quot;); var lis = ull.childNodes; alert(lis.length); &lt;/script&gt; 上面的代码在IE中输出4， 在火狐中输出9 因为火狐把 回车 空格 也算作数据了 所以直接通过childNodes直接获得准确的子类是不现实的 在Element对象的范围内，可以用来查找其他节点的唯一有效方法就是getElementsByTagName()方法。 上面的例子中，直接通过 ull.getElementsByTagName(&quot;li&quot;)获得子Element对象就行了。 Node对象属性1. nodeName 节点名称 2. nodeType 节点类型 3. nodeValue 节点的值 标签节点对应的值nodeType 1 nodeName 大写的标签名称 nodeValue null 属性节点对应的值获取方法 getAttributeNode(&quot;属性名称&quot;); nodeType 2 nodeName 属性名称 nodeValue 属性的值 文本节点对应的值获取方法 element.firstChild 或者 lastChild nodeType 3 nodeName #text nodeValue 文本内容 例子使用dom解析html的时候，需要html里面的标签，属性和文本都封装成对象 &lt;span id=&quot;spanid&quot;&gt;呵呵呵&lt;/span&gt; &lt;script&gt; //标签节点 var span1 = document.getElementById(&quot;spanid&quot;); alert(span1.nodeType); //输出 1 alert(Span1.nodeName); //输出 SPAN alert(span1.nodeValue); //输出 null //属性节点 var id1 = span1.getAttributeNode(&quot;id&quot;); alert(id1.nodeType); //输出 2 alert(id1.nodeName); //输出 id alert(id1.nodeValue); //输出 spanid //文本节点 var text = span1.firstChild; alert(text.nodeType); //输出 3 alert(text.nodeName); //输出 #text alert(text.nodeValue); //输出 呵呵呵 &lt;/script&gt; 父节点，子节点，同辈节点&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; ul 是 li 的父节点， li 是 ul 的子节点 li 与 li 是 同辈节点，因为他们是同一级 父节点parentNode 子节点childNodes的到所有的子节点，但是兼容性查 firstChild 第一个子节点 lastChild 最后一个子节点 同辈节点nextSibling 下一个子节点 previousSibling 前一个子节点 操作DOM树appendChild方法添加子节点到末尾 特点：类似于剪切粘贴的效果 例子CSS内容#div1{ width:200px; height:150px; border:2px solid red; } #div2{ width:250px; height:150px; border: 5px dashed green; } HTML内容&lt;div id=&quot;div1&quot;&gt; &lt;ul id=&quot;ulidll&quot;&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1()&quot; /&gt; js内容function add1(){ var div2 = document.getElementById(&quot;div2&quot;); var ull = document.getElementById(&quot;ulidll&quot;); div2.appendChild(ull); } 通过结果可以看到，ul 的内容 从 div1 移动到 div2 中。 insertBefore(newnode, oldNode)方法在oldnode节点之前插入一个新的节点 1. 创建标签 li2 = document.createElement(&quot;li&quot;); 2. 创建文本 text = document.createTextNode(&quot;啦啦啦啦&quot;); 3. 把文本添加到标签下 li2.appendChild(text); 4. 获取 oldNode var li3=document.getElementById(&quot;li3&quot;); 5. 插入 var ul = document.getElementById(&quot;ul1&quot;);//获得父节点 ul.insertBefore(li2, li3); removeChilid 删除节点只能通过父节点删除，不能自己删自己 1. 获取要删除标签 var li3 = document.getElementById(&quot;li3&quot;); 2. 获取父节点 var par = document.getElementById(&quot;ul&quot;); 3. 删除 par.removeChild(li3); replaceChild(newnode, oldnode)替换节点只能通过父节点进行替换，不能自己替换自己 1. 创建新节点 var li = document.createElement(&quot;li&quot;); var text = document.createTextNode(&quot;文本内容&quot;); li.appenChild(text); 2. 获取旧节点 var oldli = document.getElementById(&quot;oldli&quot;); 3. 获取父标签 var ul = document.getElementById(&quot;ul&quot;); 4. 替换标签 ul.replaceChild(li, oldli); cloneNode(boolean) 复制节点//复制ul列表到另一个div中 1. 获取ul var ul = document.getElementById(&quot;ul&quot;); 2. 复制ul，放到类似于剪切板里面 var copyul = ul.cloneNode(true); 3. 获取新的div var newdiv = document.getElementById(&quot;newdiv&quot;); 4. 复制进去 newdiv.appendChild(copyul); 因为 copyul 是复制的新的，所以appendChild的剪贴方法并不会删除掉原 ul innerHTML属性1. 浏览器几乎都支持该属性，但不是DOM标准的组成部分 2. innerHTML属性可以用来读某给定元素里的HTML内容 var span1 = document.getElementById(&quot;span1&quot;); alert(span1.innerHTML);//获取文本内容 3. innerHTML属性可以用来写给定元素里的html内容 var div1 = document.getElementById(&quot;div1&quot;); div1.innerHTML += &quot;&lt;h1&gt;AAA&lt;/h1&gt;&quot;; 案例：动态显示时间1. 获取当前时间： var date = new Date(); date = date.toLocaleString(); 2. 需要让页每秒执行 setInterval()方法 3. 用一个&lt;span&gt;来承接时间 function gettime(){ var date = new Date(); date = date.toLocaleString(); var div = document.getElementsById(&quot;time&quot;); div.innerHtml = date; } //使用定时器，每秒写一次 setInterval(&quot;gettime();&quot;, 1000); 案例：一键全选&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 排球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 篮球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 足球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 羽毛球 &lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;setall();&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;全不选&quot; onclick=&quot;setNo();&quot;/&gt; &lt;script&gt; // 复选框中 的 chexked = true 即为选中，反之为没选中 function setall(){ //获取复选框 var loves = document.getElementsByName(&quot;love&quot;); //遍历 loves 数组，整体修改值 for(var i=0; i&lt;loves.length; i++) { var love1 = loves[i]; love1.checked = true; } } &lt;/script&gt; 案例：省市联动选择 湖北省的时候，只会显示湖北省的市，选择湖南省的时候，只会显示湖南省的市 &lt;select id=&quot;sheng&quot; onchange=&quot;add1();&quot;&gt; &lt;option&gt;湖北省&lt;/option&gt; &lt;option&gt;湖南省&lt;/option&gt; &lt;option&gt;山西省&lt;/option&gt; &lt;option&gt;江西省&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;shi&quot;&gt; &lt;/select&gt; // onchange 是 当 select 改变的时候执行的操作 &lt;script&gt; //通过数据库，可以获得每个省份，有哪些城市 var arr = [];//arr存的读取的城市 var select = document.getElementById(&quot;shi&quot;); //一定要先清空 select，否则第二次选择会进行二次添加 var chils = select.getElementsByTagName(&quot;option&quot;); for(var i=child.length-1; i&gt;=0; i--){ var op = option[i]; select.removeChild(op); } for(int i=0; i&lt;arr.length; i++){ var opt = document.createElement(&quot;option&quot;); var text = document.createTextNode(arr[i]); opt.appendChild(text); select.appendChild(opt); } &lt;/script&gt; XML文档什么是xmleXtensible Markup Language：可扩展标记型语言 1. 标记型语言：html也是标记型语言，通过使用标签来操作 2. 可扩展：html里面每个标签都是固定的，有特定的含义。xml中，标签可以自定义，也可以是中文的标签 3. xml技术是W3C组织发部分，目前遵循的是2000发布的XML1.0规范 xml的用途html用于显示数据，xml也可以用来显示数据，但是更主要的功能和目的是同来存储数据。 1. 用于不同系统之间传输数据 1. 如果数据直接用 字符串 传输，接收方并不能解析数据 例如：&quot;120.0.0.1;2018.10.01;hello world&quot;发送方知道这是 &quot;ip地址，时间，内容&quot;，但是接收方并不知道 2. &lt;message&gt; &lt;ip&gt;120.0.0.1&lt;/ip&gt; &lt;time&gt;2018.10.01&lt;time&gt; &lt;content&gt;hello world&lt;/content&gt; &lt;/message&gt; 3. 这样写接收方能懂，并且可以扩展更多标签在&lt;message&gt;中 2. 同来表示生活中有关系的数据 例如： &lt;中国&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt; &lt;湖南&gt; &lt;/湖南&gt; &lt;中国&gt; 3. 经常用在配置文件 1. 用于链接数据库，例如用于存储用户密码，修改密码值用修改xml中的密码、 xml的语法xml的文档声明创建文件，后缀名为 .xml #####写一个文档声明，必须写在第一行第一列 &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 属性version：xml的版本 1.0，1.1 encoding：xml 编码 gbk utf-8 iso8859-1 standalone：yes/no 表示xml文件是否可以独立存在 声明元素（标签）标签的定义1. 标签定义有开始必须有结束：&lt;person&gt;&lt;/person&gt; 2. 标签没有内容，也可以标签内结束：&lt;person /&gt; 3. 标签可以嵌套，必须要合理嵌套 4. 一个xml文档有且必须只有一个根标签 5. 标签的包含的空格和换行会被解析成文本内容处理：&lt;person&gt; 1&lt;person&gt; 和 &lt;person&gt;1&lt;/person&gt;是不一样的 6. xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致 7. 标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头 8. 不能包括 ‘&lt; &gt; , $’ 9. 标签名尽量不要出现英文冒号“:”, 除非是在使用名空间 10. 标签名不能以字符“xml”等任意大小写组合开始 11. 标签名不能包含空格 定义属性html是标记型文档，所以标签有属性。同理，xml也可以用属性 &lt;person id1=&quot;aa&quot;&gt;&lt;/person&gt; 属性定义的要求1. 一个标签上可以有多个属性 2. 同一个标签，不能有属性名相同的属性 3. 属性值一定要用引号，单引号，双引号都行 4. 属性名的命名规范和标签命名规范相同 注释写法&lt;!-- 注释的内容 --&gt; 注释不能嵌套 特殊字符 &amp;&amp; CDATA区开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序 但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。 解决方法： 1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 2. 使用CDATA标记 在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理 实体引用也会失去作用，变成纯文本 语法： &lt;![CDATA[文本内容]]&gt; PI指令（处理指令）可以在xml中设置样式，其实就是外部引入css 引入css：&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt; 但是，对中文的标签元素不起作用，毕竟外国人定义的东西 xml的约束比如定义人的信息的xml，肯定不能出现猫猫狗狗的信息，所以需要约束 由于xml的标签是自定义，所以不加约束容易出现问题。 dtd约束创建一个后缀名为 .dtd 的dtd文件 步骤： 1. 查看xml中有多少个元素 例如： &lt;message&gt; &lt;ip&gt;120.0.0.1&lt;/ip&gt; &lt;time&gt;2018.10.01&lt;time&gt; &lt;content&gt;hello world&lt;/content&gt; &lt;/message&gt; 有四个元素（标签） 2. 有多少个元素，就在dtd文件中写多少个&lt;!ELEMENT&gt; 3. 判断元素是简单元素还是复杂元素 1. 有子元素的元素是复杂元素 &lt;!ELEMENT 元素名称(子元素名称逗号隔开)&gt; &lt;!ELEMENT message(ip+,time？,content*)&gt; `其中 + ? * 是选择性加上，代表子标签在根标签下出现的次数 1. + 代表出现一次或多次 2. ？ 代表出现0次或1次 3. * 打表出现0次或多次 默认是只出现一次` 逗号连接子元素名称时，子元素必须按顺序出现用 | 隔开时，表示只能出现范围中的一个 2. 没有子元素的元素是简单元素 &lt;!ELEMENT 元素名称 (#PCDATA)&gt; &lt;!ELEMENT ip (#PCDATA)&gt; &lt;!ELEMENT time (#PCDATA)&gt; &lt;!ELEMENT content (#PCDATA)&gt; 4. 在xml中引入外部dtd文件，写在&lt;xml&gt;标签行下 &lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd文件路径&quot;&gt; 4. 在xml内部定义dtd &lt;!DOCTYPE 根元素名称[ &lt;!ELEMENT 子标签 (#PCDATA)&gt; ]&gt; 例如： &lt;!DOCTYPE message[ &lt;!ELEMENT ip (#PCDATA)&gt; &lt;!ELEMENT time (#PCDATA)&gt; &lt;!ELEMENT content (#PCDATA)&gt; ]&gt; 4. 使用外部/网络的dtd文件 &lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt; 用浏览器打开的时候，浏览器之校验语法，不校验约束，所以用浏览器打开不能查看是否约束上 使用dtd定义属性语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 属性的约束&gt; 1. 属性类型有三种 1. CDATA：表示属性的取值为普通的文本字符串 2. ENUMERATED：表示枚举，只能从枚举列表中任选其一 例如：（鸡肉|鸭肉|鱼肉|牛肉）这种方法定义枚举 3. ID：表示属性的取值不能重复，只能是字母，下划线开始 2. 属性的约束有三种 1. #REQUIRED：表示该属性必须出现 2. #IMPLIED：表示该属性可有可无 3. #FIXED：表示属性的取值为一个固定值 4. 直接写一个值上去：表示属性的默认值为你直接协商的值 例如：&lt;!ATTLIST ip ID1 CDATA &quot;wwww&quot;&gt; 则ID1属性的值默认为www schema约束空 xml解析xml是标记型文档 js使用dom解析标记型文档 根据html的层级结构，在内存中分配一个属性结构，把html的标签属性和文本封装成对象 document对象，element对象，属性对象，文本对象，node节点对象 xml的解析方式：dom 和 sax dom方式解析根据 xml 的层级结构在内存中分配一个树形结构，把xml的标签，属性和文本都封装成对象 缺点：如果文件过大，造成内存溢出 优点：方便实现增删改操作 sax方式解析采用事件驱动方式，边读便解析，从上到下，一行一行的解析，解析到某个对象，返回对象名称 缺点：不能实现增删改 优点：不会造成内存溢出，方便实现查询操作 dom和sax方式的解析器不同的公司和组织提供了针对dom和sax方式的解析器，通过api方式提供 1. sun公司提供 jaxp 2. dom4j组织提供 dom4j（实际开发中用的比较多） 3. jdom组织提供 jdom jaxp的api的查看jaxp是javase的一部分 jaxp解析器在jdk的javax.xml.parsers包里面 DocumentBuilder 定义API，使其从xml文档获取DOM文档实例 DocumentBuilderFactory 定义工厂API，是应用程序能够从xml文档获取生成DOM对象数的解析器 SAXParser 定义包装XMLReader实现类的API SAXParserFactory 定义工厂API，是应用程序能够配置和获取基于sax的解析器以解析XML文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux 命令大全]]></title>
    <url>%2F2018%2F09%2F27%2Flinux-%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[系统信息arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \*.rpm -exec chmod 755 &apos;{}&apos; \; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &apos;%10{SIZE}t%{NAME}n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=&apos;${Installed-Size;10}t${Package}n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户 grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;{print $1}&apos; 查看一行第一栏 echo a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &apos;eth0&apos; 网络设备 ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &apos;eth0&apos; route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &apos;192.168.0.0/16&apos; route del 0/0 gw IP_gateway remove static route echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &apos;eth0&apos; ethtool eth0 show statistics of network card &apos;eth0&apos; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cocos 内存管理]]></title>
    <url>%2F2018%2F09%2F27%2FCocos-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[delete和newnew运算符使用的一般格式为 new 类型 [初值] 用new分配数组空间时不能指定初值。 如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。 new int;//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针) new int(100);//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 new char[10];//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4];//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);//开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p delete运算符使用的一般格式为 delete [ ]指针变量 例如要撤销上面用new开辟的存放单精度数的空间(上面第5个例子)，应该用 delete p； 前面用“new char[10];”开辟的字符数组空间，如果把new返回的指针赋给了指针变量pt，则应该用以下形式的delete运算符撤销该空间： delete [] pt；//在指针变量前面加一对方括号，表示是对数组空间的操作 CREATE_FUNC()函数源码分析/** * define a create function for a specific type, such as CCLayer * @__TYPE__ class type to add create(), such as CCLayer */ #define CREATE_FUNC(__TYPE__) \ static __TYPE__* create() \ { \ __TYPE__ *pRet = new __TYPE__(); \ //创建传过来的东西 if (pRet &amp;&amp; pRet-&gt;init()) \ { \ pRet-&gt;autorelease(); \ return pRet; \ } \ else \ { \ delete pRet; \ pRet = NULL; \ return NULL; \ } \ } 什么是CREATE_FUNC()为类似CCLayer类的特定类增加一个create函数，我们也可以看到在宏的下面定义了一个create()函数返回到类型就是宏带入的参数&quot;__TYPE__&quot;指针类型 create（）函数做了什么？他执行了类的构造函数，执行了init()初始化函数，最后又设置创建出的对象为自动释放内存，这样其他人在使用这个类的时候，只要是用create（）函数创建出来的对象就是不用费心区管理释放内存 引用计数什么时候引用计数每一个对象都有一个关联的引用计数 —— 对该对象的活跃引用的数量。 如果对象的引用计数是零，那么它就是垃圾（用户程序不可到达它），并可以回收。 Cocos2dx内存管理分为两块1. 通过加入 `autorelease` 来自动释放那些创建后未使用的对象 1. 通过`节点管理`来保证对象在弃用后及时的删除 及时释放弃用的对象使用条件：该对象是Node的子类对象使用方法：addChild，removeChild 内存管理过程：addChild 添加对象后，对象可以被使用 removeChild 删除对象后，对象被立刻删除（通过 delete） 及时释放未使用的对象简述新创建的对象如果 一帧 内不使用，就会被自动释放。（所谓一针，即是一个gameloop） 使用条件对象通过CREAT_FUNC()宏创建或者对象使用autorelease加入了自动释放池 使用方法自动实现 管理过程对象不使用的情况对象创建 引用+1 对象自动释放 引用-1 对象使用的情况对象创建 引用+1 对象使用 引用+1//通过 addchild 使用对象 对象自动释放 引用-1 引用的初始值为0，如果一阵结束后对象的引用值还是0，那就会被delete掉 内存管理的实现原理第一部分Red类：进行引用计数，提供加入自动释放池的接口。AutoreleasePool类：管理一个vector数组来存放自动释放池的对象。提供对释放池的清空操作PoolManager类：管理一个vector数组来存放自动释放池。默认情况下引擎只创建一个自动释放池，因此这个类是提供给开发者使用的，例如处于性能考虑添加自己的自动释放池DisplayLinkDirector类：只是一个导演类，提供游戏的主循环，实现每一帧的资源释放。这个类继承自Director类，也是唯一一个继承了Director的类，也就是说完全可以合并为一个类。 Ref源码// 引用计数变量 unsigned int _referenceCount; // 对象被构造后，引用计数值为 1 Ref::Ref() : _referenceCount(1) //当Ref对象被创建时，引用计数的值为 1 { #if CC_ENABLE_SCRIPT_BINDING static unsigned int uObjectCount = 0; _luaID = 0; _ID = ++uObjectCount; _scriptObject = nullptr; #endif #if CC_USE_MEM_LEAK_DETECTION trackRef(this); #endif } // 引用+1 void Ref::retain() { CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;); ++_referenceCount; } // 引用-1 。如果引用为0则释放对象 void Ref::release() { CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;); --_referenceCount; if (_referenceCount == 0) { #if CC_USE_MEM_LEAK_DETECTION untrackRef(this); #endif delete this; // 注意这里 把对象 delete 了 } } // 提供加入自动释放池的接口。对象调用此函数即可加入自动释放池的管理。 Ref* Ref::autorelease() { PoolManager::getInstance()-&gt;getCurrentPool()-&gt;addObject(this); return this; } //获取引用计数值 unsigned int Ref::getReferenceCount() const { return _referenceCount; } AutoreleasePool源码// 存放释放池对象的数组 std::vector&lt;Ref*&gt; _managedObjectArray; // 往释放池添加对象 void AutoreleasePool::addObject(Ref* object) { _managedObjectArray.push_back(object); } // 清空释放池，将其中的所有对象都 delete void AutoreleasePool::clear() { // 释放所有对象 for (const auto &amp;obj : _managedObjectArray) { obj-&gt;release(); } // 清空vector数组 _managedObjectArray.clear(); } // 查看某个对象是否在释放池中 bool AutoreleasePool::contains(Ref* object) const { for (const auto&amp; obj : _managedObjectArray) { if (obj == object) return true; } return false; } PoolManager源码// 释放池管理器单例对象 static PoolManager* s_singleInstance; // 释放池数组 std::vector&lt;AutoreleasePool*&gt; _releasePoolStack; // 获取 释放池管理器的单例 PoolManager* PoolManager::getInstance() { if (s_singleInstance == nullptr) { // 新建一个管理器对象 s_singleInstance = new PoolManager(); // 添加一个自动释放池 new AutoreleasePool(&quot;cocos2d autorelease pool&quot;);// 内部使用了释放池管理器的push，这里的调用很微妙，读者可以动手看一看 } return s_singleInstance; } // 获取当前的释放池 AutoreleasePool* PoolManager::getCurrentPool() const { return _releasePoolStack.back(); } // 查看对象是否在某个释放池内 bool PoolManager::isObjectInPools(Ref* obj) const { for (const auto&amp; pool : _releasePoolStack) { if (pool-&gt;contains(obj)) return true; } return false; } // 添加释放池对象 void PoolManager::push(AutoreleasePool *pool) { _releasePoolStack.push_back(pool); } // 释放池对象出栈 void PoolManager::pop() { CC_ASSERT(!_releasePoolStack.empty()); _releasePoolStack.pop_back(); } DisplayLinkDirector源码void DisplayLinkDirector::mainLoop() { //第一次当导演 if (_purgeDirectorInNextLoop) { _purgeDirectorInNextLoop = false; purgeDirector();//进行清理工作 } else if (! _invalid) { // 绘制场景，游戏主要工作都在这里完成 drawScene(); // 清空资源池 PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear(); } } 过程分析首先，创建了一个 Node 对象A，Node 继承Ref，因此 Ref 的引用计数为1； 然后，A通过 autorelease 将自己放入自动释放池；drawScene() 完成后， 一帧结束，Director 通过释放池将池中的对象 clear()，即对 Node 对象A进行 release() 操作。 A的引用计数变为0，执行 delete 释放A对象。、]]></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2F2018%2F09%2F26%2Fxml%2F</url>
    <content type="text"><![CDATA[xml概述：可扩展标记语言。(Extensible Markup Language) 允许开发者自由定义标签，可以将标签和内容有效分离。 xml不再侧重于数据如何展示，二十更过的关注数据如何存储和传输。 xml应用场景：1. xml把数据从HTML分离出来。那温度距离，用html注重于显示而无关数据，用xml改变数据，让html读取。 2. 简化数据共享。提供了独立于软件和硬件的存储方式。 3. 简化数据的传输。通过xml，可以在不兼容的系统之间传输数据。 4. 简化平台的变更。 xml的优势：1. 简单易用的标记预语言。xml标签可以自己自由定义。 2. 严格的格式。比html标签控制更严格。 3. 数据逻辑和显示逻辑分离。html注重于显示，xml注重于数据存储。 xml文档规则：1. 有且只有一个根元素 2. 元素必须合理结束 3. 元素之间必须合理嵌套 4. 元素的属性必须有值 xml存储信息：例如：书名 作者 价格 java思想 小王 79.00 Spring指南 小李 89.00 xml的写法字符集：1. 简体中文：GBK 或 GB2312 2. 繁体中文：BIG5 3. 西欧字符：ISO8859-1 4. 通用的国际编码：Unicode 5. 针对Unicode的可变长度字符编码UTF8 合法标签名：xml元素由开始标签和结束标签组合，结束标签比开始标签多一条斜线 xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致 标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头 不能包括 ‘&lt; &gt; , $’ 标签名尽量不要出现英文冒号“:”, 除非是在使用名空间 标签名不能以字符“xml”等任意大小写组合开始 标签名不能包含空格 空元素：例：&lt;元素名 属性名=&quot; &quot; /&gt; 空元素不是内容为空的元素，空元素不接受子元素，也不接受字符内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; standalone = &quot;yes&quot; ?&gt; &lt;书籍列表&gt; &lt;书名&gt; java思想&lt;/书名&gt; &lt;价格&gt;79.00&lt;/价格&gt; &lt;作者&gt;小王&lt;/作者&gt; &lt;书名&gt;Spring指南&lt;/书名&gt; &lt;价格&gt;89.00&lt;/价格&gt; &lt;作者&gt;小李&lt;/作者&gt; &lt;/书籍列表&gt; 那么 &lt;书籍列表&gt; 就是根元素 字符数据：开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序 但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。 解决方法： 1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 2. 使用CDATA标记 在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理 实体引用也会失去作用，变成纯文本 语法： &lt;![CDATA[文本内容]]&gt; 换行处理：目前主流的操作系统，主要由3种换行符： 1. Windows平台：回车符（CR） 和 换行符 （LF） 的组合存储换行 2. Unix和Linux平台：以换行符（LF）存储换行 3. Macintosh平台：以回车符（CR）存储换行 xml同一换行符（LF） 存储换行 命名空间：同一份xml文档中可能出现多个同名的元素和属性。必须添加标记判断 语法： xmlns[:prefix]= &quot;命名空间字符串&quot; xmlns -&gt; xml namespace 例如： xmlns:hehe = &quot;http://www.***.com&quot; &lt;hehe:name&gt;java思想&lt;/hehe:name&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL命令]]></title>
    <url>%2F2018%2F09%2F26%2FMySQL%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Windows下进入命令行ssh 用户名@ip地址 或者 mysql -h ip地址 -u root -p 然后输入密码 mysql -u 数据库用户名 -p 然后输入密码 修改密码：`mysqladmin -u root -p 密码 password 新密码` 增加用户：`insert into mysql.user(Host,User,Password) values (&quot;localhost&quot;,&quot;test&quot;,password(&quot;1234&quot;));（登陆地址，用户名，密码） ` 用户授权：`grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;; ` `权限包括：select,insert,update,delete，all privileges ` `记得创建授权之后，flush privileges;//刷新系统权限表 ` 删除用户：`root权限下 Delete FROM user Where User=&apos;用户名&apos; and Host=&apos;ip地址&apos;; ` `flush privileges; ` 修改密码：`update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;test&quot; and Host=&quot;localhost&quot;; ` 查看数据库：`show databases; ` 链接数据库：`use 库名； ` 查看数据表：`show tables; ` 查看状态：`show status like &apos;%下面变量%&apos;; ` Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 Connections 试图连接MySQL服务器的次数。 Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。 Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。 Delayed_writes 用INSERT DELAYED写入的行数。 Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。 Flush_commands 执行FLUSH命令的次数。 Handler_delete 请求从一张表中删除行的次数。 Handler_read_first 请求读入表中第一行的次数。 Handler_read_key 请求数字基于键读行。 Handler_read_next 请求读入基于一个键的一行的次数。 Handler_read_rnd 请求读入基于一个固定位置的一行的次数。 Handler_update 请求更新表中一行的次数。 Handler_write 请求向表中插入一行的次数。 Key_blocks_used 用于关键字缓存的块的数量。 Key_read_requests 请求从缓存读入一个键值的次数。 Key_reads 从磁盘物理读入一个键值的次数。 Key_write_requests 请求将一个关键字块写入缓存次数。 Key_writes 将一个键值块物理写入磁盘的次数。 Max_used_connections 同时使用的连接的最大数目。 Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。 Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。 Open_tables 打开表的数量。 Open_files 打开文件的数量。 Open_streams 打开流的数量(主要用于日志记载） Opened_tables 已经打开的表的数量。 Questions 发往服务器的查询的数量。 Slow_queries 要花超过long_query_time时间的查询数量。 Threads_connected 当前打开的连接的数量。 Threads_running 不在睡眠的线程数量。 Uptime 服务器工作了多少秒。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java的文件和时间操作]]></title>
    <url>%2F2018%2F09%2F25%2Fjava%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[File 类构造函数有：传入相对路径（一个参数） 传入绝对路径（一个参数） File类指定为当前文件的父级，当前文件的名称（两个参数） 文件删除读写改名File file = new File(&quot;hello.txt&quot;);//对于工程而言用相对路径，创建在根目录下。也可以用绝对路径指定文件夹 //File file = new File(&quot;bin/hello.txt&quot;);工程文件夹下的bin文件夹的hello.txt文件 //File file = new File(&quot;../hello.txt&quot;);工程文件夹的上一级文件中新建hello.txt文件 if(file.exists()){ System.out.printlen(file.isFile());//判断文件是文件 System.out.println(file.isDirectory());//判断文件是文件夹 File nameto = new File(&quot;new name .txt&quot;); file.renameTo(nameto);//将file的名字改为nameti的名字 File nameto1 = new File(&quot;src/new name.txt&quot;); file.renameTo(nameto1);//将文件移动到src目录下 file.delete();//删除文件 }else{ System.out.println(&quot;文件不存在&quot;); try{ file.createNewFile(); System }catch(IOException e){//抛出异常 e.printStackTrace(); System.out.println(&quot;文件无法创建&quot;); } } 测试样例，用于文件的读取新建一个test.txt文件，内容随意。 File file = new File(&quot;text.txt&quot;); if(file.exitst()){ try{ FileInputStream fis = new FileInputStream(file);//属于字节流 InputStreamReader isr = new InputStreamReader(fis. &quot;UTF-8&quot;);//属于字符流，在字节转换为字符的时候，需要指定编码，否则可能会出现乱码。 BufferedReader br = new BufferedReader(isr);//带有缓冲区的reader String line;//用于存放临时数据 while ((line = br.readLine()) != null){ System.out.println(line);//输出读取的一行 } 关闭输入流，先打开的后关闭，后打开的先关闭。 br.close(); isr.close(); fis.close(); }catch (FileNotFoundException e){ 该异常对应于 FileInputStream }catch (UnsupportedEncodingException e){ 该异常对应于 InputStreamReader }catch (IOException e){ 该异常对应于 ***.close() } } 测试样例，用于写入文件File newfile = new File(&quot;newtest.txt&quot;); try{ FileOutPutStream fos = new FileOutputStream(newfile); OutPutStreamWriter osw = new OutPutStream(fos, &quot;UTF-8&quot;); BufferedWriter bw = new BufferedWriter(osw); bw.write(&quot;你要写入的内容&quot;); 。。。。。。。 bw.close(); osw.close(); fos.close(); //同样，先打开的后关闭，后打开的先关闭。 } 文件夹操作File类可以表示文件或者文件夹，但是两者之间的是有区别的 File folder = new File(&quot;my new folder&quot;); // folder.createNewFile() 使用该方法创建的是一个文件，只是文件没有后缀罢了 folder.mkdir();//创建一个文件夹，返回值是一个bool类型，true为创建成功，false为失败 //如果 已经存在 名为 “my new folder”的文件夹，则创建失败。也就是说不能出现同名的文件或者文件夹 如果使用mkdir()，那么创建的文件夹必须是物理上存在的文件夹，也就是说，如果创建“one/two/test”这样的文件夹，但是 不存在one文件夹，那么是不会自动补全路径的。这时候我们就需要用 mkdirs()，也就是 file.mkdirs()这个语句。 //文件夹给名字的方法跟文件改名字的方法类似 File folder = new File(&quot;my new folder&quot;); File newfolder = new File(&quot;new folder&quot;); folder.renameTo(newfolder);//返回的是一个bool类型的值，可以通过if判断是否修改成功 //用这种方式修改文件夹的名字 forlder.delete();//删除文件夹，但是只能删除空文件夹 在windows中，千万注意移动文件夹不要跨盘移动，否则失败。因为Windows的文件系统是森林格式，而Linux和Mac系统是数状的 一些判断获取语句File file = new File(&quot;test.txt&quot;); //判断文件是否存在 file.exists(); //读取文件名称 file.getName(); //读取文件相对路径 file.getPath(); //读取文件的绝对路径 file.getAbsolutePath(); //读取文件父级路径 file.getParent(); //读取文件大小（字节） file.length(); //判断文件是否被隐藏（Linux和unix中，文件以 &quot; . &quot;开头代表隐藏） file.isHidden(); //判断文件是否可读 file.canRead(); //判断文件是否可写 file.canWrite(); //判断文件是否为文件夹 file.isDirectory(); //当程序退出时将文件删除 file.deleteOnExit(); 设置文件属性：File file = new File(&quot;test.file&quot;); //设置为可写 file.setWritable(true);//传入 true 则设置文件可写，否则设置为不可写 //设置为可读 file.setReadable(true);//与上述相同。 //设置为只读 file.setReadOnly(); 遍历文件夹public static void printfFiles(File dir){ { if( dir.isDirectory() ){ File next[] = dir.listFiles(); for( int i = 0; i&lt;next.length; i++){ if( next[i].ifFile() ){//输出文件的名字 System.out.println(next[i].name); }else{//递归的输出文件的名字 printfFiles(next[i]); } } } } 时间操作Date表示时间，日期。但是更新jdk之后就不推荐使用了。官方解释是 使用Date类不利于国际化。所以jdk1.1版本后推荐使用Calendar类。使用DateFormat类进行时间日期的格式化。Long类型表示时间类型。String类型表示时间日期类的显示。 Date.getTime();//获取Date对象的时间 Date.setTime(long time);//设置Date的时间 Calendar rightnow = Calendar.getInstance();//获取当前时间 long now = System.currentTimeMillis();//获得系统的当前时间，但是这个时间只有机器能读懂 Date d1 = new Date(now);// 获取人能够读懂的时间 Calendar c1 = Calendar .getInstance(); System.out.print(c1.getTime().toString());//获得人能够读懂的时间 String -&gt; 时间 &amp;&amp; 时间 -&gt; String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//指定日期的格式 sdf.format(date);//将Date类型转换为指定格式的String类型，返回的是一个String类型 sdf.parse(&quot;2015-06-01&quot;);//将String转换为Date类型，返回的是一个Date类型 //SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); 时间格式为 年月日 时分秒]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F09%2F25%2FGit%2F</url>
    <content type="text"><![CDATA[Git的起源linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bitkeep说开源社区中的一个成员对bitkeep的协议进行逆向工程。因此，自己写了git。 SVN-&gt;集中式版本控制系统：只有中央服务器有版本的数据库，其他电脑没有，所有版本控制都要通过中央服务器进行交互。（要是中央服务器当机离线，则就出大问题了）git-&gt;分布式版本控制：每一个台电脑上面都有一个版本的database。由于每台电脑都有数据库，所以大多数操作可以离线进行。支持比较多的控制模式-也可以安装一个中央服务器。 git每个版本存储的都是当前版本的所有内容，不需要与其他版本进行差异比较之后再进行文件的合成。 git可以离线完成大部分操作。 git有更优雅的分支和合并实现。 git有更强大撤销修改和修改版本历史的能力。 git速度更快，效率更高。 为什么学习git：研究GitHub越来越多的公司通过git调整 git如何存储文件，历史记录：git通过40个16进制字符的SHA-1 Hash 来唯一标识对象 例如： e98757d0598ab6eeaf1df0d87dd00826048bd80bgit有四种对象： 1. blob：文本文件或者二进制文件或者链接文件 2. tree：目录 3. commit：历史提交 4. tag：指向固定的历史提交 (-&gt;）指向的意思 tag -&gt; commit -&gt; tree -&gt; 多个tree对象或者多个blob对象对工作区的这些内容进行SHA-1 Hash 之后，就可以得到唯一标识。如果两个文件内容是相同的，则他们指向同一个blob对象。而文件名这种信息会存在tree对象中。 有了git对象之后，需要git仓库去存储对象，和操作对象。git init git clone 两种方法获取仓库。cd 到.git 文件夹中 （GIT_DIR!）-&gt; git工作区间 用 ls 查看git需要的文件再退出来用init方法创建一个裸仓库。然后查看仓库中有什么。git init –bare git_bare_repo通过–bare 方法创建一个 git_bare_repo 文件夹。这个文件夹只有git工作需要的文件。git clone 克隆出一个仓库 一般来说需要远程裸仓库的地址git clone git_bare_repo/ git_clone_repo （复制之前创建的本地仓库，并创建在文件夹 git_clone_repo中） git分为三个区域： working directory（工作区，日常编辑代码的地方） staging area（暂存区，工作区与历史提交的缓存，维护的是虚拟的树形结构） history repository（历史仓库） （1）工作区 添加文件到 暂存区 提交整个暂存区的状态 历史纪录区（2）历史记录区 检出文件到 暂存区和工作区大部分时间我们都在做第一个工作对应的就是 git add（到暂存区） 和 git commit（到历史记录区） git status（查看工作区和暂存区的区别，确保提交是我们所需要的） git rm（从暂存区删掉我们不需要的东西） git mv（移动文件） gitignore（确保不想添加到暂存区和历史纪录区的文件不被添加） 先 创建 a b 两个文件 touch a touch b然后添加到暂存区 git add a b查看一下 git status提交到历史纪录 git commit -m “initial commit” （加入一个提交的历史信息）修改一下a vim a（加入一些文字信息）再看一下 git status 提示 a 修改了 但是没有提交到暂存区提交a到暂存区中 git add a再status 看一下 git status再提交 a 就行 git commit -m “modify a”删除a，会删除 工作区 ，暂存区中的a git rm a还原一下a git checkout a如何只删除暂存区的文件，不删除工作目录的文件 git rm –cached a git status 看看就会提示有一个没有跟踪的文件git mv a c （将a名字命名为c）（这个命令是一系列操作的总和） 如果直接再工作区修改文件名 mv a c （工作目录直接 修改名字） 再 git status 提示 a 被删除了 ， 有个c 的文件没有被跟踪 再 git add a c（添加a c 到文件中） 提示文件 a 被更改为 cgit add -A 添加整个工作区都暂存区git .gitignore 在顶层目录下创建一个.gitignore文件.[oa]通过通配符提示git，以 o 和 a 结尾的文件不要添加到git仓库中例如：加入了 .~, *.pyc ， 但是如果以.pyc为后缀的文件，有一个要加到仓库，这个时候就要在文件名上加 !test.pyc，告诉 test.pyc 不要被忽略。如果需要ingore文件名第一个字符就是“！”，就要加上”\”转义字符。**/res 匹配 res，所有路径下的res，任何文件夹下的res。git add .gitignoregit commit -m “add ingore”//添加到仓库中，用于整个仓库的共享 git暂存区 .git/objects 对象库当执行 git add 命令时，.git 目录下多了一个index文件，整个index文件就是暂存区，每条索引有个的四十位的十六进制的SHA-1 Hash，文件模式，权限，时间戳等。每个索引都对应对象库中的某个对象对应。除了索引之外，还维护了提前计算好的tree对象的内容。当我们提交的时候，可以直接通过提前计算好的，直接生成索引等内容。当文件名更改时，根据文件内容所计算出来的SHA-1 也不会变。暂存区索引每次更新的时候，都会重新计算index 和暂存区的内容。 git本地分支与合并git branch（创建分支) git tag（给commit做标记） git checkout（分支之间的切换） git stash（切换分支之前保存本地修改） git merge（合并分支） 例如：git branch test 新建分支 test。但是只是新建，要切换过去才能使用git checkout test 切换到test分支。test分支做的修改，不会影响到master分区的工作。也就是说分支互不影响。 tag 分 轻量级 本地引用 和 annotady 带注解的tag 通过 git log --online --decorate --graph -all 查看hash值，以及提交，查看历史示意图 git tag &quot;v0&quot; a1abda30 （a1abda30 就是上述命令查出的hash值） git tag -a &quot;INITAL_COMMIT&quot; a1abda30 标注tag，提示输出tag信息。 git tag 查看以有的设置过的tag git config --global alias.lol &quot;log --oneline --decorate --graph --all&quot; 用 git lol 代替 log --oneline --decorate --graph --all git show v0 （v0是一个tag的名字） GitHub提供个人或者企业的代码托管。可以查看其他的开源项目托管。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2018 徐州赛区网络预赛]]></title>
    <url>%2F2018%2F09%2F25%2FACM-Icpc-%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[1Time Limit: 1000ms Memory Limit: 262144KB Description Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256, which can transit a string into just 256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string s, s[i] represents the i th character in the string)we calculates the value(|(int) L – s[i]|), and write down the number(keeping leading zero. The length of each answer equals to 2 because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(s)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “11 45 14”. It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. Input First line a integer T, the number of test cases(T &lt;= 10) For each test case: First line contains a integer N and a character z, (N &lt;= 1000000) Second line contains a string with length N. Problem makes sure that all characters referred in the problem are only letters. Output A single number which gives the answer. Sample input23 zoMl6 YYJSNPI Sample output610 翻译12345678910Mur喜欢哈希算法，他有时加密另一个人的名字，然后用加密值给他打电话。例如，他打电话给Kimura KMR，并打电话给Suzuki YJSNPI。有一天，他读了一本关于SHA-256的书，它可以将字符串转换成256位。 Mur认为这很酷，他想出了一个新的算法来完成类似的工作。算法以这种方式工作：首先我们选择单个字母L作为种子，对于输入（您可以将输入视为字符串s，s [i]表示字符串中的第i个字符）我们计算值（ |（int）L - s [i] |），并记下数字（保持前导零。每个答案的长度等于2，因为字符串只包含字母和数字）。数字从左到右写入，最后将所有数字转换为单个整数（不带前导零）。例如，如果我们选择&apos;z&apos;作为种子，则字符串“oMl”变为“11 45 14”。很容易发现该算法无法将任何输入字符串转换为相同的长度。虽然在绝望中，Mur仍然想知道算法产生的答案的长度。由于穆尔的愚蠢，他甚至无法弄清楚这一点，所以你被分配了计算答案的工作。 输入 第一行是整数T，测试用例数（T &lt;= 10）对于每个测试用例：第一行包含整数N和字符z，（N &lt;= 1000000）第二行包含长度为N的字符串。确保问题中提到的所有字符都只是字母。 输出 一个数字给出了答案。 样本输入23 zoMl6 YYJSNPI 样本输出610 水题，但是特别坑。这里先讲第二个样例： 减出来的结果是 00 15 06 11 09 16这样去除前面的0，得出来的结果就是1506110916，这10位如果全部都是0呢 比如 4 zzzzz 这个时候就要输出 1 而不是 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;functional&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; int sum = 0; int len; char Seed, s; cin &gt;&gt; len &gt;&gt; Seed; bool flag = false, fir = true; for(int i=0; i&lt;len; i++)&#123; cin &gt;&gt; s; int t = Seed - s; t = abs(t); if(t != 0) flag = true; if(flag)&#123; if(fir)&#123; if(t &gt;= 1 &amp;&amp; t &lt;= 9) sum += 1; else sum += 2; fir = false; &#125; else sum += 2; &#125; &#125; if(flag == false) sum = 1; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; Description Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge a[i]. Unfortunately, the longer he learns, the fewer he gets. That means, if he reads books from l to r, he will get a[l]L+a[l+1](L-1)+…+a[r1]*2+a[r] (L is the length of [l, r] that equals to r-l+1). Now Ryuji has q questions, you should answer him: 1. If the question type is 1, you should answer how much knowledge he will get after he reads books [l, r] 2. If the question type is 2, Ryuji will change the ith book’s knowledge to a new value. Input First line contains two integers n and q (n, q &lt;= 100000). The next line contains n integers represent ai Then in next q line each line contains three integers a, b, c, if a = 1, it means question type is 1, and b, c represents [l, r]. if a = 2, it means question type is 2, and b, c means Ryuji changes the bth book’ knowledge to c. Output For each question, output one line with one integer represent the answer.Sample Input5 31 2 3 4 51 1 32 5 01 4 5 Sample Output108 翻译123456789101112 Ryuji不是一个好学生，他不想学习。 但他应该学习n本书，每本书都有自己的知识[i]。 不幸的是，他学的越久，得到的就越少。 这意味着，如果他从l到r读书，他将获得a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]（L 是[l，r]的长度，等于r-l + 1）。 现在Ryuji有q问题. 你应该回答他： 1。如果问题类型是1，你应该回答他读书后会得到多少知识[l，r] 2.如果问题类型是2，Ryuji会改变 ith书对新价值的认识。 输入 第一行包含两个整数n和q（n，q &lt;= 100000）。 下一行包含n个整数表示a [i]（a [i] &lt;= 1e9） 然后在下一个q行中每行包含三个整数a，b，c， 如果a = 1，则表示问题类型为1，b ，c代表[l，r]。 如果a = 2，则表示问题类型为2，b，c表示Ryuji将bth book的知识更改为c。 这里我维护的两个数组。一个是输入的数组x，另一个是数组z。定义数组z[i] = x[i] * (n-i+1)（i从1开始）然后定义两个数组 y 和 shu。其中 y数组用于维护x，shu数组用于维护z。这个解释一下z数组的用途，以及如何维护z数组。题目求的是a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]，如果暴力求解绝对超时。所以有个z数组。用样例来说：输入的 1 2 3 4 5那么 x 数组中就是 1 2 3 4 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z 数组中就是 5 8 9 8 5求 1~3 的和。那么如果直接加上 z[1~3] ，那么就是a[1]5 + a[2]4 + a[3]3。但是题目要求的是 a[1]3+a[2]2+a[3]1，也就是减去2倍的(a[1]+a[2]+a[3])。而这个2倍其实就是 区间 （l，r）中r距离尾部的单位值。这里是5 - 3 = 2。上面的例子很容易发现 z 数组的用途，提前预处理了题目要求的a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]。如此一来就可以用0（1）的时间求出要求的值，而不需要遍历。再来看，题目有两种状态一个是区间求和，另一个是修改值。碰到这种题目很容易想到的就是树状数组或者线段树，我这里用的是树状数组。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int sm = 400000+10;long long int x[sm];long long int n, q;long long int z[sm];// x存n个数，z ai*(n-i) i 从0 开始 long long int y[sm], shu[sm];// y 求区间和， 树状数组long long int lowbit(int x)&#123; return x&amp;(-x);&#125;long long find_sum(long long int i, long long zu[])&#123;//区间求和 long long int ret =0 ; for(; i&gt;0 ; ret += zu[i], i -= lowbit(i)); return ret;&#125;void update(long long int i, long long int val, long long zu[])&#123;//建树, 更新值 for(;i &lt;= n; zu[i] += val, i += lowbit(i));&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; q; for(int i =1 ; i&lt;=n; i++) cin &gt;&gt; x[i]; for(int i=1; i&lt;=n; i++) update(i, x[i], y);//建立y，维护x数组 for(int i=1; i&lt;=n; i++) z[i] = x[i] * (n-i+1); for(int i=1; i&lt;=n; i++) update(i, z[i], shu);//建立shu，维护z数组 for(int i=1; i&lt;=q; i++) &#123; long long int t; cin &gt;&gt; t; if(t == 1)&#123; long long int l, r, suml, sumr; cin &gt;&gt; l &gt;&gt; r; long long int s1 = find_sum(r, shu) - find_sum(l-1, shu);//获得z数组的区间和 long long int s2 = find_sum(r, y) - find_sum(l-1, y);//获取x数组的区间和 cout &lt;&lt; s1 - s2*(n-r) &lt;&lt; endl; &#125; if(t == 2)&#123; long long int new_num, where; cin &gt;&gt; where &gt;&gt; new_num;//where代表位置，new_num代表值 long long int mid = new_num - x[where]; update(where, mid, y);//更新y数组 update(where, mid*(n - where + 1), shu);//更新shu数组 x[where] = new_num;//更新x数组中的值 &#125; &#125; return 0;&#125; ！！！！着重强调，如果用我这种方法做的人，一定要用`long long ！！！！`本来觉得部分数据不大可以部分不用long long，结果不知道那块就是卡住了死交不过去，wa了四五发都是因为这个。 ACM本就是逆天而行，死在路上很正常。真的，看到别人大佬一队AK了，我才做了两题，就感觉对不起队友，对不起老师。天赋上的差距没办法，自己还是很菜，再加上最近在搭建服务器，导致算法上面没用心，最后一年了，好好搞。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cocos 2d游戏——I wanna save the princess]]></title>
    <url>%2F2018%2F09%2F25%2Fcocos2dx%2F</url>
    <content type="text"><![CDATA[基于cocos-2dx的游戏制作——I wanna save the princess 在进行了两周的cocos学习之后，可以开始进行游戏的创作了。I wanna主要复杂的地方在于地图的设计以及逻辑实现。下面依次进行介绍。（使用c++） 一． 瓦片地图——tile map 1. 地图整体的大小。 配合电脑可以全屏显示，设置为1080X1920的大小。 2. 图块的大小。使用Tile map制作地图，因为它非常方便，可以将图片素材直接放到图块中，并且大小可以随意调节。比如：所有的地图图块设置为30X30像素，因此普通的土块和草地都是30X30的大小。但是在下面的场景中，因为水是直接在tile map中显示的，所以设置为了1920X900的大小。3. 图层的设置。 在这个界面中，可以新建多个图层，将不同属性的图块放入。 比如：土块和刺是分开的两个图层。 每一个形状的刺分别的一个图层。向上的刺。 向左的刺。 隐藏的刺与可以触发的刺也是不同的图层。地图上直接可见的，向上的刺。并非直接可见，需要触发条件的，向上的刺。 在图层的设置中，可以将同一属性的图层用一个新的图层覆盖，并且设置不可穿透的属性，这样在导入图层的时候会比较方便。在所有不可穿透的图层中，覆盖了一层红色图层，在vs中导入的同时，设置为不可穿透。（不可穿透是利用下文中掩码的作用。） 4. 人物图层。 在建立图层的时候，选择添加对象层，然后选择建立矩形，在地图上的任一个地方画出任意大小的矩形，代表人物。（相应操作在图上用红色方框表示。） 5. 特殊图层。 因为I wanna游戏的特殊，经常有不同的隐藏刺。这个部分首先需要在不同的图层中实现，然后需要一个对应的触发图层。 观察红色方框中图层的顺序，现在的位置是游戏地图中正常图层的位置，即土块将隐藏刺遮住了。 调整顺序后可以看到隐藏刺。 地图中红色图层的作用是，判断人物当前的位置x坐标是否与此图层中的某一个相同，相同则触发刺向上飞的事件。 这个触发图层的作用是，在地图中，人物在触碰到这个图层的同时，触发对应tag中的事件，比如让刺飞出，或是在踩到触发图层时冒出。 导入的图层为上一张图片中的yincang图层，设置tag为4。 人物的tag为1，当两个物体的tag分别为1和4的时候，触发事件。 在导入隐藏刺的同时设置冒出的移动，当人物与刺所在的图块接触，刺冒出。 触发刺飞出的事件。 二． 物理引擎 1． 建立物理世界。2． 重力的添加以及改变。 添加在创建物理世界时写入。在第三个场景的水中，需要更改重力的大小。 3． 添加不同的刚体。 普通的刚体，是矩形的。 因为刺是三角形的，所以需要建立一个数组存储三角形的三个顶点坐标，然后再附给物体，这样就是一个三角形的刚体。 4． 介绍三种掩码。 类别掩码setCategoryBitMask，接触检测掩码setContactTestBitmask，碰撞掩码setCollisionBitmask。分别将两个物体的类别掩码与接触检测掩码进行逻辑与运算，可以判断是否触发接触事件，类似的，可以判断是否穿透或者碰撞。 人物的三种掩码。 5． 重新开始。 将当前场景舍弃，重新生成一个新的场景，进行替换。 6． 键盘事件。 人物可以进行向左前进，向右前进，跳跃这三种动作，在此函数中，按下不同的键实现不同的事件。 7． 标签的添加。 在导入图层的时候就分别设置不同的tag，以便于在函数中进行相应的判断。 人物与刺碰撞，触发游戏结束的事件，在界面中添加游戏结束的图片，并且取消键盘事件，但可以按R键重新开始。（所有的刺tag都为3） 在最后切换场景时，有一个被隐藏了的触发图层，在人物接触到的同时进行tag的比较，从而可以切换场景。 8． 计时器函数 进行场景中物理引擎的手动更新。 9． 碰撞检测。 利用三种掩码进行判断。人物与土块。（人物的掩码在上方，三个都是7）（这个图层就是上方介绍过的覆盖图层）进行判断后为不可穿透。 人物与水。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
