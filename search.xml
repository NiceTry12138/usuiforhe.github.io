<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F09%2F25%2FGit%2F</url>
    <content type="text"><![CDATA[Git的起源linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bitkeep说开源社区中的一个成员对bitkeep的协议进行逆向工程。因此，自己写了git。 SVN-&gt;集中式版本控制系统：只有中央服务器有版本的数据库，其他电脑没有，所有版本控制都要通过中央服务器进行交互。（要是中央服务器当机离线，则就出大问题了）git-&gt;分布式版本控制：每一个台电脑上面都有一个版本的database。由于每台电脑都有数据库，所以大多数操作可以离线进行。支持比较多的控制模式-也可以安装一个中央服务器。 git每个版本存储的都是当前版本的所有内容，不需要与其他版本进行差异比较之后再进行文件的合成。 git可以离线完成大部分操作。 git有更优雅的分支和合并实现。 git有更强大撤销修改和修改版本历史的能力。 git速度更快，效率更高。 为什么学习git：研究GitHub越来越多的公司通过git调整 git如何存储文件，历史记录：git通过40个16进制字符的SHA-1 Hash 来唯一标识对象 例如： e98757d0598ab6eeaf1df0d87dd00826048bd80bgit有四种对象： 1. blob：文本文件或者二进制文件或者链接文件 2. tree：目录 3. commit：历史提交 4. tag：指向固定的历史提交 (-&gt;）指向的意思 tag -&gt; commit -&gt; tree -&gt; 多个tree对象或者多个blob对象对工作区的这些内容进行SHA-1 Hash 之后，就可以得到唯一标识。如果两个文件内容是相同的，则他们指向同一个blob对象。而文件名这种信息会存在tree对象中。 有了git对象之后，需要git仓库去存储对象，和操作对象。git init git clone 两种方法获取仓库。cd 到.git 文件夹中 （GIT_DIR!）-&gt; git工作区间 用 ls 查看git需要的文件再退出来用init方法创建一个裸仓库。然后查看仓库中有什么。git init –bare git_bare_repo通过–bare 方法创建一个 git_bare_repo 文件夹。这个文件夹只有git工作需要的文件。git clone 克隆出一个仓库 一般来说需要远程裸仓库的地址git clone git_bare_repo/ git_clone_repo （复制之前创建的本地仓库，并创建在文件夹 git_clone_repo中） git分为三个区域： working directory（工作区，日常编辑代码的地方） staging area（暂存区，工作区与历史提交的缓存，维护的是虚拟的树形结构） history repository（历史仓库） （1）工作区 添加文件到 暂存区 提交整个暂存区的状态 历史纪录区（2）历史记录区 检出文件到 暂存区和工作区大部分时间我们都在做第一个工作对应的就是 git add（到暂存区） 和 git commit（到历史记录区） git status（查看工作区和暂存区的区别，确保提交是我们所需要的） git rm（从暂存区删掉我们不需要的东西） git mv（移动文件） gitignore（确保不想添加到暂存区和历史纪录区的文件不被添加） 先 创建 a b 两个文件 touch a touch b然后添加到暂存区 git add a b查看一下 git status提交到历史纪录 git commit -m “initial commit” （加入一个提交的历史信息）修改一下a vim a（加入一些文字信息）再看一下 git status 提示 a 修改了 但是没有提交到暂存区提交a到暂存区中 git add a再status 看一下 git status再提交 a 就行 git commit -m “modify a”删除a，会删除 工作区 ，暂存区中的a git rm a还原一下a git checkout a如何只删除暂存区的文件，不删除工作目录的文件 git rm –cached a git status 看看就会提示有一个没有跟踪的文件git mv a c （将a名字命名为c）（这个命令是一系列操作的总和） 如果直接再工作区修改文件名 mv a c （工作目录直接 修改名字） 再 git status 提示 a 被删除了 ， 有个c 的文件没有被跟踪 再 git add a c（添加a c 到文件中） 提示文件 a 被更改为 cgit add -A 添加整个工作区都暂存区git .gitignore 在顶层目录下创建一个.gitignore文件.[oa]通过通配符提示git，以 o 和 a 结尾的文件不要添加到git仓库中例如：加入了 .~, *.pyc ， 但是如果以.pyc为后缀的文件，有一个要加到仓库，这个时候就要在文件名上加 !test.pyc，告诉 test.pyc 不要被忽略。如果需要ingore文件名第一个字符就是“！”，就要加上”\”转义字符。**/res 匹配 res，所有路径下的res，任何文件夹下的res。git add .gitignoregit commit -m “add ingore”//添加到仓库中，用于整个仓库的共享 git暂存区 .git/objects 对象库当执行 git add 命令时，.git 目录下多了一个index文件，整个index文件就是暂存区，每条索引有个的四十位的十六进制的SHA-1 Hash，文件模式，权限，时间戳等。每个索引都对应对象库中的某个对象对应。除了索引之外，还维护了提前计算好的tree对象的内容。当我们提交的时候，可以直接通过提前计算好的，直接生成索引等内容。当文件名更改时，根据文件内容所计算出来的SHA-1 也不会变。暂存区索引每次更新的时候，都会重新计算index 和暂存区的内容。 git本地分支与合并git branch（创建分支) git tag（给commit做标记） git checkout（分支之间的切换） git stash（切换分支之前保存本地修改） git merge（合并分支） 例如：git branch test 新建分支 test。但是只是新建，要切换过去才能使用git checkout test 切换到test分支。test分支做的修改，不会影响到master分区的工作。也就是说分支互不影响。 tag 分 轻量级 本地引用 和 annotady 带注解的tag 通过 git log --online --decorate --graph -all 查看hash值，以及提交，查看历史示意图 git tag &quot;v0&quot; a1abda30 （a1abda30 就是上述命令查出的hash值） git tag -a &quot;INITAL_COMMIT&quot; a1abda30 标注tag，提示输出tag信息。 git tag 查看以有的设置过的tag git config --global alias.lol &quot;log --oneline --decorate --graph --all&quot; 用 git lol 代替 log --oneline --decorate --graph --all git show v0 （v0是一个tag的名字） GitHub提供个人或者企业的代码托管。可以查看其他的开源项目托管。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2018 徐州赛区网络预赛]]></title>
    <url>%2F2018%2F09%2F25%2FACM-Icpc-%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[1Time Limit: 1000ms Memory Limit: 262144KB Description Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256, which can transit a string into just 256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string s, s[i] represents the i th character in the string)we calculates the value(|(int) L – s[i]|), and write down the number(keeping leading zero. The length of each answer equals to 2 because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(s)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “11 45 14”. It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. Input First line a integer T, the number of test cases(T &lt;= 10) For each test case: First line contains a integer N and a character z, (N &lt;= 1000000) Second line contains a string with length N. Problem makes sure that all characters referred in the problem are only letters. Output A single number which gives the answer. Sample input23 zoMl6 YYJSNPI Sample output610 翻译12345678910Mur喜欢哈希算法，他有时加密另一个人的名字，然后用加密值给他打电话。例如，他打电话给Kimura KMR，并打电话给Suzuki YJSNPI。有一天，他读了一本关于SHA-256的书，它可以将字符串转换成256位。 Mur认为这很酷，他想出了一个新的算法来完成类似的工作。算法以这种方式工作：首先我们选择单个字母L作为种子，对于输入（您可以将输入视为字符串s，s [i]表示字符串中的第i个字符）我们计算值（ |（int）L - s [i] |），并记下数字（保持前导零。每个答案的长度等于2，因为字符串只包含字母和数字）。数字从左到右写入，最后将所有数字转换为单个整数（不带前导零）。例如，如果我们选择&apos;z&apos;作为种子，则字符串“oMl”变为“11 45 14”。很容易发现该算法无法将任何输入字符串转换为相同的长度。虽然在绝望中，Mur仍然想知道算法产生的答案的长度。由于穆尔的愚蠢，他甚至无法弄清楚这一点，所以你被分配了计算答案的工作。 输入 第一行是整数T，测试用例数（T &lt;= 10）对于每个测试用例：第一行包含整数N和字符z，（N &lt;= 1000000）第二行包含长度为N的字符串。确保问题中提到的所有字符都只是字母。 输出 一个数字给出了答案。 样本输入23 zoMl6 YYJSNPI 样本输出610 水题，但是特别坑。这里先讲第二个样例： 减出来的结果是 00 15 06 11 09 16这样去除前面的0，得出来的结果就是1506110916，这10位如果全部都是0呢 比如 4 zzzzz 这个时候就要输出 1 而不是 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;functional&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; int sum = 0; int len; char Seed, s; cin &gt;&gt; len &gt;&gt; Seed; bool flag = false, fir = true; for(int i=0; i&lt;len; i++)&#123; cin &gt;&gt; s; int t = Seed - s; t = abs(t); if(t != 0) flag = true; if(flag)&#123; if(fir)&#123; if(t &gt;= 1 &amp;&amp; t &lt;= 9) sum += 1; else sum += 2; fir = false; &#125; else sum += 2; &#125; &#125; if(flag == false) sum = 1; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; Description Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge a[i]. Unfortunately, the longer he learns, the fewer he gets. That means, if he reads books from l to r, he will get a[l]L+a[l+1](L-1)+…+a[r1]*2+a[r] (L is the length of [l, r] that equals to r-l+1). Now Ryuji has q questions, you should answer him: 1. If the question type is 1, you should answer how much knowledge he will get after he reads books [l, r] 2. If the question type is 2, Ryuji will change the ith book’s knowledge to a new value. Input First line contains two integers n and q (n, q &lt;= 100000). The next line contains n integers represent ai Then in next q line each line contains three integers a, b, c, if a = 1, it means question type is 1, and b, c represents [l, r]. if a = 2, it means question type is 2, and b, c means Ryuji changes the bth book’ knowledge to c. Output For each question, output one line with one integer represent the answer.Sample Input5 31 2 3 4 51 1 32 5 01 4 5 Sample Output108 翻译123456789101112 Ryuji不是一个好学生，他不想学习。 但他应该学习n本书，每本书都有自己的知识[i]。 不幸的是，他学的越久，得到的就越少。 这意味着，如果他从l到r读书，他将获得a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]（L 是[l，r]的长度，等于r-l + 1）。 现在Ryuji有q问题. 你应该回答他： 1。如果问题类型是1，你应该回答他读书后会得到多少知识[l，r] 2.如果问题类型是2，Ryuji会改变 ith书对新价值的认识。 输入 第一行包含两个整数n和q（n，q &lt;= 100000）。 下一行包含n个整数表示a [i]（a [i] &lt;= 1e9） 然后在下一个q行中每行包含三个整数a，b，c， 如果a = 1，则表示问题类型为1，b ，c代表[l，r]。 如果a = 2，则表示问题类型为2，b，c表示Ryuji将bth book的知识更改为c。 这里我维护的两个数组。一个是输入的数组x，另一个是数组z。定义数组z[i] = x[i] * (n-i+1)（i从1开始）然后定义两个数组 y 和 shu。其中 y数组用于维护x，shu数组用于维护z。这个解释一下z数组的用途，以及如何维护z数组。题目求的是a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]，如果暴力求解绝对超时。所以有个z数组。用样例来说：输入的 1 2 3 4 5那么 x 数组中就是 1 2 3 4 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z 数组中就是 5 8 9 8 5求 1~3 的和。那么如果直接加上 z[1~3] ，那么就是a[1]5 + a[2]4 + a[3]3。但是题目要求的是 a[1]3+a[2]2+a[3]1，也就是减去2倍的(a[1]+a[2]+a[3])。而这个2倍其实就是 区间 （l，r）中r距离尾部的单位值。这里是5 - 3 = 2。上面的例子很容易发现 z 数组的用途，提前预处理了题目要求的a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]。如此一来就可以用0（1）的时间求出要求的值，而不需要遍历。再来看，题目有两种状态一个是区间求和，另一个是修改值。碰到这种题目很容易想到的就是树状数组或者线段树，我这里用的是树状数组。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int sm = 400000+10;long long int x[sm];long long int n, q;long long int z[sm];// x存n个数，z ai*(n-i) i 从0 开始 long long int y[sm], shu[sm];// y 求区间和， 树状数组long long int lowbit(int x)&#123; return x&amp;(-x);&#125;long long find_sum(long long int i, long long zu[])&#123;//区间求和 long long int ret =0 ; for(; i&gt;0 ; ret += zu[i], i -= lowbit(i)); return ret;&#125;void update(long long int i, long long int val, long long zu[])&#123;//建树, 更新值 for(;i &lt;= n; zu[i] += val, i += lowbit(i));&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; q; for(int i =1 ; i&lt;=n; i++) cin &gt;&gt; x[i]; for(int i=1; i&lt;=n; i++) update(i, x[i], y);//建立y，维护x数组 for(int i=1; i&lt;=n; i++) z[i] = x[i] * (n-i+1); for(int i=1; i&lt;=n; i++) update(i, z[i], shu);//建立shu，维护z数组 for(int i=1; i&lt;=q; i++) &#123; long long int t; cin &gt;&gt; t; if(t == 1)&#123; long long int l, r, suml, sumr; cin &gt;&gt; l &gt;&gt; r; long long int s1 = find_sum(r, shu) - find_sum(l-1, shu);//获得z数组的区间和 long long int s2 = find_sum(r, y) - find_sum(l-1, y);//获取x数组的区间和 cout &lt;&lt; s1 - s2*(n-r) &lt;&lt; endl; &#125; if(t == 2)&#123; long long int new_num, where; cin &gt;&gt; where &gt;&gt; new_num;//where代表位置，new_num代表值 long long int mid = new_num - x[where]; update(where, mid, y);//更新y数组 update(where, mid*(n - where + 1), shu);//更新shu数组 x[where] = new_num;//更新x数组中的值 &#125; &#125; return 0;&#125; ！！！！着重强调，如果用我这种方法做的人，一定要用`long long ！！！！`本来觉得部分数据不大可以部分不用long long，结果不知道那块就是卡住了死交不过去，wa了四五发都是因为这个。 ACM本就是逆天而行，死在路上很正常。真的，看到别人大佬一队AK了，我才做了两题，就感觉对不起队友，对不起老师。天赋上的差距没办法，自己还是很菜，再加上最近在搭建服务器，导致算法上面没用心，最后一年了，好好搞。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cocos 2d游戏——I wanna save the princess]]></title>
    <url>%2F2018%2F09%2F25%2FI%20wanna%20save%20the%20princess%2F</url>
    <content type="text"><![CDATA[基于cocos-2dx的游戏制作——I wanna save the princess 在进行了两周的cocos学习之后，可以开始进行游戏的创作了。I wanna主要复杂的地方在于地图的设计以及逻辑实现。下面依次进行介绍。（使用c++） 一． 瓦片地图——tile map 1. 地图整体的大小。 配合电脑可以全屏显示，设置为1080X1920的大小。 2. 图块的大小。使用Tile map制作地图，因为它非常方便，可以将图片素材直接放到图块中，并且大小可以随意调节。比如：所有的地图图块设置为30X30像素，因此普通的土块和草地都是30X30的大小。但是在下面的场景中，因为水是直接在tile map中显示的，所以设置为了1920X900的大小。3. 图层的设置。 在这个界面中，可以新建多个图层，将不同属性的图块放入。 比如：土块和刺是分开的两个图层。 每一个形状的刺分别的一个图层。向上的刺。 向左的刺。 隐藏的刺与可以触发的刺也是不同的图层。地图上直接可见的，向上的刺。并非直接可见，需要触发条件的，向上的刺。 在图层的设置中，可以将同一属性的图层用一个新的图层覆盖，并且设置不可穿透的属性，这样在导入图层的时候会比较方便。在所有不可穿透的图层中，覆盖了一层红色图层，在vs中导入的同时，设置为不可穿透。（不可穿透是利用下文中掩码的作用。） 4. 人物图层。 在建立图层的时候，选择添加对象层，然后选择建立矩形，在地图上的任一个地方画出任意大小的矩形，代表人物。（相应操作在图上用红色方框表示。） 5. 特殊图层。 因为I wanna游戏的特殊，经常有不同的隐藏刺。这个部分首先需要在不同的图层中实现，然后需要一个对应的触发图层。 观察红色方框中图层的顺序，现在的位置是游戏地图中正常图层的位置，即土块将隐藏刺遮住了。 调整顺序后可以看到隐藏刺。 地图中红色图层的作用是，判断人物当前的位置x坐标是否与此图层中的某一个相同，相同则触发刺向上飞的事件。 这个触发图层的作用是，在地图中，人物在触碰到这个图层的同时，触发对应tag中的事件，比如让刺飞出，或是在踩到触发图层时冒出。 导入的图层为上一张图片中的yincang图层，设置tag为4。 人物的tag为1，当两个物体的tag分别为1和4的时候，触发事件。 在导入隐藏刺的同时设置冒出的移动，当人物与刺所在的图块接触，刺冒出。 触发刺飞出的事件。 二． 物理引擎 1． 建立物理世界。2． 重力的添加以及改变。 添加在创建物理世界时写入。在第三个场景的水中，需要更改重力的大小。 3． 添加不同的刚体。 普通的刚体，是矩形的。 因为刺是三角形的，所以需要建立一个数组存储三角形的三个顶点坐标，然后再附给物体，这样就是一个三角形的刚体。 4． 介绍三种掩码。 类别掩码setCategoryBitMask，接触检测掩码setContactTestBitmask，碰撞掩码setCollisionBitmask。分别将两个物体的类别掩码与接触检测掩码进行逻辑与运算，可以判断是否触发接触事件，类似的，可以判断是否穿透或者碰撞。 人物的三种掩码。 5． 重新开始。 将当前场景舍弃，重新生成一个新的场景，进行替换。 6． 键盘事件。 人物可以进行向左前进，向右前进，跳跃这三种动作，在此函数中，按下不同的键实现不同的事件。 7． 标签的添加。 在导入图层的时候就分别设置不同的tag，以便于在函数中进行相应的判断。 人物与刺碰撞，触发游戏结束的事件，在界面中添加游戏结束的图片，并且取消键盘事件，但可以按R键重新开始。（所有的刺tag都为3） 在最后切换场景时，有一个被隐藏了的触发图层，在人物接触到的同时进行tag的比较，从而可以切换场景。 8． 计时器函数 进行场景中物理引擎的手动更新。 9． 碰撞检测。 利用三种掩码进行判断。人物与土块。（人物的掩码在上方，三个都是7）（这个图层就是上方介绍过的覆盖图层）进行判断后为不可穿透。 人物与水。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[python计算机视觉]]></title>
    <url>%2F2018%2F02%2F02%2Fpython%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%2F</url>
    <content type="text"><![CDATA[基本的图像操作和处理PIL python 图像处理类库 PIL (python imageing library ) 提供了通用的图像处理功能 以及大量有用的基本图像操作 比如图像的 缩放 裁剪 旋转 颜色转换 等等 从http://www.python.com/products/pil/下载 读取一副图像 12from PIL import Imagepil_im = Image.open('1234.jpg') 图像的颜色转换 使用 convert() 方法 1pil_im = Image.open('1234.jpg').convert('L') 更多例子参见 http://www.pythonware.com/library/pil/handbook/index.htm 转换图像格式 通过save方法，PIL可以将图像保存成多种格式的文件 123456789101112from PIL import Imageimport osfilelist = []filelist.append('1234.jpg')for infile in filelist: outfile = os.path.splitext(infile)[0]+'.jpg' if infile != outfile: try: Image.open(infile).save(outfile) except IOError: print("outfile error") 除了后缀变成了 jpg ，上述代码的新文件名和原文件名相同 PIL函数会进行简单的检查，如果文件不是JPEG格式，会自动将其转换成JPEG格式 如果转换失败，则会在控制台输出一个失败消息 获取目录中所有jpg图像的文件名列表12345678from PIL import Imageimport osdef get_imlist(path): return [os.path.join(path,f) for f in os.listdir(path) if f.endswith('jpg')]print(get_imlist('./')) 创建缩略图 使用thumbnail()方法接受一个元祖参数（该参数指定生成缩略图的大小） 1pil_im.thumbnail((128,128)) 复制和粘贴图像区域 使用crop()方法可以从一幅图像中裁剪指定区域 12345678from PIL import Imageimport ospil_im = Image.open('123.jpg')print(pil_im)pil_im = pil_im.crop((100,100,200,200))pil_im.save(os.path.splitext('12345')[0] + '.jpg')print(pil_im) 调整尺寸和旋转 使用resize() 方法 可以调整一幅图像的尺寸，该方法的参数是一个元祖，利用指新图像的大小 使用 rotate() 方法 可以使用逆时针方式 表示 旋转角度， 参数是角度 123456789101112from PIL import Imageimport ospil_im = Image.open('123.jpg')print(pil_im)pil_im = pil_im.resize((128,128))print(pil_im)pil_im.save(os.path.splitext('1234')[0] + '.jpg')pil_im = pil_im.rotate(50)print(pil_im) pil_im.save(os.path.splitext('12345')[0] + '.jpg') Matplotlib Matplotlib 是一个 处理数学运算，绘制图表，或者在图像上绘制 点，直线和曲线很好的类库 安装 matplotlib python -m pip install matplotlib 绘制 图像，点和线 Matplotlib 可以绘制出比较好的 条形图，饼状图，散点图等 但是，对于大多处计算机视觉应用来说，仅仅需要几个绘图命令 用画几个点和一条线 1234567891011121314151617181920212223from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('123.jpg'))print(type(im))# 绘制图像imshow(im)# 一些点x = [100,100,400,400]y = [200,500,200,500]# 使用红色星状标记绘制点plot(x, y, 'r*')# 绘制连接前两个点的线plot(x[:2], y[:2])# 添加标题，显示绘制的图像title('Plotting:"empire.jpg"')show() 绘制的四个点 分别对应 (x[0], y[0])，(x[1],y[1])，(x[2],[y2])，(x[3],y[3]) 连接的是数组中的 前两个 x[:2] 就是 x[0],x[1]，y同理 show()命令首先打开图形用户界面（GUI），然后新建一个图像窗口，在每个脚本中仅能调用一次，而且一般在结尾调用 加上 axis(&#39;off&#39;) 可以不显示 x，y 轴 还有一些其他的命令 1234plot(x, y) # 默认是蓝色实线plot(x, y, 'r*') # 红色星状标记plot(x, y, 'go-') # 带有圆圈标记的绿线plot(x, y, 'ks:') # 带有正方形标记的褐色虚线 命令 颜色 ‘b’ 蓝色 ‘g’ 绿色 ‘r’ 红色 ‘c’ 青色 ‘m’ 品红 ‘y’ 黄色 ‘k’ 黑色 ‘w’ 白色 命令 线的形状 ‘-‘ 实线 ‘–’ 虚线 ‘:’ 点线 命令 点的形状 ‘.’ 点 ‘o’ 圆圈 ‘s’ 正方形 ‘*’ 星形 ‘+’ 加号 ‘x’ ×号 图像轮廓和直方图 因为绘制轮廓需要对每个坐标[x, y] 的像素值施加同一个阀值，所以需要将图像灰度化 即 convert(‘L’) 图像的直方图涌来表征该图像像素值的分布情况 用一定数目的小区间（bin）来指定表征像素值的方位，每个小区间都会得到落入该小区间表示范围的像素数目 该（灰度）图像的直方图可以使用hist()函数绘制 hits() 函数的第二个参数指定小区间的数目 hits()函数只接受一维数组作为输入，所以在绘制图像直方图之前，必须对图像进行压平处理 flatten()方法将任意数组按照优先准则转换成一维数组 12345678910111213141516171819from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('12345.jpg').convert('L'))# 新建一个图像figure()# 不使用颜色信息gray()# 在原点的左上角显示轮廓图像contour(im, origin='image')axis('equal')axis('off')figure()hist(im.flatten(), 128)show() 交互式标注 有时候用户需要和某些应用交互，例如在一副图像中标记一些点，或者标注一些训练数据 PyLab库中的ginput() 函数就可以实现交互式标注 这里首先绘制图象，然后等待用户在绘图窗口区域点击三次 程序会自动将这些点击的坐标[x, y] 自动保存到 x 列表中 1234567891011from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('12345.jpg'))imshow(im)print('click 3 point')x = ginput(3) # 标记点有三个print('you clicked', x)show() Numpy NumPy 是非常有名的Python科学计算工具包，包含大量有用的思想 数组对象（用来表示向量，矩阵，图象等） 线性代数等 NumPy 中的 数组对象可以实现很多重要操作 矩阵乘积 转置 解方程系统 向量乘积 归一化 为图形变形，对变化进行建模，图象分类，图象聚类等提供了基础 图象数组表示 先前的例子中 使用 array()方法将图象转换为NumPy 的数组对象 NumPy中的数组对象是多维的，可以用来表示向量，矩阵和图象 一个数组对象很像一个列表(或者是列表的列表)，但是数组中所有元素必须具有相同的数据类型 小例子 12345678910from PIL import Imagefrom pylab import *# 读取图像到数组中im = array(Image.open('12345.jpg'))print(im.shape, im.dtype)im = array(Image.open('12345.jpg').convert('L'), 'f')print(im.shape, im.dtype) 输出为 12(2976, 3968, 3) uint8(2976, 3968) float32 每行的第一个元祖表示 图象数组的大小 (行，列，颜色通道) 紧接着的字符串表示数组元素的数据类型 图象通道通常被编码为无符号八位整数(uint8) 第二个因为进行过灰度处理，并且在创建数组时进行了额外的类型转换’f’，所以是float32(浮点型)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Security 为了安全]]></title>
    <url>%2F2018%2F01%2F31%2FSpring%20Security%20%E4%B8%BA%E4%BA%86%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Spring Security Spring Security 支持： 用户名+密码登录 手机号+短信认证 Spring Social 支持： 第三方认证(微信，qq等) Spring Security OAuth 支持APP的上述三种登录方式 用户名+短信登录 手机号+短信认证 第三方认证]]></content>
  </entry>
  <entry>
    <title><![CDATA[骚鸡儿的 Python]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%B0%8F%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Github上关注的库，定时检查是否更新原理 通过访问 https://api.github.com/repos/usuiforhe/2048 可以知道，github提供了一套API 即 “https://api.github.com/repose/&quot; + “用户名” + “/“ + “仓库名” 可以查询 仓库发布时间 更新时间 所用语言 仓库大小 等等 通过记录上次更新时间，可以与当前更新时间进行对比，如果不同则更新了 从图可以看出，返回的是一个json的数据格式 “updated_at” 即 更新时间 代码1234567891011121314151617181920212223import requestsimport timeimport webbrowserapi_url = 'https://api.github.com/repos/usuiforhe/2048'visit_url = 'https://github.com/usuiforhe/2048'last_time = '2019-01-10T15:44:05Z' # 初始化时间headher = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&#125;while(True): data = requests.get(api_url, headers=headher).json() # 请求数据 new_time = data['updated_at'] # 获取当前时间 if new_time &gt; last_time: last_time = new_time # 更新时间 webbrowser.open(visit_url) # 之后打开浏览器 time.sleep(3600) # 休息事件 3600s， 也就是说每一小时请求一次 展示特意隐藏起来的文件的小工具原理 在 linux/mac 系统中，只要文件夹或文件前面带有 ‘.’ 例如 ‘.text.py’ 则代表这是隐藏文件 在windows 系统中，不好实现…… 简单方法是将文件夹/文件名前面都加一个一个标识符，表示这个是被隐藏起来的 代码12345678910111213141516171819202122232425from tkinter import *import osapp = Tk()# 创建窗口# btn = Button(text='click me') # 实例化按钮# btn.pack() # 显示按钮# app.mainloop() label = Label(text='All Hidden files', font=('Hack', 25, 'bold'))# 创建文字标签，内容为all hidden files，字体为font 中的 hack，大小为25，粗体label.pack()listbox = Listbox(height=5) # 展示列表# listbox.insert(END, 'something') # end 代表末尾， 加入 something# END 是 (0,0) 坐标，tkinter 里面将 END 定义为常量listbox.pack(fill=BOTH, expand=True) # fill 填充的意思，有 X 填充， Y轴填充，BOTH xy都填充，expand 为true则扩展到整个x或ydef find_files(path): files = os.listdir(path) for file in files: if file.startswith('.'): # linux 和 mac 隐藏文件是以 '.' 开头的 # print(file) listbox.insert(END, file)find_files('/home/cong')app.mainloop() 压缩图片的小工具原理 有一个库 PIL 库，可以实现压缩 以界面的形式与用户交互 路径由用户决定 压缩大小由用户决定 即变量大都由用户决定 用listbox显示路径中选中的图片 使用 grid() 方法设置 布局 PIL有个Image类，而tkinter中也有Image类 因此 要 from PIL import Image as Img 这样就不会冲突了 tkiner中的珊格布局有几种：pack(), grid() 等 这几种不能混合使用，一个窗口中的布局 仅能使用一个 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from PIL import Image as Imgfrom tkinter import *from tkinter.filedialog import *path = []# width 单位像素# height 单位像素# opcity 单位百分比 1~100def save_new_image(): for file_path in path: image = Img.open(file_path) # 打开路径中的图片 if window.children['entry_width'].get() == '': # 如果没有输入目标宽度，则保留宽度 width = image.size[0] else: width = int(window.children['entry_width'].get()) if window.children['entry_height'].get() == '':# 如果没有输入目标高度，则保留高度 height = image.size[1] else: height = int(window.children['entry_height'].get()) if window.children['entry_opcity'].get() == '':# 如果没有输入目标压缩比，则默认不压缩 opcity = 100 else : opcity = int(window.children['entry_opcity'].get()) image.resize((width, height)).save(file_path+'new.jpg', quality=opcity) # 设置图片宽高 将图片保存到新路径，并压缩 quality的 百分比 window.children['listbox'].delete(0, END)def find_path(): file_Names = askopenfilenames() # 可以框选多个 lbox = window.children['listbox'] # 获取window的子控件中name为 listbox 的 global path path = file_Names for name in file_Names: if name.split('/')[-1].endswith('jpg') or name.split('/')[-1].endswith('png') or name.split('/')[-1].endswith('jpeg'): lbox.insert(END, name.split('/')[-1]) # name为一个路径，所以以 '/' 为分隔符，获取文件名 pass# def do()&#123;# print('1')# &#125;# button = Button(text='click, command=do) 后面的参数 command 则是回调函数def make_window(): window = Tk() # pack() 和 grid() 不能同时使用 Label(text='Image compress tool', font=('Hack', 25, 'bold')).grid(row=0, rowspan=2, column=0, columnspan=6) # 标题 Label(window, text='宽度').grid(row=6, column=0, columnspan=2) Label(window, text='高度').grid(row=6, column=2, columnspan=2) Label(window, text='压缩比').grid(row=6, column=4, columnspan=2) Entry(window, name='entry_width').grid(row=7, column=0, columnspan=2) # 宽度输入框 Entry(window, name='entry_height').grid(row=7, column=2, columnspan=2) # 高度输入框 Entry(window, name='entry_opcity').grid(row=7, column=4, columnspan=2) # 压缩比 Listbox(window, name='listbox', bg='#f2f2f2',font=('Hack', 15)).grid(row=2, rowspan=4, column=0, columnspan=6) Button(window, text='打开', command=find_path).grid(row=8,rowspan=2, column=0, columnspan=3) Button(window, text='压缩', command=save_new_image).grid(row=8,rowspan=2, column=3, columnspan=3) window.geometry('450x350') # 窗口大小 return windowwindow = make_window()window.mainloop() 实时测速网络小工具原理 如何实现检测实时网速 单位时间内电脑得到的数据量的大小 安装 psutil pip install psutil process and system utilities 不仅可以通过一两行代码实现系统监控 还可以跨平台使用，支持Linux／UNIX／OSX／Windows等 是系统管理员和运维小伙伴不可或缺的必备模块 psutil.net_io_counters() # 获取网络读写字节／包的个数 获取的是累计数据量，因此需要前一秒减去后一秒，得到这一秒的数据量 电脑有很多网卡，我们只关心其中一个的话，需要加入参数net_io_counters(pernic=True) 返回的是字典类型，比如我们只要 ‘en0’ 这个网络接口的数据，则是net_io_counters(pernic=True)[‘en0’] 不过psutil需要走系统接口，因此需要权限，因此必须sudo 启动 代码123456789101112131415161718192021222324252627282930import psutilimport timefrom tkinter import *old_time = psutil.net_io_counters(pernic=True)['wlp7s0'].bytes_recv # 记录上次的数据量def update_bytes(): new_time = psutil.net_io_counters(pernic=True)['wlp7s0'].bytes_recv # 当前记录量 global old_time result = new_time-old_time old_time = new_time # 更新数据量 if result &gt; 1024*1024: byte.config(text=str(int(result/1024/1024)) + 'MB/s') elif result &gt; 1024: byte.config(text=str(int(result/1024)) + 'KB/s') else: byte.config(text=str(result) + 'B/s') # 通过config 更改属性 byte.after(1000, update_bytes) # 设置一秒后一直函数，则语句每次调用，实现了一秒一次调用window = Tk()byte = Label(text='0', font=('Hack', 25, 'bold'))byte.pack()byte.after(1000, update_bytes)# 定时器，单位为 毫秒window.geometry('180x30')window.mainloop() 特殊情况如果 after 中的函数想要带有形式参数，但规定是不能加上括号 1after(1000, lambda:update_bytes(a)) 能够运行脚本的工具原理 展示有哪些脚本，直接用listbox存储，展示 运行，停止脚本 python中有个库runpy 运行py脚本 自己运行自己run_path(‘copy.py’) 运行指定py文件 如果直接执行该函数，会导致自身程序无法正常运行 即 程序按 顺序执行，弹出的新窗口，新窗口是一个无限循环(mainloop) 的程序 导致 自身程序被卡死在 run_path() 这句号 需要用到多进程 from multiprocessing import Process 每个进程都要自己的ID即pid 大坑在网上搜了一下，说是由于两个线程抢占GUI资源导致的，去除其中一个线程中的控件句柄，说白了就是只能有一个线程来画界面。 如果你选中的脚本也是需要绘制图形界面的话，就会出现下面的错误 1234567XIO: fatal IO error 11 (Resource temporarily unavailable) on X server ":0" after 6014 requests (6014 known processed) with 0 events remaining.[xcb] Unknown sequence number while processing queue[xcb] Most likely this is a multi-threaded client and XInitThreads has not been called[xcb] Aborting, sorry about that.python3: ../../src/xcb_io.c:259: poll_for_event: Assertion `!xcb_xlib_threads_sequence_lost' failed.已放弃 (核心已转储) 只能有一个线程来画界面 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from runpy import run_pathfrom tkinter import *from tkinter.filedialog import *from multiprocessing import Processimport multiprocessing# run_path('copy.py') 运行指定py文件# 如果直接执行该函数，会导致自身程序无法正常运行path_pys = []def run_path_py(): for py in path_pys: print(py) p = multiprocessing.Process(name='my_process',target = lambda:run_path(py )) # 创建进程 # target 应该是个函数，这里不想再新写函数，所以用了lambda表达式 p.start() passdef end_path_py(): for proce in multiprocessing.active_children(): # 获取运行进程的列表 if proce.name == 'my_process': proce.terminate() window.children['listbox'].delete(0, END) passdef add_path_py(): file_names = askopenfilenames() lbox = window.children['listbox'] for name in file_names: if name.split('/')[-1].endswith('py') and not name.split('/')[-1] in path_pys: lbox.insert(END, name.split('/')[-1]) print(name) path_pys.append(name) passdef make_window(): window = Tk() Label(text='运行脚本') Listbox(window, name='listbox', bg='#f2f2f2',font=('Hack', 15)).pack() Button(window, text='添加', command=add_path_py).pack() Button(window, text='运行', command=run_path_py).pack() Button(window, text='结束', command=end_path_py).pack() return windowwindow = make_window()window.mainloop()]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法训练板子]]></title>
    <url>%2F2018%2F01%2F26%2F%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目1正题经过了选号和漫长的等待，处女座终于拿到了给小姐姐定制的手环，小姐姐看到以后直呼666！ 处女座其实也挺喜欢6这个数字的，实际上他做手环的时候选取的k=6。所以他对于包含数码6的数字极其敏感。每次看到像4567这样的数字的时候他的心就像触电了一样，想起了小姐姐。 现在你要给处女座展示一系列数字，你想知道他的内心会激动多少次。对于同一个数字，他最多只会激动一次，即如果这个数是66666，他还是只会激动一次。 输入描述:一行包括两个数字l,r，表示你给处女座展示的数字范围为[l,r]。输出描述:一行一个整数，表示处女座内心激动的次数。 示例1输入10 20输出1 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;typedef long long LL;LL l,r;bool check(LL x)&#123; while(x&gt;0)&#123; if(x%10==6) return true; x/=10; &#125; return false;&#125;LL solve(LL x)&#123; if(x&lt;=0) return 0; int cnt=0; for(LL i=x/10*10;i&lt;=x;i++) if(check(i)) cnt++; return solve(x/10-1)*9+cnt+x/10;&#125;int main()&#123; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;solve(r)-solve(l-1);&#125; 题目2正题处女座放完了”高利贷”，拿到了不少的资金，又可以和小姐姐约会啦！（之前不还是攒钱打比赛的吗）现在处女座拿到了一份宁波市旅游地图决定和小姐姐一起去玩耍。他们来到了动物园，去参观里面的动物。但是很不幸的是，他们在游玩的途中遇到了一只恶龙。 恶龙长有n个头，但经过了处女座的调教，恶龙变得善良了一些。它的n个头每个头要么仍是邪恶的头，用“1”表示，要么已经变得善良，用“0”表示，因而恶龙的n个头就可以用n位01串来表示。而此时处女座要发挥自己的勇士形象，要把所有的龙头都变成0000⋯000000⋯00完全善良的龙头。每一次，他可以砍掉龙最右侧的一个头，同时龙会在最左侧长出新的一个头，以保证龙头数量不变。如果他砍掉的是一个1，即邪恶的头，他可以决定龙在最左侧会长出什么样的头；但如果他砍掉了一个善良的头，那么玻璃心的恶龙将会在左侧不受控制的长出一个随机的头，既可能是善良的头，也可能是邪恶的头，而且它总会与处女座作对，尽力的破坏他的计划。 现在给你一个恶龙头的初始状态，即一个01串，请帮助处女座判断一下，能否在有限步之内让全部的龙头都变成善良的龙头。输入描述:输入第一行T，表示用例组数。 之后T行，每行一个01串S表示龙头的初始状态，“0”表示善良的头，“1”表示邪恶的头。 输出描述:对于每组数据，处女座能否将全部的龙头变成善良的头，可以的话输出“cnznb”，不可以则输出“ljcnz”（不含引号）。示例1输入11111输出cnznb 1234567#include&lt;cstdio&gt;int main()&#123; int t;scanf("%d",&amp;t); while(t--) puts("cnznb");&#125; 题目3正题处女座靠着自己的家教本领赚够了去比赛的钱，于是开启了疯狂训练。在每个夜深人静第二天不收作业的夜晚，他都会开始刷题。 “今日又是一个刷题的夜晚。”他挑选了n道题开始刷，而题太多，刷不掉，理还乱（呜呜）、自己没有解决的题目每分钟都会给他带来bibi的疲倦值，而解决每一道题目都需要花费aiai分钟的时间。 当然，处女座一般都是考虑清楚了再写题的，所以他在写题的时候都会精神抖擞，也就是说，当前正在写的那一题并不会给他带来任何疲劳。 为了迎接后天要收的作业和明天要遇到的小姐姐，他想让今晚的刷题尽可能的轻松，那请你帮他找出最小所需要的疲倦值吧。 输入描述:输入数据共包括n+1行，第一行包括一个n表示处女座今晚打算训练的题的数量。 接下来n行，每行包括两个整数ai,bi，分别表示处女座刷掉本题要花费的时间和本题每分钟会带来的疲倦值。输出描述:一行包括一个整数，表示处女座今晚训练会产生的最小疲倦值。示例1输入66 14 54 36 28 12 6输出86 说明先做第6个题，增加（1+5+3+2+1）*2= 24 点疲倦值，再做第2个题，增加28点疲倦值，随后依次是第3,4,1,5道题，增加16,12,6点疲倦值。总共的疲倦值是24 + 28 + 16 + 12 + 6 = 86点。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; typedef long long ll; ll c;struct A &#123; ll a,b; bool operator&lt;(A t)&#123; return a*t.b&lt;b*t.a; &#125; A()&#123; cin&gt;&gt;a&gt;&gt;b;c+=b; &#125;&#125;; int main()&#123; c=0; ll n,m=0;cin&gt;&gt;n;A da[n]; sort(da,da+n); for(int i=0;i&lt;n;++i)&#123; m+=(c-da[i].b)*da[i].a; c-=da[i].b; &#125; cout&lt;&lt;m;&#125; 题目4输入描述输入描述:仅一行三个整数 f1,f2,a,分别表示两只手产生的力的大小以及它们之间的夹角。输出描述:输出一个实数表示两力合力的大小，要求相对误差或绝对误差不超过 10^−6 示例1输入6 8 90 输出10.0000000000 示例2输入10 10 60 输出17.3205080757 代码12345678910111213#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define PI 3.14159265using namespace std;int main()&#123; int f1, f2; int r; cin &gt;&gt; f1 &gt;&gt; f2 &gt;&gt; r; double r1 = cos(r * PI / 180.0 ); printf("%.10lf", sqrt(f1*f1*1.0 + f2*f2*1.0 + 2*f1*f2*r1)); return 0;&#125; 题目4题目描述Applese 和 Bpplese 在玩取石子游戏，规则如下： 一共有偶数堆石子排成一排，每堆石子的个数为 ai。两个人轮流取石子，Applese先手。每次取石子只能取最左一堆或最右一堆，且必须取完。最后取得的石子多者获胜。假设双方都足够聪明，最后谁能够获胜呢？ 【输入描述】第一行是一个正偶数 n，表示石子的堆数。第二行是 n 个正整数 a1,a2,…,an，表示每堆石子的个数。 2≤n≤10^51≤ai≤10^5∑ai 为奇数 输出描述输出一个字符串“Applese”或“Bpplese”，表示胜者的名字。 样例示例1 输入42 3 3 3输出Applese 思路思路：博弈 由于堆数 n 是偶数，那么先手方有必胜策略：选择所有的奇数项或者偶数项 先手方首先比较奇数项之和和偶数项之和，由于石子总数是奇数，那么一定不相等，因此有： 1）若奇数项之和比较大，那么先手就取第一项，剩下的序列首尾都是偶数项，后手就只能取偶数项，然后又剥离出一个奇数项，接着被先手取走，剩下的首尾又是偶数项，以此类推，先手就能取到所有的奇数项，后手只能取到所有的偶数项，那么先手获胜 2）若偶数项之和比较大，那么先手就取最后一项，剩下的序列首尾都是奇数项，后手就只能取奇数项，然后又剥离出一个偶数项，接着被先手取走，剩下的首尾又是奇数项，以此类推，先手就能取到所有的偶数项，后手只能取到所有的奇数项，那么先手获胜 故而直接输出 Applese 即可 题目5题干：小希最近想知道一个东西，就是A+B=A|B(其中|为按位或)的二元组有多少个。 当然，直接做这个式子对小希来说太难了，所以小希改变了一些条件，她仅想知道其中A,B&lt;NA,B&lt;N的情况，其中N为2的幂次。 当然，(A=1,B=0)和(A=0,B=1)被认为是不同的二元组。 输入描述:第一行输入一个非负整数M。 N=2^M,M≤100 即2的M次为N。 输出描述:一个整数ans，对998244353取模。 示例1输入0 输出1 示例2输入71 输出588378066 解题报告：写个暴力打表发现，答案就是3^m。 一个题解： 很显然a+b=a|b等式成立的条件是a和b的二进制表示中，在同一位不能全为1假设现在a+b=a|b，a和b是已知的，且a,b写成二进制均为n-1位数（可含前导零）。那么现在把a,b添加一位数，变成n位数（显然n位数都能从n-1位变过来），如果等式仍要成立的话，那么只有3种情况 a后添0，b后添0a后添0，b后添1a后添1，b后添0也就是说从n-1位数变为n位数，组合的方法数变为原来的3倍，且n=0时答案为1显然。 1234初始情况下都为0位，AB都为0，则答案 ans=1如果 添加1位，那么AB组合增加3种方式(A+0 B+0, A+0 B+1, A+1 B+0)，则为 1*3以此类推，可以得出最终答案 ans = 3^m 我的题解：其实拆成含有前导零的m位数，考虑每一位，只有分别在(0,0)(0,1)(1,0)的三种情况时满足条件，根据乘法原理，得到答案。 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;#define ll long longconst ll mod = 998244353;ll qpow(ll a, ll k) &#123; ll res = 1; while(k) &#123; if(k&amp;1) res = (a*res)%mod; k&gt;&gt;=1; a = (a*a)%mod; &#125; return res;&#125;int main()&#123; int m; cin&gt;&gt;m; cout &lt;&lt; (qpow(3,m)); return 0 ;&#125; 题目6题目描述小希希望你构造一个最小的正整数，使得其有n个因子。输入描述:第一行一个整数T表示数据组数 每组数据第一行输入一个正整数n，表示其因子数。 n≤1,000,000 T≤1,000,000 输出描述:输出一行一个整数，表示你构造出的这个数。注意：你需要保证你构造的数≤1,000,000，如果在这个范围里面无法构造出一个正整数满足条件，请输出-1。 示例1输入245 输出616 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int main()&#123; int min_num[maxn],num[maxn]=&#123;0&#125;;//min_num[n]记录因子数为 n的最小数 fill(min_num,min_num+maxn,INT_MAX);//num[i]记录 i的因子数 for(int i=1;i&lt;=1000000;i++) &#123; for(int j=i;j&lt;=1000000;j+=i) &#123; //j=i,2i,3i,4i... num[j]++; //j都含有因子 i，所以 num[j]++ &#125; &#125; for(int i=1;i&lt;=1000000;i++) &#123; //再次从1遍历到1000000 if(min_num[num[i]]==INT_MAX) //这样得到的一定是最小数 min_num[num[i]]=i; &#125; int T; scanf("%d",&amp;T); while(T--) &#123; int n; scanf("%d",&amp;n); if(min_num[n]==INT_MAX) printf("-1\n"); else printf("%d\n",min_num[n]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2018%2F01%2F08%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫的实际例子：1. 搜索引擎（百度、谷歌、360搜索等）。 2. 伯乐在线。 3. 惠惠购物助手。 4. 数据分析与研究（数据冰山知乎专栏）。 5. 抢票软件等。 什么是网络爬虫：通俗理解爬虫是一个模拟人类请求网站行为的程序。可以自动请求网页、并数据抓取下来 然后使用一定的规则提取有价值的数据。 专业介绍：百度百科。 通用爬虫和聚焦爬虫： 通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。 主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。 聚焦爬虫：是面向特定需求的一种网络爬虫程序,他与通用爬虫的区别在于： 聚焦爬虫在实施网页抓取的时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。 request和response头中信息 Accept:文文本的格式 Accept-Encoding:编码格式 Connection:⻓长链接 短链接 Cookie:验证用用的 Host:域名 Referer:标志从哪个⻚页面面跳转过来的 User-Agent:浏览器器和用用户的信息 为什么用Python写爬虫程序：PHP：PHP是世界是最好的语言，但他天生不是做这个的 而且对多线程、异步支持不是很好，并发处理能力弱。爬虫是工具性程序，对速度和效率要求比较高。 Java：生态圈很完善，是Python爬虫最大的竞争对手。 但是Java语言本身很笨重，代码量很大。重构成本比较高，任何修改会导致代码大量改动。爬虫经常要修改采集代码。 C/C++：运行效率是无敌的。但是学习和开发成本高。写个小爬虫程序可能要大半天时间。 Python：语法优美、代码简洁、开发效率高、支持的模块多。 相关的HTTP请求模块和HTML解析模块非常丰富。还有Scrapy和Scrapy-redis框架让我们开发爬虫变得异常简单。 准备工具：Python3.6开发环境。 Pycharm 2017 professional版。 虚拟环境。`virtualenv/virtualenvwrapper`。 http协议和Chrome抓包工具什么是http和https协议：HTTP协议：全称是HyperText Transfer Protocol，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是80端口。 HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是443端口。 在浏览器中发送一个http请求的过程：当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。 当我们在浏览器输入URL http://www.baidu.com 的时候，浏览器发送一个Request请求去获取 http://www.baidu.com 的html文件，服务器把Response文件对象发送回给浏览器。 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。 当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。 url详解：URL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成： scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。 常用的请求方法：在Http协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是get请求和post请求。 get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用get请求。 post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。 以上是在网站开发中常用的两种方法。 并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌， 有可能一个应该使用get方法的请求就一定要改成post请求，这个要视情况而定。 请求头常见参数：在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在body中（在post请求中），第三个就是把数据放在head中。 这里介绍在网络爬虫中经常会用到的一些请求头参数： User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。 如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。 因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。 Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。 Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。 一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。 常见响应状态码：200：请求正常，服务器正常的返回数据。 301：永久重定向。比如在访问www.jingdong.com的时候会重定向到www.jd.com。 302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。 400：请求的url在服务器上找不到。换句话说就是请求url错误。 403：服务器拒绝访问，权限不够。 500：服务器内部错误。可能是服务器出现bug了。 Chrome抓包工具： Chrome浏览器Chrome浏览器是一个非常亲近开发者的浏览器。可以方便的查看网络请求以及发送的参数。 对着网页右键-&gt;检查。然后就可以打开开发者选项。以下用图片来说明。 urllib库urllib库是Python中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。 urlopen函数：在Python3的urllib库中，所有和网络请求相关的方法，都被集到urllib.request模块下面了，以先来看下urlopen函数基本的使用： from urllib import request resp = request.urlopen(&apos;http://www.baidu.com&apos;) print(resp.read()) 实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。 也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。 以下对urlopen函数的进行详细讲解：url：请求的url。 data：请求的data，如果设置了这个值，那么将变成post请求。 返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。 urlretrieve函数：1234这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：from urllib import requestrequest.urlretrieve('http://www.baidu.com/','baidu.html') urlencode函数：12345678用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据。示例代码如下：from urllib import parsedata = &#123;'name':'爬虫基础','greet':'hello world','age':100&#125;qs = parse.urlencode(data)print(qs) parse_qs函数：1234567891011121314151617181920可以将经过编码后的url参数进行解码。示例代码如下：from urllib import parseqs = "name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100"print(parse.parse_qs(qs))urlparse和urlsplit：有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用urlparse或者是urlsplit来进行分割。示例代码如下：from urllib import request,parseurl = 'http://www.baidu.com/s?username=zhiliao'result = parse.urlsplit(url)# result = parse.urlparse(url)print('scheme:',result.scheme)print('netloc:',result.netloc)print('path:',result.path)print('query:',result.query) urlparse和urlspliturlparse和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。 比如有一个url为：url = &apos;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&apos;， 那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。 urllib库请求get 汉字报错 :解释器器ascii没有汉字 url汉字转码urllib.parse.quote safe=”string.printtable” 字典传参urllib.parse.urlencode() post: urlib.request.openurl(url,data = “服务器器接受的数据”) handler:处理理器器的自自定义: User-Agent:在浏览网页的时候，爬虫的浏览速度明显超过人的点击速度，所以速度过快会触发反扒。 这个时候，我们可以通过自定义User-Agent，模拟出不同的用户在浏览网页，在一定机制上可以防止反扒机制 模拟真实的浏览器器发送请求: 百度批量量搜索 检查元素(百度搜索useragent大大全) request.add_header(动态添加head数据) 响应头 response.header 创建request:urlib.request.Request(url) IP代理理: 免费的IP:时效性差,错误率高高 付费的IP:贵花钱,也有失效不不能用用的 IP分类: 透明:对方方知道我们真实的ip 匿名:对方方不不知道我们真实的ip,知道了了你使用用了了代理理 高匿:对方方不不知道我们真实的IP.也不不知道我们使用用了了代理理 handler:系统的urlopen()不不支支持代理理的添加创建对应的处理器(handler) 代理理处理理器器:ProxyHandler 拿着ProxyHandler创建opener:bulid_opener() opener.open(url)就可以请求数据 auth认证handlerCookieshandlerURLErrorrequests(第三方方模块):简单易易用用数据解析:数据存储:json csv MongDB resdis mysql urllib库实战使用百度搜索信息，返回查询的网页1234567891011121314151617import urllib.parseimport stringimport urlllibdef getHttp(url): baidu_url = 'http://www.baidu.com/s?wd=' fin_url = baidu_url + url # 由于用户输入的信息可能是中文，所以需要转码为ASCII码等python可以解释的编码 fin_code_url = urllib.parse.quote(fin_url, safe=string.printable) r = urllib.request.urlopen(fin_code_url) # r.read() 可能返回的是bytes数据，而不是字符串数据，因此存储为utf-8需要decode一下 with open('baidu.html', 'w', encoding='utf-8') as f: f.write(r.read().decode())url = input()# url 存储输入的信息，代表用户想要查询的数据getHttp(url) get请求1234567891011121314def get_params(): baidu_url = 'http://www.baidu.com/s?' # 如果发送get请求，那么请求参数就在请求链接中，通过字典的方式来设置请求参数 diction = &#123; "wd":"中文", "key":"zhang", "value":"san" &#125; # 把字典转换为字符串，然后用于字符串拼接，同时可以把中文转换为ASCII便于Python解释 str_params = urllib.parse.urlencode(diction); fin_url = baidu_url+str_params r = urllib.request.urlopen(fin_url) with open('index.html', 'w', encoding='utf-8') as f: f.write(r.read().decode()) 添加响应头信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788常见的User-Agent：OperaMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60Opera/8.0 (Windows NT 5.1; U; en)Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50 FirefoxMozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10 SafariMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 chromeMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16 360Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko 淘宝浏览器Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11 猎豹浏览器Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSERMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER) Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)"QQ浏览器Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)sogou浏览器Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)maxthon浏览器Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36UC浏览器Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36IPhoneMozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5 IPodMozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5 IPADMozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5 AndroidMozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 QQ浏览器 Android版本MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 Android Opera MobileOpera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10 Android Pad Moto XoomMozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13 BlackBerryMozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+ WebOS HP TouchpadMozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0 Nokia N97Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124 Windows Phone MangoMozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan) UC浏览器UCWEB7.0.2.37/28/999 NOKIA5700/ UCWEB7.0.2.37/28/999 UCOpenwaveOpenwave/ UCWEB7.0.2.37/28/999 UC OperaMozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999 123456789101112131415161718192021222324252627def load_baidu(): url = "https://www.baidu.com/s?" header = &#123; "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36", &#125; #创建请求对象 request = urllib.request.Request(url) #获取请求头的信息，因为没有设置值，所以为空 print(request.headers) # 添加请求头信息 #方法1 request = urllib.request.Request(url, headers=header) #方法2 动态添加，通过创建user-agent来随机的创建出请求头，以迷惑服务器的反扒机制 request.add_header("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"); #response = urllib.request.urlopen(url) 也可以，但是我们可以通过这是请求对象的方式来设置一下请求参数 respon = urllib.request.urlopen(request) #查看响应头 print(respon.headers) with open("index.html", 'w', encoding='utf-8') as f: f.write(respon.read().decode()) urllib中的proxy代理12345678910111213141516171819202122232425262728def handler_openner(): url = "https://www.baidu.com" #handler 处理器 #系统的urlopen 并没有添加 代理的功能 # handler = urllib.request.HTTPHandler()#创建处理器 #添加代理 proxy = &#123; #免费代理的写法 "http":"http://121.61.1.129:9999" #付费代理的写法 #"http":"用户名":密码 &#125; #可以使用list来设置随机代理，防止反扒 proxys = [ &#123;"http","1.192.240.196:9999"&#125;, &#123;"http","125.123.141.52:9999"&#125;, &#123;"http","119.101.125.128:9999"&#125;, &#123;"http","119.101.127.46:9999"&#125;, &#123;"http","121.61.3.143:9999"&#125; ] # 代理的处理器 proxy_handler = urllib.request.ProxyHandler(proxy) # opener = urllib.request.build_opener(handler)#通过处理器创建自己的opener opener = urllib.request.build_opener(proxy_handler)#通过代理器创建自己的opener #通过查看 urllib.request.urlopen()函数可以发现，python网络连接就是通过opener的open函数 #通过有代理的opener来执行网络连接 data = opener.open(url).read(); print(data) urllib中使用cookie的两种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import urllib.parseimport urllib.requestfrom http import cookiejardef use_cookie(): # 使用cookie的第一种方法，直接从浏览器中复制粘贴已有的cookie headers1 = &#123; "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36", "Cookie":"BAIDUID=670AE50017189CEE98CF4241E77CF222:FG=1; BIDUPSID=670AE50012; PSTM=1542866664; BDUSS=GJ2d0NyU2FxSzUxT1B-Njdzc0puOWVjbVFqWHFwMHBKbWZuanpqRHRIYlB6RDVjQVFBQUFBJCQAAAAAAAAAAAEAAADZlxkqc21hbGy~wsTPv9gAAAAAAAAAAAM8~F1zPPxdcU; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; H_PS_PSSID=1433_21126_18560_28329_26350_28414_27543" &#125; url = "https://www.baidu.com" request = urllib.request.Request(url, headers=headers1)#将url和header导入到request对象中 #request.add_header("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36") 或者随后动态导入header respon = urllib.request.urlopen(request) data = respon.read().decode('utf-8') print(data)def save_cookie(): # 第二种方法，利用登录界面存储cookie cookies = cookiejar.CookieJar() login_url = "https://passport.bilibili.com/login" headers2 = &#123; "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36" &#125;#这里用代码实现存储cookie，所以头里面不需要cookie #从 浏览器中 可以知道 登录是POST 请求，同时在浏览器工具中可以发现 名为“Form Data”的项目 form_data_nodecode = &#123; # 获取登录信息，首先你要自己先登录一次，这样才能找到登录时应该发送哪些信息 "oauthKey": "f58e34d07074", "gourl": "https://www.bilibili.com/" #是通过浏览器 检查 找到的 表单信息 &#125;# 千万注意 把form_data转换一下，因为不能发送字典请求，需要转换为字符串，再转换成bytes，因为post请求只接受bytes form_data = urllib.parse.urlencode(form_data_nodecode).encode('utf-8') # 可以通过查找规律，找到form_data的信息规律 # 定义又添加cookie功能的处理器 cookie_handler = urllib.request.HTTPCookieProcessor(cookies) #根据处理器生成opener opener = urllib.request.build_opener(cookie_handler) # 生成request对象，设置请求头和链接 login_request = urllib.request.Request(login_url, headers=headers2, data=form_data) #发送请求，登录成功则会 把cookie保存到 cookiejar中 opener.open(login_request) #访问个人中心 url = "https://account.bilibili.com/account/face/upload" person_request = urllib.request.Request(url, headers=headers2) respons = opener.open(person_request) # bytes-&gt;str data = respons.read().decode('utf-8') print(data) request.Request类：12345678910如果想要在请求的时候增加一些请求头，那么就必须使用request.Request类来实现。比如要增加一个User-Agent，示例代码如下：from urllib import requestheaders = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'&#125;req = request.Request("http://www.baidu.com/",headers=headers)resp = request.urlopen(req)print(resp.read()) ProxyHandler处理器（代理设置）12345678910111213141516很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：from urllib import request# 这个是没有使用代理的# resp = request.urlopen('http://httpbin.org/get')# print(resp.read().decode("utf-8"))# 这个是使用了代理的handler = request.ProxyHandler(&#123;"http":"218.66.161.88:31769"&#125;)opener = request.build_opener(handler)req = request.Request("http://httpbin.org/ip")resp = opener.open(req)print(resp.read()) 常用的代理有：西刺免费代理IP：http://www.xicidaili.com/ 快代理：http://www.kuaidaili.com/ 代理云：http://www.dailiyun.com/ 什么是cookie：在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。 cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地， 当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。 cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。 cookie的格式：Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE 参数意义： NAME：cookie的名字。 VALUE：cookie的值。 Expires：cookie的过期时间。 Path：cookie作用的路径。 Domain：cookie作用的域名。 SECURE：是否只在https协议下起作用。 使用cookielib库和HTTPCookieProcessor模拟登录：12345678910111213141516171819Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：from urllib import requestheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', 'Cookie': 'anonymid=jacdwz2x-8bjldx; depoe=GW; _r01_=1; _ga=GA1.2.14516.1511436360; _gid=GA1.2.862627163.1511436360; wp=1; JSESID=abczwY8ecd4xz8RJcyP-v; jebecookies=d4497791-9d41-4269-9e2b-3858d4989785|||||; ick_login=884e75d4-f361-4cff-94bb-81fe6c42b220; _de=EA5778F44555C096BF75400CE19CC; p=61a3c7d0d4b2d1e991095353f83fa2141; first_login_flag=1; ln_uact=970138074@qq.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn121/20170428/1700/main_nhiB_aebd0000854a1986.jpg; t=3dd84a3117737e819dd2c32f1cdb91d01; societyguester=3dd84a3117737e819dd2c32f1cdb91d01; id=443362311; xnsid=169efdc0; loginfrom=syshome; ch_id=10016; jebe_key=9c062f5a-4335-4a91-bf7a-970f8b86a64e%7Ca022c303305d1b2ald=0'&#125;url = 'http://www.renren.com/880151247/profile'req = request.Request(url,headers=headers)resp = request.urlopen(req)with open('renren.html','w') as fp: fp.write(resp.read().decode('utf-8'))但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储cookie的对象。而HTTPCookieProcessor处理器主要作用是处理这些cookie对象，并构建handler对象。 http.cookiejar模块：1234567891011121314151617181920212223242526272829303132333435363738394041该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。登录人人网：利用http.cookiejar和request.HTTPCookieProcessor登录人人网。相关示例代码如下：from urllib import request,parsefrom http.cookiejar import CookieJarheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'&#125;def get_opener(): cookiejar = CookieJar() handler = request.HTTPCookieProcessor(cookiejar) opener = request.build_opener(handler) return openerdef login_renren(opener): data = &#123;"email": "970138074@qq.com", "password": "pythonspider"&#125; data = parse.urlencode(data).encode('utf-8') login_url = "http://www.renren.com/PLogin.do" req = request.Request(login_url, headers=headers, data=data) opener.open(req)def visit_profile(opener): url = 'http://www.renren.com/880151247/profile' req = request.Request(url,headers=headers) resp = opener.open(req) with open('renren.html','w') as fp: fp.write(resp.read().decode("utf-8"))if __name__ == '__main__': opener = get_opener() login_renren(opener) visit_profile(opener) 保存cookie到本地：1234567891011121314151617保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名：from urllib import requestfrom http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar("cookie.txt")handler = request.HTTPCookieProcessor(cookiejar)opener = request.build_opener(handler)headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'&#125;req = request.Request('http://httpbin.org/cookies',headers=headers)resp = opener.open(req)print(resp.read())cookiejar.save(ignore_discard=True,ignore_expires=True) 从本地加载cookie：1234567891011121314151617从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法：from urllib import requestfrom http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar("cookie.txt")cookiejar.load(ignore_expires=True,ignore_discard=True)handler = request.HTTPCookieProcessor(cookiejar)opener = request.build_opener(handler)headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'&#125;req = request.Request('http://httpbin.org/cookies',headers=headers)resp = opener.open(req)print(resp.read()) requests库虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。 安装和文档地址：12345利用pip可以非常方便的安装：pip install requests中文文档：http://docs.python-requests.org/zh_CN/latest/index.htmlgithub地址：https://github.com/requests/requests 发送GET请求：最简单的发送get请求就是通过requests.get来调用： response = requests.get(&quot;http://www.baidu.com/&quot;) 添加headers和查询参数：12345678910111213141516171819202122232425如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下： import requests kw = &#123;'wd':'中国'&#125; headers = &#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36"&#125; # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode() response = requests.get("http://www.baidu.com/s", params = kw, headers = headers) # 查看响应内容，response.text 返回的是Unicode格式的数据 print(response.text) # 查看响应内容，response.content返回的字节流数据 print(response.content) # 查看完整url地址 print(response.url) # 查看响应头部字符编码 print(response.encoding) # 查看响应码 print(response.status_code) 发送POST请求：123最基本的POST请求可以使用post方法：response = requests.post("http://www.baidu.com/",data=data) 传入data数据：1234567891011121314151617181920这时候就不要再使用urlencode进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码： import requests url = "https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0" headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', 'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=' &#125; data = &#123; 'first': 'true', 'pn': 1, 'kd': 'python' &#125; resp = requests.post(url,headers=headers,data=data) # 如果是json数据，直接可以调用json方法 print(resp.json()) 使用代理：1234567891011121314151617使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。示例代码如下：import requestsurl = "http://httpbin.org/get"headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',&#125;proxy = &#123; 'http': '171.14.209.180:27829'&#125;resp = requests.get(url,headers=headers,proxies=proxy)with open('xx.html','w',encoding='utf-8') as fp: fp.write(resp.text) cookie：1234567891011121314151617181920212223242526272829303132如果在一个响应中包含了cookie，那么可以利用cookies属性拿到这个返回的cookie值：import requestsurl = "http://www.renren.com/PLogin.do"data = &#123;"email":"*****4@qq.com",'password':"p****spider"&#125;resp = requests.get('http://www.baidu.com/')print(resp.cookies)print(resp.cookies.get_dict())cookies = 'BAIDUID=67017189CEE98CF4241E77CF222:FG=1; BIDUPSID=670AE50017189CEE98CF4241E77CF222; PSTM=1542866664; BDORZ=B490B5EBF6F3CD402E512BCDA1598; pgv_pvi=6780275712; delPer=0; H_PS_PSSID=1433_21126_18560_28350_28414_27543; BDUSS=0RkcTNETTczdElRUUZBaVNLWjN2VZcy00Z2g2S2FWdjFGcWVoRVB2M2hjQVFBQUFBJCQAAAAAAAAAAAEAAADZlxkqc21hbGy~wsTPv9gAAAAAAAAAAAAAA8yUVwPMlFcd'# 手动将 cookies 转换成 dict 字典# cook_dict = &#123;# 'BAIDUID':'670AE50017189CE241E77CF222:FG=1',# 'BIDUPSID':'670AE50017189CF4241E77CF222',# 'PSTM':'154264',# 'BDORZ':'B490B5EBF6F3CD402E51A1598',# 'pgv_pvi':'6780275712',# 'delPer':'0',# 'H_PS_PSSID':'1433_0_28329_26350_28414_27543',# 'BDUSS':'0RkcTNETTczdElRUUZBaVNLWjZQd2VNN2VZcy00Z2g2S2FWdjFGcWVoRVB2M2hjQVFBQUFBJCQAAAAAAAAAAAEAAADZlxkqc21hbGy~wsTPv9gAAAAAAAAA8yUVwPMlFcd# &#125;#或者代码转换cookie_dict = &#123;&#125;cookie_list = cookies.split(';')for cookie int cookie_list: cook_dict[cookie.split('=')[0]] = cookie.split('=')[1]response = requests.get(url, headers=headers, cookies=cook_dict) session：123456789101112131415161718192021之前使用urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。那么如果使用requests，也要达到共享cookie的目的，那么可以使用requests库给我们提供的session对象。注意，这里的session不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用requests来实现。示例代码如下：import requestsurl = "http://www.renren.com/PLogin.do"data = &#123;"email":"970138074@qq.com",'password':"pythonspider"&#125;headers = &#123; 'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"&#125;# 登录session = requests.session()session.post(url,data=data,headers=headers)# 访问大鹏个人中心resp = session.get('http://www.renren.com/880151247/profile')print(resp.text) 处理不信任的SSL证书：1234对于那些已经被信任的SSL整数的网站，比如https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下：resp = requests.get('http://www.12306.cn/mormhweb/',verify=False)print(resp.content.decode('utf-8')) 对于不被SSL信任的网站则会抛出异常错误 12345678910111213import requestsdef requests_ssl(): url = 'https://sso.ctgu.edu.cn:7002/cas/login?service=http://210.42.35.80/G2S/ShowSystem/CA.aspx' headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36' &#125; response = requests.get(url=url, headers=headers) data = response.content.decode('utf-8') print(data)requests_ssl()# 抛出 requests.exceptions.SSLError 异常， 就是SSL认证错误 解决方式是告诉 web 忽略证书访问 1response = requests.get(url=url, headers=headers, verify=False) requests的使用例子基础例子1234567891011121314151617181920212223242526272829303132333435363738import requestsclass RequestSpider(object): def __init__(self): url = 'http://www.baidu.com' headers1 = &#123; "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36" &#125; self.response = requests.get(url, headers=headers1) def run(self): data = self.response.content #获取返回体 #获取请求头 request_header = self.response.request.headers print(request_header) #获取响应头 response_header = self.response.headers print(response_header) #响应状态码 response_code = self.response.status_code print(response_code) #请求的cookie request_cookie = self.response.request._cookies #低版本的requests是 request_cookie = self.response.request.cookies print(request_cookie) #响应的cookie response_cookie = self.response.cookies print(response_cookie) #json()自动将json字符串转换为 python的 列表或字典 dta = self.response.json()RequestSpider().run() python的正则表达式正则规则12#导入python自带的正则库import re 项目 价格 \ 将下一个字符标记为特殊字符，或一个原义字符，或一个向后引用，或一个八进制转义符 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配’\n’或’\r’之后的位置 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，^也匹配’\n’或’\r’之前的位置 * 匹配前面的子表达式0次或多次。例如 ‘zo*’ 可以 匹配 ‘z’ ‘zo’ ‘zoo’ 等 + 匹配前面的子表达式一次或多次。例如 ‘zo+’ 能匹配 ‘zo’ ‘zoo’ 等 不能匹配 ‘z’ ? 匹配前面的子表达式0次或一次。例如 ‘zo(es)?’ 匹配 ‘zoed’ 或 ‘zo’ {n} n是一个非负整数。匹配确定的n次。例如’o{2}’ 能够匹配 ‘food’ 不能匹配 ‘bob’ {n,} n是一个非负整数。匹配至少n次，无上限。例如’o{2,}’ 能够匹配 ‘food’ ‘dooof’ 不能匹配’Bob’ {n,m} n，m是非负整数。匹配至少n次，至多m次。例如’o{2,3}’能够匹配 ‘food’ ‘foood’ 不能’Bob’’boooob’ ? 当该字符紧跟在任何一个其他限制符(*,+,?,{n},{n,},{n,m})后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如：对于字符串’ooooo’，‘o+?’将匹配单个o，而’o+’匹配所有的‘o’ . 匹配除’\n’之外的任何一个单个字符。要匹配包括’\n’在内的任何字符，请使用想’(.\ \n)’的模式 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`( )”来组合一个模式的各个部分是很有用。例如“industr(?:y ies)”就是一个比“industry industries`”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95 98 NT 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95 98 NT 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95 98 NT 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows`”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95 98 NT 2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows`”。 **x\ y** 匹配x或y。例如，“`z food”能匹配“z”或“food”。“(z f)ood”则匹配“zood”或“food`”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 [xyz] 表示字符集，匹配所包含的任意字符，例如 [abc] 能匹配’a’,’b’,’c’ [a-z] 表示字符范围，能匹配范围内任意一个字符，例如 [a-b] 能匹配 a~z的字符，[1-9] 匹配1~9 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}\ [a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@(\da-z?)+(.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z.-]+).([a-z.]{2,6})([\/\w .-])\/?$/ IP 地址 /((2[0-4]\d\ 25[0-5]\ [01]?\d\d?).){3}(2[0-4]\d\ 25[0-5]\ [01]?\d\d?)/ /^(?:(?:25[0-5]\ 2[0-4][0-9]\ [01]?[0-9][0-9]?).){3}(?:25[0-5]\ 2[0-4][0-9]\ [01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;\/\1&gt;\ \s+\/&gt;)$/ 删除代码\注释 (?&lt;!http:\ \S)//.*$ Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/ python使用正则12345678910111213141516171819202122232425262728293031323334353637383940414243# 正则import re# 贪婪模式 从开头匹配到结尾one_str = 'mdfsdsfffdsn1234565n'pattern = re.compile('m(.)n')pattern1 = re.compile('m(.*)n')result = pattern.findall(one_str)result1 = pattern1.findall(one_str)print(result)#输出为空 因为 '.' 只能匹配一个print(result1)#输出为'dfsdsfffdsn1234565'# 默认的贪婪模式 会 尽可能多的匹配字符串 # 即使'mdfsdsfffdsn‘已经符合条件 # 逆贪婪模式就是 不是尽可能大的抓取而是尽可能小的pattern2 = re.compile('m(.*?)n')result2 = pattern2.findall(one_str)print(result2)# 输出的就是 'dfsdsfffds'# ' . '不能匹配 换行符 '\n' 但是又方法可以设置code = """ msfasdflksjdfkgsdn 123998657982345n 15226326345345N"""huanhang1 = re.compile('m(.*)n')huanhang2 = re.compile('m(.*)n', re.S)result_huanhang1 = huanhang1.findall(code)result_huanhang2 = huanhang2.findall(code)print(result_huanhang1)# 不能匹配换行的结果print(result_huanhang2)# 可以匹配换行的结果# re正则严格查询大小写，如果不想明确区分大小写，请加上re.I# 例如：daxiaoxie = re.compile('m(.*)n', re.S | re.I ) #既让 '.'匹配换行，同时不区分大小写 判断方法12345678910111213141516171819202122232425262728# 正则import reone_str = 'a1234'two_str = '1234a'pattern = re.compile('\d')# 匹配判断的方法# match 方法 是否匹配成功 从头开始 匹配一次就停止# 例子：这里需要判断字符串是不是纯数字result = pattern.match(one_str)result2 = pattern.match(two_str)print(result) # 输出为none，因为第一字字符是’a‘，所以直接输出为noneprint(result2.group())# 输出不为1，这个1就是 ’1234a‘ 中第一个字符’1‘# 很明显 字符串 ’1234a' 不能纯数字，所以这的判断是错的# 我们想判断 str 是否是纯数字，而不带其他字符，所以需要这样pattern2 = re.compile('\d+$') # 至少有一个数字，从开头到结尾，而且必须全部是 '\d' （数字）result3 = pattern2.match('1234a')result4 = pattern2.match('1234')print(result3) # 输出为none，因为字符串带有 字母'a' print(result4.group()) # 输出为 1234 完全匹配 常用方法1234567891011121314151617181920212223242526272829import reone = '123 abc'two = 'abc 123'patter = re.compile('\d+')patter2 = re.compile('\d+')# match 从头匹配 匹配一次result = patter.match(one)result2 = patter2.match(two)print(result)print(result2)# search 从任意位置匹配一次result3 = patter.search(one)result4 = patter2.search(one)print(result3)print(result4)# findall 查找符合正则的内容 返回的是listresult5 = patter.findall(one)result6 = patter2.findall(two)# sub 替换字符串 把匹配的字符换成目标字符result7 = patter.sub('#', one)result8 = patter2.sub('#', two)# split 拆分patter = re.compile(' ') # 以空格拆分result9 = patter.split(one) 正则匹配中文12345678910111213141516171819import re# python 中匹配中文two = '&lt;a href="http://news.baidu.com" target="_blank" class="mnav"&gt;新闻&lt;/a&gt;'# python 中匹配中文是有范围的 就是unicode 的 范围 \u4e00 ~ \u9fa5 # 这个范围是现在的范围，可能跟以前不一样，可能与以后不一样pattern = re.compile('[\u4e00-\u9fa5]')result = pattern.findall(two)print(result) # 返回列表 '新' '闻'# 很明显我们想要匹配出来的是 "新闻" 而不是 '新' '闻'pattern1 = re.compile('[\u4e00-\u9fa5]+')result1 = pattern1.findall(two)print(result1) # 输出新闻 爬取百度新闻12345678910111213141516171819202122232425262728import requestsimport re# 爬取 http://news.baidu.com/ 的 各个新闻的 链接def get_baidu_news(): url = 'http://news.baidu.com/' headers = &#123; 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' &#125; data = requests.get(url, headers = headers).content.decode('utf-8') # &lt;a href="http://www.xinhuanet.com/politics/leaders/2019-01/31/c_1124070520.htm" target="_blank" class="a3" mon="ct=1&amp;amp;a=1&amp;amp;c=top&amp;amp;pn=0"&gt;《求是》杂志发表习近平重要文章&lt;/a&gt; # 上述是 一个例子 # 观察例子 patt = '&lt;a href="(.+?)" target="_blank" (.*)&gt;(.*[\u4e00-\u9fa5]+)&lt;/a&gt;' pattern = re.compile(patt) result = pattern.findall(data) for i in result: # print(i[0] +' ' + i[len(i)-1]) with open('config.txt', 'a') as file: file.write(i[0]) file.write(' ') file.write(i[len(i)-1]) file.write('\n') # 在Python的面向对象机制下，这确实非常简单。需要注意的是，当你再次使用“w”方式在文件中写数据，所有原来的内容都会被删除。 # 如果想保留原来的内容，可以使用“a”方式在文件中结尾附加数据get_baidu_news() Xpath的使用 安装支持 解析html和xml的解析库 lxml pip install lxml 1from lxml import etree 如果想要使用Xpath 需要转解析类型（我们拿到的是字符串，转成xpath能进解析的类型） 12345678910111213import reimport requestsfrom lxml import etreeurl = 'http://news.baidu.com/'headers = &#123; 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&#125;data = requests.get(url, headers=headers).content.decode('utf-8')xpath_data = etree.HTML(data) 调用xpath的方法 12345result_text = xpath_data.xpath('//*[@id="pane-news"]/div/ul/li[1]/strong/a/text()')print(result_text) # 输出的就是 标签的text 节点内容result_url = xpath_data.xpath('//*[@id="pane-news"]/div/ul/li[1]/strong/a/@href')print(result_url) Xpath 的 数组 是 从1开始 而不是 从0开始 Xpath的使用规则 符号 意义 article 选取所有article元素的所有子节点 /article 选取根元素article article/a 选区所有属于article的子元素的a元素 //div 选取所有div子元素（不论出现在文档任何地方） article//div 选取所有属于article元素的后代的div元素，不管它出现在article之下的任何位置 //@class 选取所有名为class的属性 /article/div[1] 选取属于article子元素的第一个div元素 !!!这个地方下标是从1开始不是从0开始 /article/div[last()] 选取属于article子元素的最后一个div元素 /article/div[last()-1] 选取属于article子元素的倒数第二个div元素 //div[@lang] 选取所有拥有lang属性元素的div元素 //div[@lang = ‘eng’] 选取所有lang属性为eng的div元素 /div/* 选取所有div元素的所有子节点 //* 选取所有元素 //div[@*] 选取所有带属性的title元素 /div/a \ //div/p 选取所有div元素的a和p元素 //span \ //ul 选取文档中的span和ul元素 article/div/p \ //span 选取所有属于article元素和div元素和p元素 以及文档中所有的span元素 模糊查询12345678result_url = xpath_data.xpath("//input[contains(@class,'sister')]")print(result_url) # 匹配 class 含有 sister 的inputresult_url = xpath_data.xpath("//input[start-with(@class,'sister')]")print(result_url) # 匹配 class 以 sister 开头的 inputresult_url = xpath_data.xpath("//input[ends-with(@class,'sister')]")print(result_url) # 匹配 class 以 sister 结尾的 input 以 http://syw.ctgu.edu.cn/info/1003/29224.htm 为例子 获取这文章的时间 /html/body/ html为根节点 所以一开始为html/html/body/table[2]/tbody/tr/td[1]/table/tbody/tr[2]/td/table/tbody/tr[1]/td/form/table/tbody/tr[2]/td/span[1] 浏览器中F12 调试 点中之后 右键 复制 xpath 可直接查看xpath 当然xpath路径的写法并不唯一，从html源码上看，很容易发现时间是用span标签包着的并且class = “timestyle0010”，所以用//span[@class = “timestyle0010”][0]也可以找到 Beautifulsoup4 安装 bs4 pip install beautifulsoup4 参考文档 https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ Bs4的小例子1234567891011121314151617181920212223242526272829303132333435363738from bs4 import BeautifulSouphtml_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;span&gt;&lt;!-- 这是一个注释 --&gt;&lt;/span&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""# 很明显上面的html代码有问题，body 和 html 标签没有补全# 转换类型 soup = BeautifulSoup(html_doc, 'lxml') # 设定解析器为 lxml，建议pip安装lxml # 格式化输出、补全result = soup.prettify()print(result) # 这里 补全了html 和 body 标签# 解析数据print(soup.head) # 输出 &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;result_head = soup.headresult_p = soup.p # 这里有3个p标签，但是只能取到第一个# 数据result_a_text = soup.a.stringprint(result_a_text) # 输出为第一个a标签的内容 Elsie# 属性result_a_href = soup.a['href']print(result_a_href) # 输出为第一个a标签href属性 http://example.com/elsie bs4中的对象 标签 1print(type(soup.head)) # 输出为 bst.element.tag对象 NavigableString 1print(type(soup.a['href'])) # 输出为str BeautifulSoup 1print(type(soup)) # 输出为 bsf.BeautifulSoup Comment，注释类型 123# 取出第一个p标签中的内容print(soup.p.string) # 输出为None 空print(type(soup.p.string)) # 输出为 Comment 获取对象 find 方法 123456789# 1. findresult = soup.find(name='a')print(result) # 输出第一个a标签result = soup.find(attrs=&#123;'class':'title'&#125;)print(result) # 输出class 为 title的，如果有多个则依旧是输出的是第一个result = soup.find(text='Tillie')print(result) # 输出的就是传入的Titlle 底层调用的是 find_all 方法，只是 find_all 的 limit = 1，同时返回列表的第一个 find_all方法 123456# 2. find_allresult = soup.find_all(name='a')print(result) # 返回列表，输出的是所有标签为a的result = soup.find_all(attrs=&#123;'class':'sister'&#125;)print(result) select_one方法- 12345# 3. find_one result = soup.select_one('.sister') # css选择器result = soup.select_one('#id') # id选择器result = soup.select_one('head title') # 后代选择器print(result) 底层调用的是 find_all 方法，只是 find_all 的 limit = 1，同时返回列表的第一个 select 123456# 4. selectresult = soup.select('.sister') # css选择器result = soup.select('#id') # id选择器result = soup.select('title,.tile') # 主选择器 同事输出 title标签 和 class 为 tile 的result = soup.select('a[class="sister"]') # 标签选择器 找 class = "sister" 的 a 标签print(result) # 输出一个列表 获取标签包裹的内容属性 12345result = soup.select('a')[0].get_text()print(result) # 输出列表中第一个a标签的内容 Elsieresult = soup.select('a')[0].get('href')print(result) # 输出列表中第一个a标签的href属性值 数据存储 json中 必须是 双引号，而不能是单引号 这点很重要 字符串 和 dic list 转换12345678910111213import json# 字符串和dic list 转换data = '[&#123;"name":"张三","age":20&#125;,&#123;"name":"李四","age":20&#125;]'list_data = json.loads(data)print(type(list_data)) # str的json转化为列表list1 = [&#123;"name":"张三", "age":20&#125;, &#123;"name":"李四", "age":30&#125;]data_json = json.dumps(list1)print(type(data_json)) # 列表 转为 str的json 文件对象 和 list dict 转换 json 转 csv csv 一个类似于 Excle 表格的东西 1234567891011121314151617181920212223242526272829303132333435import jsonimport csvdata = '[&#123;"name":"张三","age":20&#125;,&#123;"name":"李四","age":20&#125;]'print(data)with open('test.json', 'w', encoding='utf-8') as file: file.write(data)# 1. 分别读 ，创建文件json_fp = open('test.json', 'r')csv_fp = open('csv.csv', 'w')# 2. 提出表头，表内容data_list = json.load(json_fp)data_head = data_list[0].keys() #获取表头 就是 keyvalue_list = []for value in data_list: value_list.append(value.values()) # 表单数据内容写入列表中 print(type(value)) # value 类型为dictprint(type(data_head))print(type(value_list))# 3. csv写入器writer = csv.writer(csv_fp) # csv 专用写入器，写入到 'csv.csv' 文件中# 4. 写入表头writer.writerow(data_head)# 5. 写入内容writer.writerows(value_list)# 6. 关闭文件json_fp.close()csv_fp.close() 爬取实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import jsonimport csvimport requestsfrom bs4 import BeautifulSoupfrom lxml import etreeNo_page = 'Page not found - All IT eBooks'star_url = 'http://www.allitebooks.com/page/'headers = &#123; "User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"&#125;page = 1with open('test.txt', 'r') as file: page = int(file.readline())csv_fp = open('csv.csv', 'a')CSV_writer = csv.writer(csv_fp)first = Truedef get_down_link(url): respon =requests.get(url, headers=headers) xpath_data = etree.HTML(respon.content.decode('utf-8')) download_link = xpath_data.xpath('//span[@class="download-links"]/a/@href') downlaod_book_title = xpath_data.xpath('//h1/text()') if downlaod_book_title == None or download_link == None or len(downlaod_book_title) == 0 or len(download_link) == 0: print("error") return print_str = 'name = ' + downlaod_book_title[0] + " link = " + download_link[0] print(print_str) ebook_dict = &#123;&#125; ebook_dict['book_title'] = downlaod_book_title[0] ebook_dict['download_link'] = download_link[0] global first if first == True: first = False json_head = ebook_dict.keys() # 获取表头 CSV_writer.writerow(json_head) CSV_writer.writerow(ebook_dict.values()) print("******** diyici ********") else: CSV_writer.writerow(ebook_dict.values()) pass# get_down_link('http://www.allitebooks.com/troubleshooting-and-maintaining-your-pc-all-in-one-for-dummies-3rd-edition-2/')while(True): url = star_url + str(page) + '/' respon = requests.get(url, headers=headers) soup = BeautifulSoup(respon.content.decode('utf-8'), 'lxml') title = soup.select_one('title').string if title == No_page: print('end') csv_fp.close() break download_links = soup.select('a[rel="bookmark"]') num = 0 for book in download_links: if num % 2 == 0: print(book.get('href')) get_down_link(book.get('href')) num = num + 1 global page with open('text.txt', 'w') as file: file.write(str(page+1) page = page + 1 print("*********** " , page , " ******************") Scrapy 框架 scrapy的帮助文档https://doc.scrapy.org/en/latest/topics/selectors.html 内建的CSS选择器和XPath表达式 基于IPython交互式shell，方便编写爬虫和debug 内建的文件导出和保存方法，格式多样的json，csv，xml 健壮的编码支持 扩展性强，可以使用signals和API（中间件，插件，管道）添加自定义功能 多种用于处理session，cookies，HTTP认证，user-agent，robots.txt，专区深度限制的中间件和插件 Scrapy内建Telnet console，可用于debug 名词解释 ENGINE：引擎，控制数据流的流向 SPIDERS：爬虫，对response进行数据分析 SCHEDULER：调度器，从引擎接受请求并对请求进行排队，以便未来引擎需要的时候返回引擎 ITEM PIPELINES：数据项管道，对解析成功的数据进行持久化 DOWNLOADER：下载器，把网页通过请求将其编程一个response，返回给引擎 中间件：即图像中紫色部分 ENGINE 和 DOWNLOADER 中间的中间件 可以对 request 和 response 进行一些修改（比如设置请求头，proxy代理，等等） ENGINE 和 SPIDERS 的 中间的中间件 可以 对ITEMS 或者 初识链接添加一下后处理（修改，添加，移除请求，处理爬虫异常等） 序号对应步骤 scrapy 会通过 你给的初始链接（start_urls）列表，提取链接 链接会通过引擎，到调度器 从调度器返回给引擎下一个要爬去的请求 引擎通过下载器中间件将链接传递给下载器 下载器通过下载器中间件返回给引擎 再把响应给爬虫 爬虫解析完响应后通过中间件将数据项和新的请求传递给引擎 引擎把数据项传递给数据项管道，同时将一下个请求传递个调度器 安装创建Scrapy工程12pip install scrapyscrapy startproject 工程名 在命令行所在文件夹中创建出 与工程名相同的文件夹 工程名文件夹 __init__.py初识化文件 __pycache__pytho加速引擎 items.py 指定保存文件的数据结构 middlewares.py 中间件，处理request和reponse等相关配置 pipleines.py项目管道，可以输出items settings.py 设置文件，指定项目的一些配置 spiders文件夹，放置一些要手写的爬虫 _init__.py __pycache__ scrapy.cfg 配置文件，指定路径 Scrapy Shell 操作 我这里是Ubuntu操作系统，直接输入scrapy shell 你想爬取的url 进入命令行操作 1scrapy shell https://blog.csdn.net/baidu_41671472/article/details/82904002 123456789101112131415161718192021222324252627282930313233343536373839404142434445462019-02-03 18:19:43 [scrapy.utils.log] INFO: Scrapy 1.6.0 started (bot: scrapybot) # scrapy的版本2019-02-03 18:19:43 [scrapy.utils.log] INFO: Versions: lxml 4.3.0.0, libxml2 2.9.9, cssselect 1.0.3, parsel 1.5.1, w3lib 1.20.0, Twisted 18.9.0, Python 3.7.0 (default, Jun 28 2018, 13:15:42) - [GCC 7.2.0], pyOpenSSL 18.0.0 (OpenSSL 1.0.2p 14 Aug 2018), cryptography 2.3.1, Platform Linux-4.15.0-45-generic-x86_64-with-debian-buster-sid # scrapy 一些配置文件的版本2019-02-03 18:19:43 [scrapy.crawler] INFO: Overridden settings: &#123;'DUPEFILTER_CLASS': 'scrapy.dupefilters.BaseDupeFilter', 'LOGSTATS_INTERVAL': 0&#125; # 设置信息2019-02-03 18:19:43 [scrapy.extensions.telnet] INFO: Telnet Password: 6b0b551cecdc1f242019-02-03 18:19:43 [scrapy.middleware] INFO: Enabled extensions: # 开启的一些插件['scrapy.extensions.corestats.CoreStats', 'scrapy.extensions.telnet.TelnetConsole', 'scrapy.extensions.memusage.MemoryUsage']2019-02-03 18:19:43 [scrapy.middleware] INFO: Enabled downloader middlewares:# 开启的插件['scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware', 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware', 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware', 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware', 'scrapy.downloadermiddlewares.retry.RetryMiddleware', 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware', 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware', 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware', 'scrapy.downloadermiddlewares.cookies.CookiesMiddleware', 'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware', 'scrapy.downloadermiddlewares.stats.DownloaderStats']2019-02-03 18:19:43 [scrapy.middleware] INFO: Enabled spider middlewares: # 开启的中间件['scrapy.spidermiddlewares.httperror.HttpErrorMiddleware', 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware', 'scrapy.spidermiddlewares.referer.RefererMiddleware', 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware', 'scrapy.spidermiddlewares.depth.DepthMiddleware']2019-02-03 18:19:44 [scrapy.middleware] INFO: Enabled item pipelines: # 启用数据线管道[]2019-02-03 18:19:44 [scrapy.extensions.telnet] INFO: Telnet console listening on 127.0.0.1:6023 # telnet 在本地的6023端口进行监听2019-02-03 18:19:44 [scrapy.core.engine] INFO: Spider opened # 显示爬虫被打开了# 下面显示的就是 请求和响应的一些信息2019-02-03 18:19:44 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://blog.csdn.net/baidu_41671472/article/details/82904002&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x7fc89040e4a8&gt;[s] item &#123;&#125;[s] request &lt;GET https://blog.csdn.net/baidu_41671472/article/details/82904002&gt;[s] response &lt;200 https://blog.csdn.net/baidu_41671472/article/details/82904002&gt;[s] settings &lt;scrapy.settings.Settings object at 0x7fc890303e48&gt;[s] spider &lt;DefaultSpider 'default' at 0x7fc88fe0f470&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects [s] shelp() Shell help (print this help)[s] view(response) View response in a browser 可以直接在命令行中使用xpath 等的命令 12response.xpath('//h3/text()').extract() #获取所有 h3 标签的内容response.xpath('//h3[last()]/text()').extract() # 获取最后一个 h3 标签的内容 全局命令 startproject语法: 1scrapy startproject &lt;project_name&gt; 这个命令是scrapy最为常用的命令之一，它将会在当前目录下创建一个名为 1&lt;project_name&gt; 的项目。 settings语法: 1scrapy settings [options] 该命令将会输出Scrapy默认设定，当然如果你在项目中运行这个命令将会输出项目的设定值。 runspider语法: 1scrapy runspider &lt;spider_file.py&gt; 在未创建项目的情况下，运行一个编写在Python文件中的spider。 shell语法: 1scrapy shell [url] 以给定的URL(如果给出)或者空(没有给出URL)启动Scrapy shell。 例如， 1scrapy shell http://www.baidu.com 将会打开百度URL， 并且启动交互式命令行，可以用来做一些测试。 fetch语法: 1scrapy fetch &lt;url&gt; 使用Scrapy下载器(downloader)下载给定的URL，并将获取到的内容送到标准输出。简单的来说，就是打印url的html代码。 view语法: 1scrapy view &lt;url&gt; 在你的默认浏览器中打开给定的URL，并以Scrapy spider获取到的形式展现。 有些时候spider获取到的页面和普通用户看到的并不相同，一些动态加载的内容是看不到的， 因此该命令可以用来检查spider所获取到的页面。 version语法: 1scrapy version [-v] 输出Scrapy版本。配合 -v 运行时，该命令同时输出Python, Twisted以及平台的信息。 项目命令 crawl语法: 12scrapy crawl &lt;spider_name&gt;scrapy crawl [爬虫名] -o [保存到.json 文件中] 使用你项目中的spider进行爬取，即启动你的项目。这个命令将会经常用到，我们会在后面的内容中经常使用。 check语法: 1crapy check [-l] &lt;spider&gt; 运行contract检查，检查你项目中的错误之处。 list语法: 1scrapy list 列出当前项目中所有可用的spider。每行输出一个spider。 genspider语法: 1234scrapy genspider [-t template] &lt;name&gt; &lt;domainscrapy genspider + 文件名 + 网址例子： scrapy genspider text baidu.com 在当前项目中创建spider。该方法可以使用提前定义好的模板来生成spider。您也可以自己创建spider的源码文件。 Scrapy 使用 items.py文件 先引入scrapy包 定义一个与工程名相同的类，继承于 scrapy.Item 把自己的数据项定义在这里 # define the fields for your item here like: # name = scrapy.Field() 12345678910class LcfirstItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() # 将我们想抓取的数据项的字段写下来 title = scrapy.Field() # 标题 price = scrapy.Field() # 价格 area = scrapy.Field() # 面积 district = scrapy.Field() # 地段 pass 新建 my_spider.py 文件，创建自己的爬虫（名字随意） scrapy 会通过 你给的初始链接列表，提取链接 链接会通过引擎，到调度器，从调度器返回给引擎 引擎通过下载器中间件传递给下载器，下载器通过下载器中间件返回给引擎 再把响应给爬虫 爬虫仅仅负责解析，所以我们只要写解析就行了 解析必须写在 parse 函数中 my_spider.py文件 1234567891011121314151617181920212223242526import scrapyfrom LcFirst.items import LcfirstItemfrom scrapy.utils import spider# 导入 刚刚写的 items 中的 自己的类class MaintianItem(scrapy.Spider): name = 'zufang' # 爬虫的名字 start_urls = ['http://bj.maitian.cn/zfall/PG1'] # 格式固定，必须 def parse(self, response): for zufang_item in response.xpath('//div[@class="list_title"]'): yield &#123; 'title' : zufang_item.xpath('./h1/a/text()').extract_first().strip(),# 对应items.py中的 title 对象 'price' : zufang_item.xpath('./div[@class="the_price"]/ol/strong/span/text()').extract_first().strip(), # 对应items.py中的 price 对象 'area' : zufang_item.xpath('./p/span/text()').extract_first().strip(), # 对应items.py中的 area 对象 'district' : zufang_item.xpath('./p/span/text()').re(r'昌平|朝阳|东城|大兴|房山|丰台|海淀|门头沟|平谷|石景山|顺义|通州|西城')[0]# 对应items.py中的 district 对象 # 上述使用正则，因为地区肯定会出现在上述地区中的其中之一，因为网站里面明确表示只有这些地区的房子 &#125; next_page_url = response.xpath('//div[@id="paging"]/a[@class="down_page"]/@href').extract_first() # 下一页链接 print(" ********** next_page_url =") print(next_page_url) if next_page_url is not None: yield scrapy.Request(response.urljoin(next_page_url)) # 如果不为空，则 将下一个链接 使用urljoin()方法构建完整的绝对URL，因为有些链接是相对链接 博主到这里因为没有用代理，导致被网站封IP了 文件pipelines.py 用于数据保存，数据持久化 参数 item 就是 从上面写的爬虫中yield 出来的内容，是一个字典 1234567class LcfirstPipeline(object): def process_item(self, item, spider): zufang = dict(item) # 将提取出来的数据 保存起来 持久化 # 参数：item 就是从爬虫中 yield 出来的内容 # 保存item数据到数据库或者本地等 return item pipelines.py中常有的几个函数 12345678910111213141516171819class LcfirstPipeline(object): def __init__(self): # 可选实现，做参数初始化等 # doing something def process_item(self, item, spider): # item (Item 对象) – 被爬取的item # spider (Spider 对象) – 爬取该item的spider # 这个方法必须实现，每个item pipeline组件都需要调用该方法， # 这个方法必须返回一个 Item 对象，被丢弃的item将不会被之后的pipeline组件所处理。 return item def open_spider(self, spider): # spider (Spider 对象) – 被开启的spider # 可选实现，当spider被开启时，这个方法被调用。 def close_spider(self, spider): # spider (Spider 对象) – 被关闭的spider # 可选实现，当spider被关闭时，这个方法被调用 下载器中间件 突破反爬虫：https://www.cnblogs.com/hyit/articles/7882396.html 突破反爬虫从某种程度上来看就是 设置 下载器中间件 下载器中间件按照优先级被调用： 当request从引擎向下载器传递时，数字小的下载器中间件先执行 当下载器将response向引擎传递时，数字大的下载器中间件先执行，小的后执行 Scrapy 提供的默认下载器中间件 是个字典类型，后面跟的整数就是上述的 数字， 1234567891011121314151617DOWNLOADER_MIDDLEWARES_BASE = &#123; 'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware': 100, #爬虫协议中间件 'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware': 300,#HTTP认证的中间件 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware': 350,#下载超时中间件 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware': 400,#默认headers中间件 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': 500,# user-agent中间件 'scrapy.downloadermiddlewares.retry.RetryMiddleware': 550,#重试 'scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware': 560,#Ajax抓取 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware': 580,#元数据刷新 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 590,#Http压缩 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware': 600,#重定向 'scrapy.downloadermiddlewares.cookies.CookiesMiddleware': 700,#Cookies 'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware': 750,#代理中间件 'scrapy.downloadermiddlewares.stats.DownloaderStats': 850,#下载器数据 'scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware': 900,#Http缓存&#125; 下载器中间件？ 下载器中间件是一个类，类里可以定义方法 process_request() 比较重要 process_response() process_exception() 等等 process_request 参数是request,spider 参数request 是个字典，包含了headers ，url等信息 可以利用request里面的信息，对请求做修改，这时函数一般返回的是None 典型的任务是 修改user-agent，变换代理 该函数也可以返回response 如果根据参数request里的url直接就去抓取就返回response对象 那么下载器不经过下载器中间件，直接返回引擎 该函数也可以返回request对象 如果对请求做了修改，则发回到调度器，等待调度 process_response(request,response, spider) 必须返回Response，Request或者IgnoreRequest异常 例子 这次访问 http://httpbin.org/ 网站 scrapy 工程创建的时候就自带 middlewares.py 文件 里面定义了下载器中间件和爬虫中间件 当然也可以自定义下载器中间件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import randomclass RandowUA(): def __init__(self): self.user_agent = [ 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60', 'Opera/8.0 (Windows NT 5.1; U; en)', 'Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0', 'Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11', 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER', 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)', 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)', 'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0', 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36' ] def process_request(self, request, spider): request.headers['User-Agent'] = random.choice(self.user_agent) # def process_response(self, request, response, spider): # response.status = 201 # return responseclass ProxyMiddleware: def __init__(self): self.proxy_list = [ 'https://113.121.146.207:9999', 'https://121.61.1.99:9999', 'https://112.85.168.112:9999', 'https://123.55.102.102:9999', 'https://121.61.1.153:9999', 'https://121.61.0.53:9999', 'http://125.123.141.16:9999', 'http://222.217.30.94:9999', 'https://121.233.206.247:9999', 'http://116.209.57.154:9999', 'http://121.61.0.116:9999', 'http://61.184.109.33 61320', 'http://112.85.130.23:9999', 'http://116.209.53.176:9999', 'https://121.61.0.31:9999', 'http://110.52.235.160:9999', 'https://115.151.2.42:9999', 'https://115.151.4.121:9999', 'https://122.193.245.53:9999', 'http://116.209.59.97:9999' ] def process_request(self, request, spider): ip = random.choice(self.proxy_list) request.meta['proxy'] = ip 第一个类设置请user-agent 第二个类仅仅设置了 代理 代理一定记得加上 http://或者 https:// 否则报错 切记 记得必须要在使用代理前进行判断，判断该代理能否运行，否则程序报错 定义好了中间件，那么怎么使用呢？ 在settings文件中，添加如下代码 差不多在文件的55行左右的地方有个DOWNLOADER_MIDDLEWARES，这就是scrapy设置的例子 1234DOWNLOADER_MIDDLEWARES = &#123; 'LcFirst.middlewares.RandowUA': 543, #后加请求头 'LcFirst.middlewares.ProxyMiddleware': 542, # 先加代理&#125; 设置爬虫，查看结果 12345678class MaintianItem(scrapy.Spider): name = 'zufang' # 爬虫的名字 # start_urls = ['http://bj.maitian.cn/zfall/PG1'] # 格式固定，必须 start_urls = ['http://httpbin.org/get'] def parse(self, response): print(response.text) print(response.status) 输出结果 123456789101112131415[scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://httpbin.org/get&gt; (referer: None)&#123; "args": &#123;&#125;, "headers": &#123; "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Encoding": "gzip,deflate", "Accept-Language": "en", "Cache-Control": "max-age=259200", "Connection": "close", "Host": "httpbin.org", "User-Agent": "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)" &#125;, "origin": "110.52.235.160", "url": "http://httpbin.org/get"&#125; 有些代理 IP 可能无效，需要在使用前先进行测试 爬虫中间件 作用 处理引擎传递给爬虫的响应 处理爬虫传递给引擎的请求 处理爬虫传递给引擎的数据项 默认爬虫中间件 1234567&#123; 'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware': 50,# 处理http错误 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware': 500, # 站外中间件 'scrapy.spidermiddlewares.referer.RefererMiddleware': 700, # 网页跳转中，前一个网页就是后一个网页的referer 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware': 800, # url长度的中间件 'scrapy.spidermiddlewares.depth.DepthMiddleware': 900, # url深度的中间件&#125; 自定义爬虫中间件 详情见：http://docs.scrapy.org/en/latest/topics/spider-middleware.html#writing-your-own-spider-middleware 爬虫中间件也是一个类，包含几个函数： process_spider_input(response, spider) process_spider_output(response, result, spider) process_spider_exception(response, exception, spider) process_start_requests(start_requests, spider) from_crawler(cls, crawler) 实际上，好像并没有怎么用到过爬虫中间件。。。。所以没有例子的说 pipelines 管道 参考链接：http://docs.scrapy.org/en/latest/topics/item-pipeline.html 每个管道组件都是一个实现了某个功能的python类，常见功能有： 清理html数据 做确认 查重 存入数据库 等等 每个管道组件的类，必须要有以下方法 process_item(self, item, spider) 比较重要 open_spider(self, spider) cloase_spider(self, spider) from_crawler(cls, crawler) 丢弃数据项1234567891011121314from scrapy.exceptions import DropItemclass LcfirstPipeline(object): vat_factor = 1.15 def process_item(self, item, spider): if item['price']: if item['price_excludes_vat']: item['price'] = item['price'] * self.vat_factor return item else: raise DropItem("missing price in %s" % item)# 如果 item 包含 'price' 的数据项，则返回，否则丢弃该item 保存到MongoDB123456789101112131415161718192021222324252627mport pymongoclass MongoPipeline(object): collection_name = 'scrapy_items' def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE', 'items') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[self.collection_name].insert_one(dict(item)) return item 保存为本地Json文件1234567891011121314import jsonclass JsonWriterPipeline(object): def open_spider(self, spider): self.file = open('items.jl', 'w') def close_spider(self, spider): self.file.close() def process_item(self, item, spider): line = json.dumps(dict(item)) + "\n" self.file.write(line) return item 去重12345678910111213from scrapy.exceptions import DropItemclass quchongPipeline(object): def __init__(self): self.ids_seen = set() def process_item(self, item, spider): if item['id'] in self.ids_seen: raise DropItem("duplicate item found : %s" % item) else: self.ids_seen.add(item['id']) return item 激活管道 settrings 文件中 找到 pipilenes 顺序是数字从小到达执行 123456ITEM_PIPELINES = &#123; 'LcFirst.pipelines.LcfirstPipeline': 300, 'LcFirst.pipelines.MongoPipeline': 301, 'LcFirst.pipelines.JsonWriterPipeline': 302, 'LcFirst.pipelines.quchongPipeline': 303,&#125; Setting文件是否遵守爬虫协议1ROBOTSTXT_OBEY = False # 不遵守robots.txt 规定的协议 默认并发请求数 默认是16个 通过设置 CONCURRENT_REQUESTS = 32 可以设置为32个 12# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32 请求间歇 如果两次请求同一个网站，是否需要间歇 默认间歇值为0 设置 DOWNLOAD_DELAY = 3 ，设置间隔时间为3s 1234# Configure a delay for requests for the same website (default: 0)# See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3 每个域名的并发请求数 CONCURRENT_REQUESTS_PER_IP = 16，设置每个ip的并发请求数 123# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16 是否启用cookies 默认是启用的 12# Disable cookies (enabled by default)#COOKIES_ENABLED = False 是否启用Telnet控制台 默认是启用的 12# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False autothrottle extension 插件 限制抓取的速度 默认插件关闭 AUTOTHROTTLE_ENABLED = True #开启autothrottle 插件 AUTOTHROTTLE_START_DELAY = 5 # 抓取初识链接延迟5s AUTOTHROTTLE_MAX_DELAY = 60 # 最大的延迟是60s AUTOTHROTTLE_DEBUG = False # 显示统计信息 123456789101112# Enable and configure the AutoThrottle extension (disabled by default)# See https://doc.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True #开启autothrottle 插件# The initial download delay#AUTOTHROTTLE_START_DELAY = 5 # The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60 # The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False Http缓存 可以做到一定的提速，不过会占用本地的存储资源 HTTPCACHE_ENABLED = True # 打开http缓存 HTTPCACHE_EXPIRATION_SECS = 0 # 缓存的过期时间，以秒为单位 HTTPCACHE_DIR = ‘httpcache’ # 缓存的文件夹路径 HTTPCACHE_IGNORE_HTTP_CODES = [] # 忽略那些http响应码 HTTPCACHE_STORAGE = ‘scrapy.extensions.httpcache.FilesystemCacheStorage’ 1234567# Enable and configure HTTP caching (disabled by default)# See https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings#HTTPCACHE_ENABLED = True#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = 'httpcache'#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 如何使用无头浏览器来抓取 无头浏览器即headless browser 是一种没有界面的浏览器 既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已 随着反爬虫和反反爬虫对抗技术的升级，越来越多的爬虫开始使用无头浏览器伪装成正常用户绕过反爬虫策略。 从数据的角度来看： 数据的来源有 Html，Ajax，js这三种 需要下载对应浏览器的驱动，比如chromedriver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from selenium import webdriverfrom selenium.webdriver.support.wait import WebDriverWait# 设置选项option = webdriver.ChromeOptions()option.add_argument('headless')# 不加上headless 则 弹出chrome# 加上 headless 则 不弹出chrome# 要换成适应自己浏览器的操作系统的ChromeDirver# 添加驱动driver = webdriver.Chrome( executable_path = '/home/cong/桌面/chromedriver', # 驱动的执行路径 chrome_options=option # chrome 的选项)url = 'https://www.baidu.com'# 打开网站driver.get(url)# 网站标题print(driver.title)# 在搜索栏输入关键字timeout = 5 #定义超时时间为5秒search_content = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//input[@id="kw"]')) # 找到输入框 search_content.send_keys('python')# 模拟点击“百度一下”search_button = WebDriverWait(driver, timeout).until( lambda d: d.find_element_by_xpath('//input[@id="su"]')) # 找到 搜索按钮search_button.click()# 打印搜索结果search_result = WebDriverWait(driver, timeout).until( lambda d: d.find_elements_by_xpath('//h3[contains(@class, "t")]') # 注意element后面一定加上s)# print(search_result)for item in search_result: print(item.text)driver.close() option.add_argument(‘headless’) 不加上headless 则 弹出chrome 加上 headless 则 不弹出chrome 设置选项 opetion = webdriver.ChromeOptions() 添加驱动 driver = driver = webdriver.Chrome( executable_path = ‘/home/cong/桌面/chromedriver’,hrome_options=option) 输入文字 element.send_keys(‘you want search’) 点击 element.click() 查找元素 单一节点 element = drive.find.element_by_id(“”) element = drive.find.element_by_name(“”) element = drive.find.element_by_xpath(“”) …… 多个节点 element = drive.find.elements_by_id(“”) element = drive.find.elements_by_id(“”) element = drive.find.elements_by_id(“”) …… 动作链 from selenium.webdriver import ActionChains action_chains = ActionChains(driver) action_chains.drag_and_drop(element, target).perform() 上述是 实现一个 名为 drag_and_drop (拖动并放下)的动作 在页面中切换 window_heandles = driver.window_handles dirver.switch_to.window(window_handles[-1]) 保存页面截图 driver.save_screeenshot(‘screen.png’) 打开一个网页的时候，网页的加载速度不一样，有快有慢 如果加载速度慢，在网页刚开的一瞬间就使用xpath等查找节点，可能查找不到 添加条件进行判断 WebDriverWait 直接等待方式 条件等待方式 可以直接使用上述的lambda表达式方式，比较方便简单 使用cookie cookies 必须写成这种 name, value 的格式 写成一个 字典列表 12345678910chrome_cookies = [ &#123;'name': 'BAIDUID', 'value': '70AE50017189CEE98CF4E77CF222:FG=1'&#125;, &#123;'name': 'BIDUPSID', 'value': '670AE50017189CE8CF4241E77CF222'&#125;, &#123;'name': 'PSTM', 'value': '154286666'&#125;, &#123;'name': 'BD_UPN', 'value': '123353'&#125;, &#123;'name': 'BDUSS', 'value': '0RkcTNETTczdElRUUZBaVNLWjZQd2VNN2VZcy00Z2g2S2FWdjFGcW'&#125;]for cookie in chrome_cookies: driver.add_cookie(cookie)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lua学习]]></title>
    <url>%2F2017%2F12%2F24%2FLua%2F</url>
    <content type="text"><![CDATA[Lua简介 Lua是脚本型语言 动态编译 动态执行 每次修改不需要重新编译链接执行 运行时编译而并非运行前编译 是C语言编写的 速度比C语言快 特性Lua的Hello World1print("Hello world") Lua行末不要分号 Lua的括号12345do …… …… ……end Lua语言几乎用不到大括号，取而代之的是do…end Lua的注释123456789--这是一个注释// 双斜杠不是注释了哦--[[这是一个多行注释哦]]/* 这不是多行注释了哦*/ 小心不要变成纯文本了 12345--如果上面的多行注释没有写 双横线的话，就变成的纯文本赋值语句哦a = [[&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]-- 这个时候的 a 就是一个纯文本 数据类型 Lua是动态类型，不需要定义就可以直接使用 12a = "I'm a"print("a is "..a) Lua的数据类型是动态可变的 Lua的数据类型 数字类型 整型 浮点型 long double 等 都是 数字类型，并没有明确划分 字符串类型 thread类型 线程也算是一个数据类型 function类型 函数方法的数据类型 table 数组，融合的链表和键值对等 其他类型 1234567891011121314a = function(x) print("user input is "..x)enda("test")-- 这就相当于调用了function(x) 那个函数-- 唯一一个使用了 大括号的地方myTable = &#123;12,13&#125;print(myTable) -- 会输出table的地址for k,v in pairs(myTable) do print(k,v)end-- 输出了序列号和对应的值（序号从1开始） 变量作用域123456789101112b = "123"local c = 12local function myfuntion1() print("i'm lua")endlocal function myfuntion2() local a = "hello" return aend 其他lua文件引用该lua文件的时候，将无法访问到local标记的变量 相当于 是一个 private 的变量 反之 如果不加 local标识符，那么Lua默认的是全局变量global类型 如果一个function函数中创建的变量不是local的，就意味着它是一个global变量 if语句(没有switch语句) 单独一个if 1234local a = 12if a == 12 then print("a\'s value is 12")end if..else 语句 123456local a = 2if a == 2 then print("value is 12")else print("value is not 12") end if…else if…语句 123456local a = 12if a == 12 then print("value is 12") elseif a ~= 11 then print("value is not 11")end 这里不等于符号是 ~= 注意注意！！！！！ 函数/方法无参无返回值123local function f1() print("hello")end 有参无返回值123local function f2(a) print(a)end 有参有返回值1234567local function f3(a) a += 2 return aend--调用a = f3(123) 返回多个值123456local function f4() return 1,2end-- 调用local a,b = f4() 可变参数列表12345678910local function f5(...) local myTable = &#123;...&#125; for k,v in pairs(myTable) do print(k,v) endend-- 调用f5("12",123,"ok") 库函数 print() 就是一个很明显的print()，因为我们没有定义它 有些函数是Lua自带的 逻辑操作符1and or not 表示假 false nil 表示真 0 其他数值 and 和 or 就类似于 C语言中的 &amp;&amp; 和 || and 如果我们第一个需要去计算的操作数，如果操作数是假，则返回第一个操作数 反之则返回第二个操作数 1234print(1 and 2)-- 输出的 2 哦print(false and 5)-- 输出 false 哦 or 如果第一个我们需要去计算你的操作数为真，返回第一个值 反之返回第二个值 1234print(1 or 5)-- 返回 1print(false or 5)-- 返回 5 not 类似于 C语言的 ! 取反 not 永远返回的是 true或false 1234print( not nil)-- 返回 trueprint( not 1)-- 返回 false 循环语句while123456local index = 1local mytable = &#123;1,2,3&#125;while mytable[index] do print(mytable[index]) index = index+1end do……while换成了 repeat1234repeat line = io.read() -- 从命令行获取输入 print(line)until line ~= "" for循环1234567891011121314151617181920for i = 1, 5 do print(i) end-- 输出 1 2 3 4 5 想想为什么for i = 1, 10, 2 do print(i) end-- 输出 1 3 5 7 9 想想为什么for i = 20, 10, -2 do print(i) end-- 输出 20 18 16 14 12 想想为什么table = &#123;1,2,3&#125;for i=1, #table do print(table[i])end-- #table 相当于取 table的长度，然后遍历 上述可见，for 后面有三个参数 一个是初始化i，一个是结束判断，一个是加减i(默认为1) Table的使用 Table类似于Java的list和map的结合体 12345678910-- 建立一个有数值的tablelocal MyTable = &#123; 1, -- 索引为1 2, -- 索引为2 3, -- 索引为3 4, -- 索引为4 5, -- 索引为5 table2 = &#123;1,2,3&#125;, -- 索引不为6 "ok" -- 索引为6&#125; 为什么上面的table2的索引部位6呢？ Table的遍历方式 Table的复杂性导致其有三种遍历方式 因为Table既是链表类型又是键值对类型 123456789101112131415myTable = &#123; k = "x"&#125;print(myTable[k])-- 输出 nilprint(myTable["k"])-- 输出 xprint(myTable.k)-- 输出 x-- 又或者直接s = "ok"myTable[s] = 10print(myTable[s])-- 直接通过键去设置值 myTable.k 与 myTable[“k”]有所不同 myTable.k 等价于 myTable[“k”]，索引的键就变成了字符串 myTable[k] 表示用变量k的值来索引table，索引的键可以是其他 普通遍历方式12345678myTable=&#123; 1,2,3,4,k = "ok",5&#125;for i=1, #myTable do print("value is "..myTable[i])end-- 只输出1,2,3,4,5 哦， 因为 "ok" 的键为 "k" for ipairs(迭代器)123for i,v in ipairs(myTable) do print(i,v)end 与第一种for循环方式一样，都是按照当前索引的隐式索引来迭代并显示值的 for pairs(迭代器)123for k,v in pairs(myTable) do print(k,v)end 按照键值对来输出 如果值为一个table，则会输出该table的地址 Table的作用 你可以作为第三方插件集成到项目中，为项目提供一个支持功能 完全使用table进行开发 当做一种数据的配置集（就是阵列） 整体游戏的配置集（例子） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 使用lua，当做一种配置信息application_config = &#123; game_config = &#123; ifDebugModel = false, -- 调试模式 isCheatModel = true -- 作弊模式 &#125;, sound_config = &#123; isBackgroundMusicOpen = true, isEffectOpen = false &#125;, textrure_config = &#123; Plist_Dictionary = "res/plist/", PACKE_TEXTURE_DIR = "res/images/" &#125;&#125;-- 小怪阵列enemy_waves = &#123; &#123;enterId = 1, infoid = 1&#125;, &#123;enterId = 2, infoid = 1&#125;, &#123;enterId = 2, infoid = 2&#125;, &#123;enterId = 1, infoid = 2&#125;, &#123;enterId = 1, infoid = 1&#125; --[[ 很典型的小怪阵列 enterId 指的是 出兵口 infoid 有一些具体信息 ]]&#125;enemy_datas = &#123; &#123; maxHp = 100, damage = 70, isHaveSpecialEffect = true &#125;, &#123; maxHp = 50, damage = 20, isHaveSpecialEffect = false &#125;, &#123; maxHp = 75, damage = 50, isHaveSpecialEffect = false &#125;, &#123; maxHp = 125, damage = 80, isHaveSpecialEffect = true &#125; -- 这里的参数 maxHp 指的是最高血量，damage 指的是攻击伤害， isHavaSpecialEffect 指的是是否有攻击特效&#125;for key, value in pairs(enemy_datas) do print(key, value) if type(value) == "table" then for ik,iv in pairs(value) do print(ik, iv) print("__________") end endend 使用Lua可以很快的给角色赋予属性使用Lua可以很快的设置调试属性 读写数据文件 以万能的txt文件作为例子 这里使用IO库 一种写法 读12345678910111213141516171819202122232425262728293031323334local f = assert(io.open("123.txt",'r'))--[[ 返回一个文件流指针 assert 是一个断言，当读写输入报错的时候会报错 这里的io其实是一个table，正如同上面的table所讲的使用 '.' 来获取键的值 这里的open就是io的一个键 open 函数 有两个参数 一个是 路径名字 一个是 操作名字 r 以只读方式打开文件，该文件必须存在。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） r+ 以可读写方式打开文件，该文件必须存在。 w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a+ 与a类似，但此文件可读可写 b 二进制模式，如果文件是二进制文件，可以加上b + 号表示对文件既可以读也可以写]]local string = f:read("*all");-- *all 表示读取文件的所有内容--[[ *line 表示读取一行 *number 表示读取一个数字 &lt;num&gt; 读取一个不超过num长度的字符串]]f:close() -- 关闭流print(string) 需要强调的是，f后面的’:’相当于面向对象的封装方式 -写 1234567local function Write_txt(filename, inData) local f = assert(io.open(filename, 'a')) f:write(inData);endWrite_txt("123.txt", "\nthis is a function"); 另一种写法1234567891011121314151617181920212223242526272829303132333435------------------简单模型-------------------读local file1=io.input("1.txt") --当前目录"1.txt"要存在，不然出错local str=io.read("*a")print(str)--写local file2=io.output("2.txt") --当前目录"2.txt"不需要存在io.write(str)io.flush()io.close()--利用这几个函数可以做一个文件复制的函数function copy(fileA,fileB) local file1=io.input(fileA) if not file1 then print(fileA.."不存在") return end local str=io.read("*a") local file2=io.output(fileB) io.write(str) io.flush() io.close() endfor line in io.lines("1.txt") do print(line)end------------------完整模型-----------------local f=io.open("3.txt","a+")f:write("Happy New Year!")f:flush()f:seek("end",-1) --定位到文件末尾前一个字节local str=f:read(1) --读取一个字符print(str) --输出"!"f:close() 串行化 当一个对象没用被用到后就会从内存中delete掉，但是有的时候我们又想在之后恢复该对象到当时的状态 12345678910111213141516171819202122232425function serialize( o ) if type(o) == "number" then io.write( o ) elseif type(o) == "string" then io.write(string.format("%q", o)) elseif type(o) == "table" then io.write("&#123;\n") for k,v in pairs(o) do io.write(" ", k, " = ") serialize( v ) io.write(",\n") end io.write("&#125;\n") endendfile = io.output("123.txt")table = &#123; 1,2,3,4,5&#125;serialize(table)io.flush()io.close() 上述代码将一个table对象保存到txt文件中 模块化 module Java有 package包 来封装类 C++有 namespace 名空间 来封住类 Lua与C++的交互 Lua底层实现是 C/C++ Lua与C++交互的中间件栈 Lua与C++又部分不同，Lua有内部垃圾回收机制 Lua无需声明直接使用，而C++需要声明变量]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习]]></title>
    <url>%2F2017%2F12%2F23%2FJava%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[真～Java基础 Java SE：Java Platform， Standard Edition 标准版：各应用平台的基础，桌面开发和低端商务应用的解决方案 Java EE：Java Platform，Enterprise Edition 企业版：以企业为环境而开发应用程序的解决方案 Java ME：Java Platform，Micro Edition 微型版：致力于消费产品和嵌入式设备的最佳解决方案 体系特点 一种纯面向对象的编程语言 一种与平台无关（跨平台）的语言 它提供了在不同平台下运行的解释环境 一种健壮的语言，吸收了C/C++语言的优点 有较高的安全性 自动垃圾回收 强制类型检查 取消指针 Java跨平台 对于不同的运行平台，有不同的JVM（Java Virtual M×××） JVM屏蔽了底层运行平台的差别，实现了“ 一次编译，随处运行” 垃圾回收（GC） 不再使用的内存空间应当进行回收 垃圾回收在Java程序运行过程中自动启用，用于检查并释放那些可以被释放的空间 程序开发的步骤 程序：是为了实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合 第一个Java程序12345678910111213/** *public：共有的 *class：类 *Hello：类名 */public class Hello&#123; public static void main(String[] args)&#123; System.out.println("hello world"); // static 静态关键字 // main 主函数，程序入口方法 // void 没有返回值 &#125;&#125; 代码格式： java 代码的位置 java 严格区分大小写 java 是一种自由格式的语言 代码分为结构定义语句和功能执行语句 功能执行语句的最后必须用分号结束 Java基本语法变量 变量就是系统为程序分配的一块内存单元，用来存储各种类型的数据 根据所存储的数据类型的不同，有各种不同类型的变量 变量名代表这块内存中的数据 变量的分类 变量的分类： 按所属的数据类型划分 基本数据类型 引用数据类型 按被声明的位置划分 局部变量：方法或语句块内部定义的变量 成员变量：方法外部，类的内部定义的变量 数据类型 数据类型 关键字 占用字节 取值范围 默认值 布尔型 boolean 1 true、false false 字节型 byte 1 -128～127 0 短整型 short 2 -2^15～2^15-1 0 整型 int 4 -2^31～2^31-1 0 长整形 long 8 -2^63～2^63-1 0 字符型 char 2 0～2^16-1 ‘\u0000’ 单精度浮点型 float 4 1.4013E-45～3.4028E+38 0.0F 双精度浮点型 double 8 4.9E-324～1.7977E+308 0.0F 基本数据类型转换 自动类型转换： 容量下的类型自动转换成容量大的数据类型 byte,short,int-&gt;float-&gt;long-&gt;double byte,short,int不会相互转换，他们三者在计算时会转换成int类型 强制类型转换： 容量大的类型转换成容量小的数据类型时，要加上强制转换符 long n = 100L; int i = (int)n; boolean 类型不能转换成任何其他数据类型 关键字 abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implement import instanceof int interface long native new package private protected public return strictfp short static super switch synchronized this throw throws transient try void volatile while 键盘输入：Scanner input = new Scanner(System.in) Java面向对象编程基础类与对象的关系 类表示一个共性的产物，是一个综合的特征，而对象是一个个性的产物，是一个个性的特征 类由属性和方法组成 属性：相当于特征，人的名字等 方法：相当于行为，人会吃饭等 定义一个类1234class 类名称&#123; 属性名称; 返回值类型 方法名（）&#123;&#125;&#125; 类的定义 一个类要想真正的进行操作，则必须依靠对象，对象的定义格式如下 类名称 变量名 = new 类名称(); 封装 封装性是面向对象思想的三大特征之一 封装性就是隐藏实现细节，仅对外提供访问接口 封装有 属性封装 方法封装 类的封装 组件封装 模块化封装 封装的好处 模块化 信息隐藏 代码重用 插件化易于调试 具有安全性 如何封装1234567891011121314151617class Dog&#123; private String Name; private int age; public void setName(String name)&#123; this.Name = name; &#125; public String getName()&#123; return this.Name; &#125; public void setName(int age)&#123; this.age = age; &#125; public String getName()&#123; return this.age; &#125; &#125; 通过使用方法来获取和设置类的属性，而不是让直接操作属性值 在set方法中，我们还可以格式化传入的参数，改变其为我们想要的类型 构造方法 什么是构造方法？ 构造方法就是类构造对象时调用的方法，用于对象的初始化工作 构造方法是实例化一个类的对象时，也即是new的时候，最先调用的方法 构造方法的定义 构造方法是在类中定义的，构造方法的定义格式：方法名与类名相同，无返回参数类型 12345678910111213141516171819202122232425class Dog&#123; private String Name; private int age; // 无参构造函数 Dog()&#123; this(Name, age); &#125; // 带参构造函数 Dog(String Name, int age)&#123; this.setName(Name); this.setage(age); &#125; public void setName(String name)&#123; this.Name = name; &#125; public String getName()&#123; return this.Name; &#125; public void setName(int age)&#123; this.age = age; &#125; public String getName()&#123; return this.age; &#125;&#125; 注意事项 每个类默认会有一个无参构造函数 方法名与类名相同，无返回值 构造方法可以用来初始化属性 如果类中又带参的构造方法，那么需要默认的无参构造方法时必须显示的写出来 在构造方法中调用其他的构造方法使用 this(参数) 而且必须在第一句 值传递与引用传递 实例一，值传递 1234567891011public class ValueDemo&#123; public static void main(String[] agrs)&#123; int x=10; method(x); System.out.println("x=" + x); // 最后 x 等于 10 &#125; public static void method(int mx)&#123; mx = 20; &#125;&#125; 实例二，引用传递 1234567891011121314public class RefDemo1&#123; public static void main(String[] args)&#123; Weapon w = new Weapon(); method(w); System.out.println("weapon age = " + w.age); // 最后 w.age 等于 &#125; public static void method(Weapon w)&#123; w.age = 5l &#125;&#125;class Weapon &#123; int age = 2;// &#125; 如果是自定义的类，那么绝对是引用传递；如果是java自己封装的类，大多是值传递 正确的解释是，如果值在 栈 中，那么是值传递；如果值 在 堆中，那么是引用传递 static 关键字 static关键字的作用： 使用static关键字修饰一个属性 声明为static的变量实质上就是一个全局变量 使用static关键字修饰的一个方法 通常是 无需实例化对象就可以调用的方法 类名().方法名() 使用static关键字修饰一个类 普通类不能定义为static，内部类可以 注意 静态变量或方法属于类，而不是对象 所以调用静态变量或方法时直接使用类名调用，而不要用对象调用 静态变量在内存中只会保存一份，由这个类的所有对象共享 静态数据（变量和方法）在第一次使用时即载入内存，知道程序退出 静态方法不能调用非静态属性，反之可以使用（因为静态方法先于非静态属性，方法） 注意 声明为static的方法有以下几个限制 他们仅能调用其他的static方法 他们只能访问static数据 他们不能以任何方式引用this或super JDBC编程目前市面上数据库管理系统已经非常多，mysql，Oracle，SQLserver等等在ODBC出现之前，对这些数据库的访问是一件非常麻烦的事情，因为这些数据库虽然都支持sql，但他们针对自己数据库的访问方法，所以当用户访问不同个的数据库时，就必须使用不同API来编写相应的数据库访问程序 ODBC（Open Database Connectivity）通过ODBC访问不同的数据库，无需对数据库访问程序进行修改，这样ODBC的应用越来越广泛 JDBC（java data base connectivity）按照ODBC的模式来制定的，它是一个通用的底层的支持sql功能的Java API JDBC的组成JDBC提供了两种接口 JDBC API 面向开发人员的API JDBC Driver API 面向底层驱动程序开发商的API JDBC API JDBC API 是一系列的应用编程接口，可以用来进行数据库连接，访问数据等 JDBC API的主要编程接口： DriverManager 驱动程序管理类 用来装载驱动程序，并为创建数据库链接提供支持 Connection 是一个接口 用来连接某一个指定的数据库 Statement 是一个接口 提供了执行SQL语句，获取查询结果的方法 PreparedStatement 用于执行预编译的SQL语句 ResultSet 提供了对接口集进行处理的方法 JDBC Driver API主要有四种类型 JDBC-ODBC bridge 通过将JDBC的调用全部委托给其他编程接口来实现 部分java技术的本地API驱动程序 驱动程序部分实现通过JAVA语言 其他的部分则委托给本地的数据库的客户段代码来实现 全部基于java技术的本地API程序 这种驱动程序的实现全部通过Java语言 通常由某个中间件服务器提供 客户端程序可以使用数据库无关的协议和中间件服务器进行通信 中间件服务器再讲客户端的调用转发给服务器进行处理 全部基于java技术的本地协议驱动程序 全部基于java语言 包含了特定数据库的访问协议，使得客户端可以直接同服务器进行通信 使用JDBC进行增删改首先建表 修改Mysql-WorkBench快捷键 自动补全 ctrl+space 但是和Ubuntu的输入法切换冲突 修改/usr/share/mysql-workbench/data/main_menu.xml文件 modifier + Space 就是 Ctrl+space的意思，修改为不冲突的快捷键例如F2 或者 直接 菜单栏 edit-&gt;auto complete 启动自动补全 创建用户表 12345678use jsp_db;create table tbl_user( id int(11) unsigned not null auto_increment, name varchar(50) not null default &apos;&apos;, password varchar(50) not null default &apos;&apos;, email varchar(50) default &apos;&apos;, primary key(id) )engine=InnoDB default charset=utf8; 创建地址表 1234567CREATE TABLE tbl_address ( id INT(11) UNSIGNED not null auto_increment, city varchar(20) default null, country varchar(20) default null, user_id int(11) unsigned not null, primary key(id)) engine=InnoDB default charset = utf8; 表中插入记录 123456789insert into tbl_user(id,name,password,email)values(1, &apos;xiaoming&apos;, &apos;123456&apos;,&apos;xiaoming@qq.com&apos;),(2, &apos;xiaozhang&apos;, &apos;123456&apos;, &apos;xiaozhang@qq.com&apos;);insert into tbl_address(city, country, user_id)values(&apos;beijing&apos;, &apos;china&apos;, 1),(&apos;tianjin&apos;, &apos;china&apos;, 2); 查询初体验 JDBC执行流程 Eclise中 Alt+ ‘/‘ 可以进行生成函数 数据库查询 ​12345678910111213141516package com.JDBC.Test;import java.sql.DriverManager;import java.sql.Connection;import java.sql.ResultSet;import java.sql.Statement;import com.mysql.jdbc.Driver;public class JDBCTest &#123;​ public static void main(String[] args) &#123;​ String sql = &quot;select * from tbl_user&quot;;​ Connection connection = null;​ Statement statement = null;​ ResultSet resultSet = null;​ try { // 用于注册Mysql JDBC的驱动程序 // forName 方法用于初始化参数指定的类，并创建一个对应的实例对象 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 这里url 指定了 数据库的 地址 端口 以及具体访问的库名 String url = &quot;jdbc:mysql://localhost:3306/jsp_db&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; // 获取Mysql 数据库的连接 这里使用的是 DriverManage 的 getConnection 方法 connection = DriverManager.getConnection(url, user, password); // 创建一个Statement对象 statement = connection.createStatement(); // 使用Statement对象的executeQuery方法来发送Sql语句 // executeQuery 方法返回一个 ResultSet对象 resultSet = statement.executeQuery(sql); // 遍历ResultSet对象 while (resultSet.next()) { System.out.println(resultSet.getInt(&quot;id&quot;)); System.out.println(resultSet.getString(&quot;name&quot;)); System.out.println(resultSet.getString(&quot;password&quot;)); System.out.println(resultSet.getString(&quot;email&quot;)); } } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } finally { try { // 关闭ResultSet对象的结果集 resultSet.close(); } catch (Exception e2) { } try { // 关闭Statement对象 statement.close(); } catch (Exception e2) { } try { // 关闭数据库连接 connection.close(); } catch (Exception e2) { } } }1234&#125;​ 增删改查 首先写一个Connection的函数，这样执行就不用每次都写 那几条固定语句 12345678910111213141516public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 这里url 制定了 访问数据库的 地址 端口 以及 具体 库的名字 String url = &quot;jdbc:mysql://localhost:3306/jsp_db&quot;; String user = &quot;root&quot;; String password = &quot;root&quot;; // 获取Mysql 数据库的连接 这里使用的是 DriverManage 的 getConnection 方法 conn = DriverManager.getConnection(url, user, password); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return conn;&#125; 然后就是增删改的函数了 增 1234567891011121314151617181920public static void insert() &#123; Connection conn = getConnection(); try &#123; // 存储sql语句，用来向用户表中插入记录 String sql = &quot;insert into tbl_user(name,password,email)&quot; + &quot;values&quot; +&quot;(&apos;Tom&apos;, &apos;123456&apos;,&apos;Tom@qq.com&apos;),(&apos;Anny&apos;, &apos;123456&apos;, &apos;Anny@qq.com&apos;)&quot;; Statement st = conn.createStatement(); // Statement中的executeUpdate方法，可以执行DML语句，包括insert update 以及 delete // 也可以执行没有返回结果的语句 例如：DDL语句 // 参数是一个字符串形式的sql语句，如果执行的是DML语句，那么返回影响的记录条数，如果是DDL语句则返回0 // 会抛出sqlExcuption 以及 sqlTimeOut 的异常 int count = st.executeUpdate(sql); System.out.println(&quot;向表中插入了&quot; + count + &quot;条语句&quot;); conn.close(); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;&#125; 改 123456789101112131415161718public static void update() &#123; Connection conn = getConnection(); try &#123; // 存储sql语句，用来向用户表中插入记录 String sql = &quot;update tbl_user set email=&apos;Tomm@163.com&apos; where name = &apos;Tom&apos;&quot;; Statement st = conn.createStatement(); // Statement中的executeUpdate方法，可以执行DML语句，包括insert update 以及 delete // 也可以执行没有返回结果的语句 例如：DDL语句 // 参数是一个字符串形式的sql语句，如果执行的是DML语句，那么返回影响的记录条数，如果是DDL语句则返回0 // 会抛出sqlExcuption 以及 sqlTimeOut 的异常 int count = st.executeUpdate(sql); System.out.println(&quot;向表中更新了&quot; + count + &quot;条语句&quot;); conn.close(); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;&#125; 删 123456789101112131415161718public static void delete_db() &#123; Connection conn = getConnection(); try &#123; // 存储sql语句，用来向用户表中插入记录 String sql = &quot;delete from tbl_user where name=&apos;Tom&apos;&quot;; Statement st = conn.createStatement(); // Statement中的executeUpdate方法，可以执行DML语句，包括insert update 以及 delete // 也可以执行没有返回结果的语句 例如：DDL语句 // 参数是一个字符串形式的sql语句，如果执行的是DML语句，那么返回影响的记录条数，如果是DDL语句则返回0 // 会抛出sqlExcuption 以及 sqlTimeOut 的异常 int count = st.executeUpdate(sql); System.out.println(&quot;向表中删除了&quot; + count + &quot;条语句&quot;); conn.close(); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;&#125; 之后只需要在 main 函数中 调用inset 等 方法就 能插入 修改 删除了 需要注意的是，不要把sql语句写错 执行之后，控制台会输出修改的语句的个数 main方法 12345public static void main(String[] args) &#123; //insert(); //update(); delete_db();&#125; JDBC事务处理数据库是一个多用户使用的共享资源当多个用户使用数据库存取资源的时候，就会产生不同用户存取同一数据的情况因此需要控制并发 原子性 事务中包含的操作都被看做是一个逻辑单元 这个逻辑单元的操作 要么全部成功 要么全部失败 事务中所有元素作为一个整体，提交或回滚 事务的所有元素是不可分割的，是一个完整的操作 一致性 事务开始之前和事务结束以后，数据库都处于一致性状态 数据库的完整性约束，没有被破坏 隔离性 对数据库进行修改的多个事务，是彼此隔离的 事务必须是独立的，不应该以任何形式影响其他事务 持久性 事务完成之后，对于系统的影响是永久的 该修改真实的修改了数据库，即使系统出现故障也会一直保留 事务语句 开始事务 Begin transaction 提交事务 Commit transaction 回滚事务 Rollback transaction 举个例子：​ 我们有 user 和 address 表​ 在 address 表中 插入 Tom 的地址信息​ 在 user 表中 插入 id 为 1 的 Tom的个人信息 不难发现，由于user表中原来就有id 为 1 的信息，所以user表插入失败 但是，address 表却可以插入，因为没有主键冲突 这就是 完整性 缺失 代码实例​1public class TransAction &#123; public static Connection getConnection() { Connection conn = null; try { Class.forName(“com.mysql.jdbc.Driver”); String url = “jdbc:mysql://localhost:3306/jsp_db”; String user = “root”; String password = “root”; conn = DriverManager.getConnection(url, user, password); } catch (Exception e) { } return conn; }// 使用 throws SQLException 来捕获异常，因为如果数据插入失败的时候会抛出异常// 通过 这种方法 将异常传递给 上层函数 通过上层函数捕捉异常 进行回滚public static void insertUser(Connection conn) throws SQLException { String sql = “insert into tbl_user(name,password,email)” + &quot;values&quot; +&quot;(&apos;Tom&apos;, &apos;123456&apos;,&apos;Tom@qq.com&apos;),(&apos;Anny&apos;, &apos;123456&apos;, &apos;Anny@qq.com&apos;)&quot;; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println(&quot;向表中插入了&quot; + count + &quot;条语句&quot;); } public static void insertAddress(Connection conn) throws SQLException { String sql = “insert into tbl_address(id,city,country)” + &quot;values&quot; +&quot;(1, &apos;beijing&apos;,&apos;china&apos;),(2, &apos;tianjing&apos;, &apos;china&apos;)&quot;; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println(&quot;向表中插入了&quot; + count + &quot;条语句&quot;); } public static void main(String[] args) { Connection conn = null; try { conn = getConnection(); //关闭自动提交 conn.setAutoCommit(false); insertAddress(conn); insertUser(conn); conn.commit(); } catch (SQLException e) { System.out.println(&quot;=====偶哟，捕获到SQL异常了呢====&quot;); e.printStackTrace(); try { // 如果捕获到异常 那么说明数据插入失败，则要回滚到插入之前的状态 // 避免出现，部分插入，部分没插入 所导致的 完整性缺失问题 System.out.println(&quot;====现在开始数据回滚呢，请等会哦====&quot;); conn.rollback(); System.out.println(&quot;====回滚成功呢，请再看看是哪里的代码有问题呢====&quot;); } catch (Exception e2) { e2.printStackTrace(); } } finally { try { // 如果 conn 连接 不为空的时候，最后要关闭连接 if (conn != null) { conn.close(); } } catch (Exception e3) { e3.printStackTrace(); } } }123&#125;​ JDBC 优化前面的写法都是直接将 数据库链接，用户名，密码等直接内嵌到代码中但是这样的写法其实重用性特别差，一旦修改了密码那么所有的文件都需要修改 这个时候最好的方法就是写一个 配置文件，然后所有的数据链接都用这个配置文件这里 默认 配置文件的后缀是 .properties 1234driver=com.mysql.jdbc.Driverdburl=jdbc\:mysql\://localhost\:3306/jsp_dbuser=rootpassword=root 直接写上面的内容就行了 不需要上面花里胡哨的​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849​package com.JDBC.Test;​ import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.util.Properties;import com.mysql.jdbc.Driver;public class DataConnectFactory &#123; private static String driver; private static String dburl; private static String user; private static String password; private static final DataConnectFactory factory = new DataConnectFactory(); private Connection connection; static &#123; Properties prop = new Properties(); try &#123; InputStream in = DataConnectFactory.class.getResourceAsStream(&quot;dbconfig.properties&quot;); prop.load(in); &#125; catch (Exception e) &#123; System.out.println(&quot;==配置问价出错了呢==&quot;); &#125; driver = prop.getProperty(driver); dburl = prop.getProperty(dburl); password = prop.getProperty(password); user = prop.getProperty(user); &#125; //定义默认构造函数 private DataConnectFactory()&#123; &#125; // 单例模式 public static DataConnectFactory getInstance() &#123; return factory; &#125; public Connection makeConnection() &#123; try &#123; Class.forName(driver); connection = DriverManager.getConnection(dburl, user, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 这里使用了静态代码块 Java 上传下载 文件上传 文件上传的作用 上传照片 上传文档 上传简历 …… 文件上传对页面的要求 必须使用表单，而不是超链接 表单的method 必须是 POST，而不能是GET 表单的enctype 必须是 multipart/form-data; 在表单中添加file表单字段，即&lt;input typt=”file” name=”file” …/&gt; 12345&lt;form action="..." method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username" /&gt; 照 片：&lt;input type="file" name="picture" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 上传对Servlet限制 request.getParametere(“”)在表单为 enctype=”multipart/form-data”时作废，返回null 整个表单都不能用 调用 request.getInputStream(); 方法，返回 ServletInputStream，返回数据包含整个请求的体 多部件表单的体 每个分开的多个部件，即一个表单项一个部件 一个部件中有自己的请求头和空行，还有请求提 普通表单项： 一个头：Content-Disposition：包含name=”xxx”，即表达项名称 一个体：表单项的值 文件表单项： 两个头： Content-Disposition：包含name=”xxx”，表单项名称，还有一个filename，即上传文件的名称 Content-Type：它是上传文件的MIME类型，例如：image/pjpeg，….. Servlet写法12345678910protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub request.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=utf-8"); ServletInputStream in = request.getInputStream(); String s = IOUtils.toString(in); System.out.println(s);&#125; 这里的 IOUtils 是 commons-io.jar 包，你需要手动导入到路径中 这里的jar包，一定要放到lib 文件夹中，否则无效，我也不知道为啥 使用 commons-fileupload.jar 和 commons-io.jar 工具包 帮我们解析 request 中上传的数据 解析后的结果是一个表单项数据，封装到一个FileItem对象中 调用FileItem的方法即可获取数据 上传三步 相关类 工厂：DiskFileItemFactory 解析器：ServletFileUpload 表单项：FileItem 创建工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); 创建解析器 ServletFileUpload sfu = new ServletFileUpload(factory); 使用解析器来解析request，得到FileItem集合 List&lt;FileItem&gt; fileItemList = sfu.parseRequest(request); FileItem 的 API boolean isFormField() 是否为普通表单项 true 为普通表单项 false 文件表单项 String getFileName() 返回当前表单项的名称 String getString(String charset) 返回表单项的值（不适用于文件表单项） String getName() 返回上传的文件名称 long getSize() 返回上传文件的字节数 InputStream getInputStream() 返回对应文件的输入流 void write(File destFile) 将上传的文件内容保存到指定的文件中 如果文件存在，则替换文件 如果文件不存在，则创建文件 Servlet文件，注意这里导入的是 org.apache.commons.fileupload 包，并且io包和fileupload 包一定要放到WEB-INF 的lib中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package up;import java.io.File;import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.*;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;/** * Servlet implementation class upPic */@WebServlet("/upPic")public class upPic extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public upPic() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println("get"); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); /* *上传三步 *1. 得到工厂 *2. 通过工厂创建解析器 *3. 解析request，得到FileItem集合 *4. 遍历FileItem集合，调用其API */ DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload sfu = new ServletFileUpload(factory); try &#123; List&lt;FileItem&gt; fileItems = sfu.parseRequest(request); // 我们这里明确知道只有两个表单项，所有就不便利数组了 //FileItem fil1 = fileItems.get(0);// 普通表单项 FileItem fil2 = fileItems.get(1);// 上传的图片表单项 System.out.println("Content-Type : " + fil2.getContentType()); System.out.println("size : " + fil2.getSize()); System.out.println("filename : " + fil2.getName()); File picture = new File("/home/cong/picture.jpg"); fil2.write(picture); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125; jsp文件 12345678910111213141516&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="upPic" method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username" /&gt; 照 片：&lt;input type="file" name="picture" /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上传的细节 把上传的文件放到WEB-INF目录下 如果没有把用户的文件存放到WEB-INF目录下，那么用户可以通过浏览器直接访问上传的文件，这个是非常危险的 加入用户上传了一个a.jsp文件，再通过浏览器链接访问a.jsp，那么就会执行a.jsp，而如果jsp文件中有”shutdown -h now”，那么后果嘛 通常我们会在WEB-INF目录下创建一个uploads目录，来存放上传的文件，而在Servlet中找到这个目录需要使用ServletContext 的 getRealPath(String) 方法 ServletContext servletContext = this.getServletContext(); String savepath = servletContext.getRealPaht(“/WEB-INF/uploads”); 文件名称相关问题 有点浏览器上传的文件名是绝对路径，这需要切割 乱码问题，文件名乱码 request.serCharacterEncoding(“utf-8”) 上传文件同名问题 目录打散问题 一个目录不能存放过多文件 一般一个目录存放1000个文件就是上限 如果文件太多就会导致打开卡顿 打散方法很多： 按 日期 生成 文件夹 按 首字母 分 文件夹 上传的单个文件的大小限制 ServletFileUpload类的setFileSizeMax(long)就可以了 参数是上传文件的上限字节数 一旦文件超过上限就会抛出FileUploadBase.FileSizeLimitExceededException异常 缓存大小与临时目录 下载文件 下载就是向客户端响应字节数据 原来响应的都是HTML字符数据 现在响应字节数据 把一个文件变成字节数组，使用response的流(outputstream)响应给浏览器 下载的要求 两个头，一个流 头：响应头 流：字节流 头1：Content-Type： 你传递给客户端的文件是什么MIME类型 例如：image/pipeg 头2：Content-Disposition： 一般来说，如果不设置头，那么默认不弹出下载框 默认值为：inline，在浏览器窗口中打开，打不开就弹窗 修改为 “attachment;filename=***” 流：要下载的文件数据 Servlet代码演示 Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.upload.pic;import java.io.FileInputStream;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.swing.filechooser.FileNameExtensionFilter;import org.apache.tomcat.util.http.fileupload.IOUtils;/** * Servlet implementation class DownLoad */@WebServlet(&quot;/DownLoad&quot;)public class DownLoad extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public DownLoad() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println(&quot;get&quot;); /** * 两个头一个流 * 1. content-type * 2. content-dsidposition * 3. 下载文件的数据流 */ String wen_inf_path = getServletContext().getRealPath(&quot;/WEB-INF&quot;); String filename = &quot;3.Servlet获取到上传表单的数据.mp4&quot;; String filepath = wen_inf_path + &quot;/3.Servlet获取到上传表单的数据.mp4&quot;; filename = new String(filename.getBytes(&quot;GBK&quot;),&quot;ISO-8859-1&quot;); String contentType = this.getServletContext().getMimeType(filepath);//通过文件名称获取mime类型 String contentDisposition = &quot;attachment;filename=&quot; + filename;//带中文则乱码，最好是英文 System.out.println(filename); System.out.println(filepath); FileInputStream input = new FileInputStream(filepath); response.setHeader(&quot;Content-Type&quot;, contentType); response.setHeader(&quot;Content-Disposition&quot;, contentDisposition); // 获取绑定了客户端的流 ServletOutputStream output = response.getOutputStream(); IOUtils.copy(input, output); input.close(); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println(&quot;post&quot;); &#125;&#125; 下载的细节 显示在下载框中的中文名称会出现乱码 IE浏览器会出乱码 火狐会出现乱码 解决方案 使用浏览器的编码 Firefox 使用 Base64编码 其他大部分浏览器都是用 URL 编码 通用方案 filename = new String(filename.getBytes(“GBK”),”ISO-8859-1”); 虽然不懂为什么，但是就是有用 注意，上述代码中分 filepath 和 filename filepath 为 文件路径 不能 改变编码方式 filename 为 文件名称 可以 修改编码方式 发送Mail12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mail.send;import java.util.Properties;import javax.mail.Authenticator;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class SendMail &#123; public static void SendYourMail(String address) throws AddressException, MessagingException&#123; /** * 创建连接 */ Properties properties = new Properties(); properties.setProperty("mail.host", "smtp.163.com"); properties.setProperty("mail.smtp.auth", "true");// 制定验证为True 是否需要身份验证 properties.setProperty("mail.transport.protocol", "SMTP"); Authenticator auth = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication()&#123; return new PasswordAuthentication("SZMT_TEAM", "szmt317"); // 这个szmt317 不是我163的密码 而是我的 &#125; &#125;; Session session = Session.getInstance(properties, auth); // 编辑邮件 MimeMessage msg = new MimeMessage(session); msg.setFrom(new InternetAddress("SZMT_TEAM@163.com")); //设置发件人 msg.setRecipients(RecipientType.TO, address); //设置收件人，正常发送 msg.setRecipients(RecipientType.CC, address); //设置收件人，抄送（即再发送一份样的） msg.setRecipients(RecipientType.BCC, address); //设置收件人，暗送 msg.setSubject("测试，测试，测试"); // 邮件的标题 msg.setContent("你的验证码是 ****", "text/html;charset=utf-8"); //邮件内容 // 发送邮件 Transport.send(msg); System.out.println("发送成功"); &#125;&#125; 这里的问题就是 你的 163 邮箱需要开启服务 设置 客户端授权密码 上述的 Authenticator 中并不是我的163账户密码，而是授权密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#学习]]></title>
    <url>%2F2017%2F12%2F22%2FC%23%2F</url>
    <content type="text"><![CDATA[C数据类型整型 整型即整数 整型可以分为有符号和无符号整行 有符号整型 可以表示负数和正数 字节型 sbyte 短整型 short 整型 int 长整行 long 无符号整型 只能表示大于等于0的数 字节型 byte 短整型 ushort 整型 uint 长整型 ulong 有符号整型 整型 关键字 字节数 取值范围 字节型 sbyte 1 -128~127 短整型 short 2 -2^15~2^15-1 整型 int 4 -2^31~2^31-1 长整型 long 8 -2^63~2^63-1 无符号整型| 整型 | 关键字 | 字节数 | 取值范围 || :——: | :——–: | :——–: | :——: || 字节型 | byte | 1 | 0~255 || 短整型 | ushort | 2 | 0~2^16-1 || 整型 | uint | 4 | 0~2^32-1 || 长整型 | ulong | 8 | 0~2^64-1 | 浮点型 单精度浮点型 float 双精度浮点型 double 高精度 decimal 浮点型 关键字 字节数 单精度 float 4 双精度 double 8 高精度 decimal 16 布尔型 布尔型 bool 1字节 只有两个值 true false 字符型 字符型 char 两个字节 标识符 用来表示内存中的一个数据 一个由字符数据下划线和@符号组成的一个有序列 规则 只能由数字字母下划线和@符号组成 不能已数字开头 如果包含@，那么@必须放在首位 不能与关键字重名 1234567xiaoming 符合xiao_ming 符合xiaoming_9 符合_xiaoming 符合xiaoming@163符合1xiaoming 符合INT 符合 规范 望文知意 username 用户名 password 密码 ……这种 遵循驼峰命名法 如果一个标识符由多个单词组成，那么单词首字母都要大写 UserName UserID 如果一个标识符由多个单词组成，那么从第二个单词开始，后面的单词首字母大写 userName userID 默认使用小驼峰 补充 标识符的组成部分也可以是汉字或者部分中文字符 不推荐使用汉字 少使用@来作为标识符的一部分 变量与常亮 如果一个标识符所表示的数据，在程序运行的过程中是可以被修改的，那么这个数据就是变量 程序运行中不能被修改的就是常亮 12345678910111213using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsolApplication&#123; class Program&#123; static void Main(String[] args)&#123; Console.WriteLine(&quot;Hello World&quot;); &#125; &#125;&#125; using 表示应用命名空间 namespace 表示命名空间 class 代表一个类 代码语法变量声明变量123456789101112// 数据类型 标识符 int age;long time;bool flag = true;age = 10;time = 123412341234;// 数据类型 标识符 = 初始值int age = 10;double pi = 3.1315926535;// 声明多个变量int length, width, height;int length = 10, width = 10, height = 10; 常量 必须声明的同时赋初值 一旦声明，未来的代码中不能更改 123// const关键字声明常量// 修饰的常量不能更改且必须赋初值const int PI = 3.1415926535; 数据类型转换 数据类型转换并不是把一个变量的类型直接转换成其他的类型 是生命一个要转型的变量，然后将变量的值给这个新的类型的变量赋值 自动类型转换（隐式类型转换） 由数据范围小的数据类型转型为取值范围大的数据类型 1234// 自动类型转换的实例sbyte num0 = 10;int num1 = num0;// 自动完成不需要额外操作 强制类型转换（显式类型转换） 由数据范围大的数据类型转换为取值范围小的数据类型 long -&gt; int int -&gt; byte 1234// 强制类型转换int num2 = 1111;sbyte num3 = num2; // 此处会报错sbyte num3 = (sbyte)num2; // 加上要转换的类型，强制类型转换 sbyte 和 short 在参与运算的时候，会自动转成int型 123sbyte n1 = 10, n2 = 20;sbyte result = n1+n2; // 报错，因为上述的 sbyte 在参与运算的时候返回的是int型sbyte result = (sbyte)(n1 + n2); // 对]]></content>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习]]></title>
    <url>%2F2017%2F11%2F22%2FMyBatis%2F</url>
    <content type="text"><![CDATA[MyBatis MyBatis 不同与 Hiberanat MyBatis 比较轻 而 Hiberanat 比较重这里的 轻 代表的是 方便学习，开发，维护，简单 初识MyBatisMyBatis介绍历史iBATIS = “internet” + “abatis” 的组合是Apache公司的一个开源项目，这个项目是做软件加密的abatis 翻译过来是 路障，铁丝网的意思后来转型成为一个基于Java的持久层框架 持久层 Java中对象有两种状态 瞬态 持久态 瞬态 new 了一个对象 用完之后垃圾回收 对象中的属性状态没有保存 持久态 对象的状态属性保持住了 保存的方法又很多种 ：文件，数据库等 如果保存在数据库中，我们可以用JDBC来访问，操作 但是JDBC不是很方便，这样就产生了一种框架，叫做持久层框架 iBatis 后来改名为 MyBatis因为跳槽，从Apache 跳槽到 Google 再到 Github 特点 开源的优秀持久层框架 轻 SQL语句和代码分离 面向配置的编程（面向切片的编程） 增强程序的可维护性，可扩展性 良好支持复杂数据映射 使用JDBC我们会拼装SQL语句，这种语句并不安全，容易造成SQL注入 MyBatis 使用 动态SQL 技术，替换拼装SQL语句 MyBatis环境搭建下载MyBatis下载地址 解压压缩文件 其中mybatis-..*.jar 是 MyBatis 的主jar包 lib/ 文件夹是他的部分依赖包，毕竟曾经是Apache的项目 mybatis-..*.pdf 是 说明文档导入工程 导入 mybatis-..*.jar 包 导入 lib 中相关的 jar 导入 mysql 数据库 针对于 JDBC 的jar包 日志配置 为什么配置日志 -当我调试或者观察程序的时候，是通过输出的SQL语句看一下程序的执行状况 MyBatis 是通过 日志来完成的，所以要配置日志 加入日志配置文件log4.properties 改写日志输出级别为debug级别 MyBatis 在日志输出的时候，SQL语句一定实在debug级别才能输出 如果是inform级，则不输出 12345678910111213log4j.rootLogger=DEBUG, Console#Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%nlog4j.logger.java.sql.ResultSet=INFOlog4j.logger.org.apache=INFOlog4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG MyBatis工作流程工作流程的步骤 读取配置文件 读取的是基本配置文件 包含的是连数据库的相关信息 生成SqlSessionFactory Sqlsession的工厂，用于建立与数据库之间的会话 建立SqlSession 用于执行Sql语句 SqlSession 调用MyBatis提供的API 查询MAP配置 Map配置文件里面存放的是sql语句 返回结果 不同的sql语句返回不同的结果 关闭SqlSession 工作流程的配置文件 基本配置文件 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; # 一个environments 中有多个 environment &lt;environment id="development"&gt; # 一个environment 代表连接的一个数据库 里面的是数据库的信息 &lt;transactionManager type="JDBC"&gt; #事务由谁来管理 这里是JDBC管理 &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; #是否用连接池 或者 第三方child &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; #驱动 &lt;property name="url" value="jdbc:mysql://localhost:3306/jikebook"/&gt; #链接路径 &lt;property name="username" value="root"/&gt; # 用户名 &lt;property name="password" value="123"/&gt; # 密码 &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="jike/book/map/jikeUser.xml"/&gt; ＃ &lt;/mappers&gt;&lt;/configuration&gt; 包含着连数据库的基本信息 链接数据库的信息 就是环境，封装的就是连数据库的信息 map配置文件的数据位置 映射map配置文件的路径信息 map配置文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="/"&gt; &lt;select id="findById" parameterType="int" resultType="jike.book.pojo.JiKeUser"&gt; select * from jikeUser where id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; SqlSessionFactory, SqlSession SqlSessionFactory代表着跟数据库之间的连接 连上去之后自然要进行各种各样的操作 各种各样的操作是由SqlSession去执行的 SqlSession是由SQLSessionFactory来建立的 生命周期 SqlSessionFactory的生命周期是程序级的 一般一个MyBatis程序只有一个SqlSessionFactory 程序开始的时候建立，结束的时候才会消亡 SqlSession 是过程级的 比如在一个方法当中会建立一个SqlSession，执行完后SqlSession就应该关闭了 建立的代码 1234 SqlSessionFactory sqlMapper = new SqlSessionFactoryBuilder().build(reader);# reader 是一个输入流，是基本配置文件的路径的流SqlSession session = sqlMapper.openSession(); Map文件基本配置文件引用map文件 相对路径引用 1234&lt;mappers&gt; &lt;mapper resource="test/book/map/TestUser.xml"/&gt;&lt;/mappers&gt; 绝对路径引用 1234&lt;mappers&gt; &lt;mapper url="file:///var/sqlmaps/AuthorMapper.xml" /&gt;&lt;/mappers&gt; 包路径引用12&lt;package name="com.Test.mybatis.mapperinterface" /&gt; 什么是map文件1234&lt;select id="findById" parameterType="int" resultType="Test.book.pojo.TestUser"&gt; select * from TestUser where id=#&#123;id&#125;&lt;/select&gt; 上述标签中的id，这是找到这个sql语句的标示 上述标签中的parameterType是参数类型 上述标签中的resultType指的是返回类型 上述的sql语句中id = #{id}，’#’后面的内容代表一个参数 看实战，学操作，我有知识我自豪建立数据库123456789101112131415create database jikebook;use jikebook;create table jikeUser( id int not null auto_increment, userName varchar(20) , password varchar(20) , primary key(id))engine=InnoDB default charset=utf8;insert into jikeUser(id, userName, password)values(1, 'hello world', ''); 查询代码123TestUser temp = session.selectOne("findById", 1); # 第一个参数是map配置中的id，第二个参数是 mysql数据库中 的idSystem.out.println("name = " + temp.getUseName()); jikeUser.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test.book.map"&gt; &lt;select id="findById" parameterType="int" resultType="test.book.pojo.TestUser"&gt; select * from jikeUser where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; MyBatisConfig.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/jikebook"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="test/book/map/jikeUser.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; TestUser.java 123456789101112131415161718192021222324252627package test.book.pojo;public class TestUser &#123; private int id; private String userName; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; MainTest.java 12345678910111213141516171819202122232425262728293031323334package test.book.pojo;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String reource = "test/book/map/MyBatisConfig.xml"; Reader reader = null; SqlSession session; try &#123; reader = Resources.getResourceAsReader(reource); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); session.rollback();//回滚 &#125; System.out.println("111"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); System.out.println("222"); session =sqlSessionFactory.openSession(); TestUser temp = session.selectOne("findById", 1); System.out.println(temp.getUserName()); &#125;&#125; MyBatis 基础操作增删改 影响行数 insert1234&lt;insert id="insertUser" parameterType="TestUser" statementType="PREPARED" keyProperty="id" useGeneratedKeys="true"&gt; insert into JikeUser (userName, password) values (#&#123;userName, jdbcType=VARCHAR&#125;, #&#123;password, jdbcType=VARCHAR&#125;)&lt;/insert&gt; 上述代码中 StatementType=”PERPARED” 代表这是一个 预处理的SQL语句 parameterType=”TestUser” 代表传入的类 这里传入的应该是一个全路径名称，即com.jike.book.JikeUser 这里使用了typeAliases 标记 来定义了别名 简化了代码的书写 keyProperty 代表 哪一个 参数 是主键 上一个大类中完成的基本配置中加上 1234&lt;typeAliases&gt; &lt;typeAlias alias="TestUser" type="test.book.pojo.TestUser" /&gt;&lt;/typeAliases&gt; 着重强调！！！着重强调！！！着重强调！！！ Alias要写在environments前面，先定义别名，在配置环境，否则会报错 切记 切记 下面介绍代码 TestUser类依旧不变 MainTest类修改 1234567891011121314151617181920212223242526272829303132333435363738394041package test.book.pojo;import java.io.IOException;import java.io.Reader;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String reource = "test/book/map/MyBatisConfig.xml"; Reader reader = null; SqlSession session; try &#123; reader = Resources.getResourceAsReader(reource); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); session =sqlSessionFactory.openSession(); try &#123; TestUser testUser = new TestUser(); testUser.setUserName("laoziniubi"); testUser.setPassword("123456"); session.insert("insertUser", testUser); session.commit();//提交sql语句 &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚 &#125;finally &#123; session.close(); &#125; &#125;&#125; jikeUser.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test.book.map"&gt; &lt;select id="findById" parameterType="int" resultType="test.book.pojo.TestUser"&gt; select * from jikeUser where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="TestUser" statementType="PREPARED" keyProperty="id" useGeneratedKeys="true"&gt; insert into jikeUser (userName, password) values (#&#123;userName&#125;, #&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; MyBatisConfig.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias="TestUser" type="test.book.pojo.TestUser" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/jikebook"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="test/book/map/jikeUser.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Update1234&lt;update id="updateUser" parameterType="TestUser"&gt; update jikeUser set userName=#&#123;userName, jdbcType=VARCHAR&#125;,password=#&#123;password,jdbcType=VARCHAR&#125; where id=#&#123;id,jdbcType=INTEGER&#125;&lt;/update&gt; 上述代码中 parameterType 仍然利用别名 jdbcType 是 MyBatis 中 自动类型转换的一种设定 java当中的数据类型 和 数据库当中的数据类型需要一个转换 这种转换 往往是自动完成的，但当不能自动转换的时候，就需要进行手动转换 下面介绍代码 就不介绍xml了，和之前一样，就加上 update 标签就行了 写一下调试代码 1234567891011121314try &#123; TestUser testUser = new TestUser(); testUser.setUserName("laoziniubi"); testUser.setPassword("666666"); testUser.setId(2); session.update("updateUser", testUser); session.commit();//提交sql语句&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; delete(使用注解方式) 在map.xml的包中新建一个interface接口，名为JikeUserMapInterface 123456789package test.book.map;import org.apache.ibatis.annotations.Delete;public interface JikeUserMapInterface &#123; @Delete("delete from jikeUser where id=#&#123;id&#125;") public void deleteUder(int id);&#125; 在基本配置文件的mapper 标签中添加 12345&lt;mappers&gt; &lt;mapper resource="test/book/map/jikeUser.xml" /&gt; &lt;mapper class="test.book.map.JikeUserMapInterface" /&gt;&lt;/mappers&gt; 在TestMain调试文件中 1234567891011try &#123; JikeUserMapInterface jkumi = session.getMapper(JikeUserMapInterface.class); jkumi.deleteUder(1);//删除id为1的记录 session.commit();//提交sql语句&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; 查询 返回集合 Select 参数 如何操作 如何得到结果集12&lt;select id="selectPerson" parameterType="int" parameterMap="hashmap" resultType="hashmap" resultMap="personResultMap" flushCache="false" userCache="true" timeout="10000" fetchSize="256"&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句 parameterType 将会传入这条语句的参数类的完全限定名或类名 parameterMap 这是引用外部parameterMap的已经被废弃的方法。使用内敛参数映射和parameterType属性 resultType 从这条语句中返回的期望类型的类和完全限定名或别名。注意集合情形，那应该是集合可以包含的类型，而不能是集合。使用resultType或resultMa，但不能同时使用 resultMap 命名引用外部的resultMap。返回map是MyBatis最具力量的特性，对其有一个很好的理解的话，许多复杂映射的清醒就能被解决了。 flushCache 将其设为true，不能语句什么时候被调用，都会导致缓存被清空。默认值为false userCache 将其设置为true，将会导致本条语句的结果被缓存。默认值为false timeout 设置驱动程序等待数据库返回请求结果，并抛出异常时间的最大值。默认值不设定，驱动自行处理 fetchSize 这是暗示驱动程序每次批量返回的结果函数。默认值不设置，程序自行控制 statementType STATEMENT，PREPARED或CALLABLE的一种。这会让MyBatis选择使用Statement,PreparedStatement或Callable 的一种 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE,SCROLL_INSTENSITIVE中的一种。默认是不设置，驱动自行处理 parameterType封装：hashmap 123&lt;select id="loginSelect" resultType="TestUser" parameterType="hashmap"&gt; select * from jikeUser where userName=#&#123;userName&#125; and password=#&#123;password&#125;&lt;/select&gt; 老样子 把上述代码放在map.xml文件中 测试 123HashMap(String, String) hm = new HashMap();hm.put("userName", "laoziniubi");hm.put("password", "666666"); 上述的 “userName” 和 “password” 不仅是map的键，同时是 上述 select 标签中传入的参数名称 调用session 方法传入 hashmap TestUser ontemp = session.selectOne(“loginSelect”, hm); 调试代码 (使用hashmap) 1234567891011121314try &#123; HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put("userName", "laoziniubi"); hm.put("password","666666"); TestUser testUser = session.selectOne("loginSelect",hm); if (testUser != null) &#123; System.out.println(testUser.getUserName() + " 欢迎回来"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; 调试代码 (使用对象) 对象参数自动匹配属性 如果对象属性与列名不一样用别名 这里 要修改xml文件的select标签 1234&lt;select id="login2" resultType="TestUser" parameterType="TestUser" &gt; select * from jikeUser where userName=#&#123;userName&#125; and password=#&#123;password&#125;&lt;/select&gt; 然后是TestMain 123456789101112131415try &#123; TestUser testUser = new TestUser(); testUser.setUserName("laoziniubi"); testUser.setPassword("666666"); TestUser getone = session.selectOne("login2", testUser); if (getone != null) &#123; System.out.println(getone.getUserName() + " 欢迎回来"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; 返回多个查询 上述只是返回一个对象的情况，如果是返回多个对象呢？ MyBatis会返回一个list 1234&lt;select id="selectTestUserList" resultType="TestUser"&gt; select * from jikeUser &lt;/select&gt; 测试函数中调用List 来接受list123456789101112try &#123; List&lt;TestUser&gt; ap = session.selectList("selectTestUserList"); for (TestUser testUser : ap) &#123; System.out.println(testUser.getUserName() + " 欢迎回来"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; resultType 与 resultMap resultType 与 resultMap 一样用于返回结果操作 但是，resultType 与 resultMap 只能用其中一个 区别是 resultMap 中可以解决一些比较复杂的映射问题 例如：一个对象含有另一个对象的引用 12345&lt;resultMap id = "TestUserMap" type= "TestUser"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="userName" column="userName" /&gt; &lt;result property="password" column="password" /&gt;&lt;/resultMap&gt; 上述中，如果类中的参数名与数据库中的参数名不一致的时候，可以使用resultMap来改变映射关系 使用resultMap 123&lt;select id="selectUsers" resultMap="TestUserMap"&gt; select id,userName,password from jikeUser&lt;/select&gt; 上述代码中，resultMap 指明了使用 哪个resultMap 会按照resultMap的设定来返回对应的值 TestMain中的测试代码 123456789101112try &#123; List&lt;TestUser&gt; ap = session.selectList("selectUsers"); for (TestUser testUser : ap) &#123; System.out.println(testUser.getUserName() + " 欢迎回来"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback();//回滚&#125;finally &#123; session.close();&#125; ###事物处理 事务处理配置 MyBatis的事务处理又两个选项 JDBC JDBC代表的事 务处理由JDBC完成 MANAGED MANAGED代表的事务处理由第三方的一些插件完成，例如Spring 事务处理的配置写在基本配置文件当中 在基本配置文件当中（就是那个调用map.xml的xml文件啦）有个 transactionManager 标签，tpye属性当中就是上述的JDBC或者MANAGED 事务处理方法 MyBatis JDBC事务管理（典型代码） 关闭自动提交1234567891011try&#123; session = sqlMapper.openSession(false); // 关闭自动提交 操作 balabalbala..... session.commit();// 提交事务 &#125;catch(Exception e)&#123; session.rollback();//回滚&#125;finally&#123; session.close(); //关闭session&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F11%2F20%2FAjax%2F</url>
    <content type="text"><![CDATA[什么是Ajax允许浏览器与服务器通信而无须刷新当前页面的技术都叫Ajax 异步的Js和XML的通信 不用刷新整个页面就可以与服务器通讯的方法1. Flash 2. Java appleet 3. 框架：如果使用一组框架构造了网页，可以只更新其中一个框架，而不用惊动整个页面 4. 隐藏的iframe 5. XMLHttpRequest:该对象是对JavaScript的一个扩展，可使网页与服务器进行通信。 是创建Ajax应用的最佳选择，实际上通常把Ajax当成XMLHttpRequest对象的代名词 Ajax工具包Ajax并不是一项新技术，它实际上是几种技术，每种技术各尽其职，以一种全新的方式聚合在一起： 1. 服务器端语言：服务器必须具备向浏览器发送特定信息的能力。Ajax与服务器语言无关 2. XMLL:Ajax程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML是其中一种选择 3. XHTML：使用扩展HTML和CSS标准化呈现 4. DOM：实现动态交互和显示 5. 使用Javascript绑定和处理所有数据 6. 使用XMLHTTP组件XMLHttpRequests对象进行异步数据读取 Ajax的缺陷1. 由JavaScript和Ajax引擎会导致引擎的兼容性问题（现在少） 2. 页面局部刷新，导致 后退功能不好用 3. 对流媒体的支持没有Flash和JavaApple好 4. 一些手持设备支持性差（现在少） XMLHttpRequest创建XMLHttpRequest对象function getHTTPObject(){ var xhr = false; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); } else if(window.ActiveXObject()){ xhr = new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); } return xhr; } 大多数浏览器都支持 var xmlhttp = new XMLHttpRequest() IE6.0： var xmlhttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;) IE5.5及更早版本的IE： var xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 对window.XMLHttpRequest的调用会返回一个对象或null，如果XMLHttpRequest对象存在，啧把xhr的值设为该对象的新实例 属性以下用于发送： abort()停止当前请求 getAllResponseHeader() 把HTTP请求的所有响应首部作为键值对返回 getResponseHeader(“header”); 返回指定首部的串值 open(“method”,”url”,bool);建立对服务器的调用，Method参数可以是put或post，url可以是相对url也可以是绝对url, 请求是否为异步请求 send(content) 向服务器发送请求，没有为null，最好send里面有东西（就算是null） setRequestHeader(“header”,”value”);设置首部及其值，在设置任何首部之前必须先调用open() 以下用于请求： onreadystatechange 每个状态改变的是都会出发这个事件处理器，通常会条用一个JavaScript函数 readyState 请求的状态，有五个可取值：0=未初始化，1=正在加载，2=已经加载，3=交互中，4=完成 responseText 服务器的响应，表示为一个串 responseXML 服务器的响应，表示为XML，这个对象可以解析为Dom对象 status 服务器的HTTP状态码 statusText HTTP状态码对应的文本（OK或NotFount等） 一个简单的案例目标，不刷新，不跳转界面，只alert 出 a.xml &lt;script&gt; window.onload = funtion(){ //获取a节点 document.getElementByTagName(&quot;a&quot;)[0].onclick = function(){ // 创建一个XMLHttpRequest对象 var request = new XMLHttpRequest(); // 准备发送请求的数据：url加上时间戳 var url = this.href + &quot;?time=&quot;+new Date(); var method = &quot;GET&quot;; // 调用XMLHttpRequest 对象的open方法 request.open(method, url); // 调用XMLHttpRequest 对象的send方法 request.send(null); // 为 XMLHttpRequest 对象添加onreadystatechange // 判断响应是否完成：XMLHttpRequest对象的readyState属性为4的时候 // 再判断响应是否可用：XMLHttpReqeust对象status属性值为200 request.onreadystaechange = function(){ if(request.readyState == 4){ if(request.status == 200 || request.status == 304) alert(request.responseText); } } //返回false，取消原有功能，也就是说返回false后，不会跳转页面 return false; } } &lt;/script&gt; &lt;html&gt; &lt;a href=&quot;a.xml&quot;&gt;跳转&lt;/a&gt; &lt;/html&gt; 发送请求 利用XMLHttpRequest实例与服务器进行通信包含一下三个关键部分： onreadystatechange 事件处理函数 open 方法 send 方法 onreadystatechange该事件处理函数由服务器出发，而不是用户 在Ajax执行过程中，服务器会通知客户端当前的通信状态 这依靠更新XMLhttpRequest对象的readyState来实现 改变readyState属性是服务器对客户端连续操作的一种方式 每次readyState属性的改变都会触发readystatechange事件 open(methdo, url, asynch) XMlHttpRequest对象的open方法允许程序员用一个Ajax调用向服务器发送请求 method：请求类型，类似“GET”或“POST”的字符串。 在某些情况下，有些浏览器会把多个XMLHttpRequest请求的结果缓存到用一个URL， 如果每个请求的相应不同，但是得到的结果却会一样。所以此时加一个 时间戳 到url最后，以确保url的唯一性 url：路径字符串，指向你所请求的服务器上的那个文件，可以是绝对路径，也可以是相对路径 asynch：表示是否要异步传输，默认是true send(data) open方法定义了Ajax请求的一些细节，send方法可以为已经待命的请求发送指令 data：将要发送给服务器的字符串 若用”GET”请求，则不用发任何数据，即request.send(null); 当向send()方法提供参数时，要确保open()中指定的方法是”POST”,如果没有数据发送，则使用null setRequestHeader(header, value) 当浏览器向服务器请求页面时，它会伴随这个请求发送一组首部信息，当这些首部信息是一系列描述请求的元数据（metadata）。首部信息来声明一个请求时get还是post Ajax请求中，发送首部信息的工作可以是由setRequestHeader完成 参数header:首部的名字；参数value:首部的值 如果用POST请求向服务器发送数据，需要将 “Content-type”的首部设置为 “application/x-www-form-urlencoded”。 他会告知服务器正在发送数据，并且数据已经符合url编码了 该方法必须在open()之后才能调用 post示例12345var url = "../jsp/forumServlet";var nameValue = trim(document.forumiddform.name.value);xhr.open("POST", url);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send("method=name_isExist" + "&amp;name" + nameValue); 接收响应readyState readyState 属性表示Ajax请求的当前状态 0代表未初始化，没调用open方法 1代表正在加载，open()调用了而send()没有调用 2代表send()调用了，请求开始 3代表交互中，服务器正在发送响应 4代表完成 readyState值的变化会出发 readystatechange 事件，如果把onreadystaechange事件赋给函数，则每次变换调用函数 readyState的值因浏览器不同有所差异，但是请求结束时，每个浏览器都会把 readyState 的值设为 4 status服务器发送的每一个响应也都有首部信息 常用的状态码及其意义： 1. 404 没有页面 2. 403 禁止访问 3. 500 内部服务器错误 4. 200 一切正常 5. 304 没有被修改 在 XMLHttpRequest 对象中，服务器发送的状态码都保存在status属性中。 responseTextXMLHttpRequest 的 responseText 属性包含了从服务器发送的数据。它是一个HTML，xml或普通文本 当 readyState 属性值变成 4 时，responseText 属性才可以用，表明Ajax请求已经结束 数据格式在服务器端Ajax时一门与语言无关的技术，在业务逻辑层使用何种服务器端语言都可以 从服务器端接收数据的时候，那些数据必须以浏览器能够理解的格式来发送。服务器端的编程语言只能以如下三种格式返回数据： 1. XML 2. JSON 3. HTML 解析HTMLHTML由一些普通文本组成，如果服务器通过XMLHttpRequest发送HTML，文本将存储在responseText属性中 不必从responseText属性中读取数据。他已经是希望的格式，可以直接将它插入到页面中 插入HTML代码最简单的方法是更新这个元素的innerHTML属性 例如1document.getElementById(&quot;id&quot;).innerHTML = request.responseText; 优点1. 从服务器端发送的HTML代码在浏览器端不需要用Javascript解析 2. HTML的可读性好 3. HTML代码块与innerHTML 属性搭配，效率高 缺点1. 如需要通过Ajax更新一篇文档的多个部分，HTML不合适 2. innnerHTML并非DOM标准（问题不大，现在浏览器大都兼容） XML1. 需要进行解析，之后再插入到HTML中 2. 获得的 responseHTML 不能直接使用，必须先创建对应的节点作为容器 result = request.responseXML; 3. xml可以使用DOM的方式进行解析 var name = result.getElementsByTagName(&quot;key&quot;)[0].firstChild.nodeValue; var aNode = document.createElement(&quot;a&quot;);//创建a标签 aNode.appendChild(document.createTextNode(name)); aNode.href = &quot;url&quot;; 优点1. XMl是一种通用的数据格式 2. 不必把数据强加到以定义好的格式中，而是要为数据自定义合适的标记 3. 利用DOM可以完全掌控文档 缺点1. 当浏览器接收到长的XML文件后，DOM解析可能会很复杂 2. 如果文档来于服务器，就必须得到保证文档含有正确的首部信息。若文档类型不正确，那么responseXML的值将是空的 JSON 一种简单那的数据格式，比XML更轻巧。 SON是JavaScript原生格式，这意味着JavaScript中处理JSON数据必须要任何特殊的API 或 工具包 JSON的规则很简单：对象是一个无序的” ‘名称/值’对 “的集合。 一个对象以”{“ 开始， “}”结束。每个“名称” 后跟一个 “:”冒号；“’名称/值’对”之间使用 “,” 逗号分隔 Json用冒号来赋值 赋值语句用逗号分开 整个对象用大括号封装 可用大括号分装嵌套数据 对象描述中存储的数据可以是字符串，数字，布尔值，甚至函数方法 12345678910var jsonObjec = &#123; "name" : "test", "age":12, "address":&#123;"city":"wuhan", "contury":"chind"&#125; "teaching" : function () &#123; alert("this is a funtion"); &#125;&#125;;alert(jsonObjec.name);jsonObjec.teaching(); 其实嘛，json可以用jar包打包，不用自己写 字符串转为json对象 Json保存在responseText中 需要借助JavaScript的eval语句 函数eval会把一个字符串当做它的参数，然后这个字符串会被当做JavaScript代码来执行 var JsonResponse = xmlHttp.responseText; var personJson = eval(“(“ + JsonResponse + “)”); 上述的 左括号和右括号 一定要加 Json 提供了json.js 包，下载http://www.json.org/json.js 后，使用parseJSON()方法将字符串解析 var JsonResponse = xmlHttp.responseText; personJson = JsonResponse.parseJSON(); 看实战学操作发送post请求，判断账户名是否存在如果发送请求时带有参数，一般都用post请求 请求头有个 默认值 是 Content-Type: application/x-www-form-urlencoded open : xmlHttp.open(“post”, …..); 添加一步：设置Content-Type请求头： xmlHttp.setRequeestHeader(“Conten-Type”,”application/x-www-form-urlencoded”); send : xmlHttp.send(“username=zhanshan&amp;password=123”); JSP的写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%-- User: cong Date: 18-11-22 Time: 下午3:48 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.0.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form method="post" action=""&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type="text" id="username" name="username" /&gt;&lt;span id="can1" style="color: red" &gt;&lt;/span&gt; &lt;br&gt; &lt;span&gt;密 码：&lt;/span&gt;&lt;input type="password" id="password" name="username"/&gt; &lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; window.onload = function () &#123; var username = document.getElementById("username"); function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest(); &#125; catch (e) &#123; try &#123; return new ActiveXObject("Msxm12.XMLHTTP"); &#125; catch (e) &#123; try &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e) &#123; alert("浏览器太几把差了"); throw e; &#125; &#125; &#125; &#125; username.onblur = function() &#123; // 当失去焦点的时候 触发函数 // 获取异步对象 var xmlHttp = createXMLHttpRequest(); // 打开链接 xmlHttp.open("post", "Exist", true); // 设置请求头 xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // 发送请求 给出请求体 xmlHttp.send("username=" + username.value); // 给xmlHttp的onreadystatechange事件注册监听 xmlHttp.onreadystatechange = function () &#123; if (xmlHttp.readyState === 4) &#123; if (xmlHttp.status === 200)&#123; // 4 代表 运行完成 200 代表状态码 var text = xmlHttp.responseText; var can1 = document.getElementById("can1"); if (text == "1") &#123; can1.innerHTML = "用户名已存在" &#125; else &#123; can1.innerHTML = ""; &#125; &#125; else&#123; alert("false"); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/html&gt; Servlet写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ajax.test;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class Exist */@WebServlet("/Exist")public class Exist extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Exist() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub // response.getWriter().append("Served at: ").append(request.getContextPath()); System.out.println("get"); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub // doGet(request, response); System.out.println("post"); request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charaset=utf-8"); String username = request.getParameter("username"); if(username.equalsIgnoreCase("lc")) &#123; response.getWriter().print("1"); System.out.println("1"); &#125;else &#123; response.getWriter().print("0"); System.out.println("0"); &#125; &#125;&#125; 响应内容为XML 首先就要设置响应头 服务器端： Contentype 设置为 text/xml;charset=utf-8 客户端： var doc = xmlHttp.responseXML; //得到的是Documented对象 获取服务器的响应结果 使用dom运用 JQuery的Ajax jQuery对Ajax操作进行了封装 在jQuery中最底层的方式是 $.ajax() 第二层是load()，$.get() 和 $.post() 第三层是$.getScript()和$.getJSON() ajax 方法（底层接口） $.ajax(url,setttring) url 参数地址 setttring 例如下面（包括大括号都是） {type:’post’, data : {id : 1, name : “test”} ,beforeSend:function(xhr){},success:function (data){},error(xhr){},conplete:function(){}} data 为 服务端的响应体 success 为 响应成功的时候的回调函数 其中 data 的数据类型 会通过 服务端的 设置 自动转换 data 为 传递参数 post 通过请求体传递 get 通过 url 传递 通过设置dataType 设置 返回的参数类型 error 请求不正常(状态码不为200)的时候执行的函数 complete 请求完成(readystatus 到达 4 )时执行的回调函数 beforeSend 在 执行 xmlHtpp.open 之前调用的回调函数 setting 还有其他参数 放在下面的链接里面咯 jQuery.Ajax 其实嘛 你也可以吧 url 放入 setting 里面 为什么使用jQuery呢在访问一个不存在的页面时 会返回一个404页面 如果用原生js 返回的是一个404页面代码 即 一串 html 代码 如果是jQuery 返回空 load方法 load() 载入远程HTML文件代码并插入至DOM中 load(url,[data],[callback]); url 待装入HTML网页的网址，必须是JSON格式，一旦url不为空，那么请求方式就默认改为POST data（可选） 发送至服务器的 key/value 数据，在jQuery1.3中也可以接受一个字符串 callback（可选）载入成功时回调函数 如果只需要加载目标HTML网页内的某些元素，则可以通过load()方法的URL参数来达到目的 通过URL参数制定选择符就可以方便的从加载过来的HTML文档中挑选内容 语法结构是 “url selector”(注意：url 和 选择器 中间有个空格) 如果返回的是&lt;h2&gt;文本1&lt;/h2&gt;&lt;h3&gt;文本2&lt;/h3&gt; 如果url 后面 加上 “ h2” ，那么就只会得到 h2 部分 传递方式： load()方法的传递参数根据参数data来自动自定 如果没有参数传递，采用GET方式传递，否则POST 对于必须在加载完才能继续的操作，load()方法提供了回调函数 该回调函数有三个参数 data 代表请求返回内容 textStatus 代表请求状态 XMLHttpRequest 代表请求状态 任何一个节点都可以使用load()方法来加载Ajax，结果直接插入到html节点中 get和post 方法 $.get() （或$.post()）方法 $.get() 方法使用GET方式来进行异步请求 它的结构是 $.get(url, [data], [callback], [type]); url，String类型，请求HTML页面的URL地址 data，Object类型，发送到服务器的key/value数据会作为Query/String附加到URL中 callback， function类型，载入成功时的回调函数 type，String类型，服务器返回内容的格式，包括xml,html,script,json等 $.get()方法的回调函数只有两个参数 data， 代表返回的内容，可以是一个XML文档，JSON文件，HTMl片段等 textstatus代表请求状态，其值可能是 succuss error notmodify timeout $.get()和$.post()方法是jQuery中的全局函数，而find()等方法都是对jQuery对象进行操作的方法 12345678910111213var url = this.href;var args= &#123;"time" : new Date()&#125;;$.post(url, args, function(data)&#123; var name = $(data).find("name").text(); var email = $(data).find("email").text(); var website = $(data).find("website").text();&#125;, "JSON");$.getJSON(url, args, function(data)&#123; // 这里直接通过getJSON 将 data 转为JSON格式 var name = data.person.name; var email = data.person.email; var website = data.person.website;&#125;); Ajax的全局事件 所谓全局事件，就是在所有ajax调用的时候，都会执行的事件 例如：我有一个请求开始的动画，我整个页面写了100个Ajax 有一天 我想把所有的动画全部改了 我要改100个 全局事件就是用在这个地方的 .ajaxComplete() 当Ajax请求完成后注册一个回调函数。这是一个 AjaxEvent。 Ajax &gt; 全局 Ajax 事件处理器 .ajaxError() Ajax请求出错时注册一个回调处理函数，这是一个 Ajax Event。 Ajax &gt; 全局 Ajax 事件处理器 .ajaxSend() 在Ajax请求发送之前绑定一个要执行的函数，这是一个 Ajax Event. Ajax &gt; 全局 Ajax 事件处理器 .ajaxStart() 在AJAX 请求刚开始时执行一个处理函数。 这是一个 Ajax Event. Ajax &gt; 全局 Ajax 事件处理器 .ajaxStop() 在AJAX 请求完成时执行一个处理函数。 这是一个 Ajax Event。 Ajax &gt; 全局 Ajax 事件处理器 .ajaxSuccess() 绑定一个函数当 Ajax 请求成功完成时执行。 这是一个Ajax Event. 123$(document).ajaxComplete(function() &#123; $( ".log" ).text( "Triggered ajaxComplete handler." );&#125;); jQuery + Servlet实现 验证用户名是否存在 HTML 写法 1234567891011121314151617181920212223242526272829303132&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;检查用户名是否注册&lt;/title&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/JS/jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("#usernmae").change(function()&#123;//当value值改变时触发函数 var val = $(this).val();//获取值 val = $.trim(val);//去除前后的空格 if(val != "")&#123; var url = "$&#123;pageContext.request.contextPath&#125;/Exist"; var args = &#123;"username" : val, "time":new Date()&#125;; $.post(url, args, function(data)&#123; $("#message").html(data); &#125;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;link &gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; UserName:&lt;input type="text" id="usernmae" /&gt;&lt;span id="message" style="color:red;"&gt;&lt;/span&gt; &lt;br/&gt;&lt;input type="submit" value="submit" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Servlet写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.ajax.test;import java.io.IOException;import java.util.Arrays;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class Exist */@WebServlet(&quot;/Exist&quot;)public class Exist extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Exist() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println(&quot;get&quot;); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println(&quot;post&quot;); String username = request.getParameter(&quot;username&quot;); List&lt;String&gt; userNames = Arrays.asList(&quot;AAA&quot;,&quot;BBB&quot;,&quot;CCC&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charaset=utf-8&quot;); if (userNames.contains(username)) &#123; response.getWriter().print(&quot;改用户名以存在&quot;); &#125; else &#123; response.getWriter().print(&quot;&quot;); &#125; System.out.println(&quot;请求已发送&quot;); &#125;&#125; 使用jackson包去生成json 导入jar包 创建ObjectMappter 对象 ObjectMapper mapper = new ObjectMapper(); 调用 mapper 的 writerValueAsString() 方法 把一个对象转为一个 Json 字符串 先写好一个class1234567891011121314151617181920212223242526public class Customer&#123; private String name; private String id; public String getName()&#123; return name; &#125; public String getId()&#123; return id; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setId(String id)&#123; this.id = id; &#125; public Customer(String name, Stirng id)&#123; this.name = name; this.id = id; &#125; public String getBrithday()&#123; return "2018.12.01"; &#125; public String getAddress()&#123; return "hubei-wuhan"; &#125;&#125; 写一个main类去调用上述Customer1234567public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOE......&#123; ObjectMapper mapper = new ObjectMapper(); Customer customer = new Customer("Name", "1001"); String jsonStr = mapper.writeValueAsStirng(customer); System.out.println(jsonStr);&#125; 注意 JackSon 使用 getter 方法来定位Json 对象的属性 自行尝试上述的代码，你会发现 没有定义为 string 的 address 和 birthday 也会出现在最后的json中 因为 addrss 和 birthday 都 定义了 get 方法 即 只要是定义了 get 方法的，其返回值都会被放入json对象中 如果 getName() 修改 为 getCustName()，那么最后放入json的键的名字就是 “csunstName” 可以通过在CLASS中添加注解来使某些get方法不放入json对象中 @JsonIgnore 放在 get 函数前面 jQuery block uijQuery BlockUI 插件可以在不同锁定浏览器的同时，模拟同步模式下发起Ajax请求的行为该插件激活时，会阻止用户在页面进行的操作，直到插件被关闭BlockUI通过向DOM中添加元素实现其外观和组织用户交互的行为。 1&lt;script type="text/javascript" src="http://malsup.github.io/min/jquery.blockUI.min.js"&gt;&lt;/script&gt; 阻止页面交互1$.blockUI(); 自定义消息阻塞UI1$.blockUI(&#123;message:&apos;&lt;h1&gt;&lt;img src=&quot;busy.gif&quot; /&gt;Just a moment...&lt;/h1&gt;&apos;&#125;); 自定义样式阻塞UI1$.blockUI(&#123;css:&#123;backgroundColor: &apos;red&apos;; color:&apos;#fff&apos;&#125;&#125;); 解除对页面的遮罩1$.unblockUI(); 使用缺省设置对所有的ajax请求都使用UI遮罩1$(document).ajaxStart($.blockUI).ajaxStop($.unblockUI); 学习学习http://bookshadow.com/weblog/2014/09/26/jquery-blockui-js-introduction/ 全局覆盖12345// change message border$.blockUI.defaults.css.border = &apos;5px solid red&apos;;// make fadeOut effect shorter$.blockUI.defaults.fadeOut = 200; 局部覆盖1234567891011121314151617// change message border$.blockUI(&#123; css: &#123; border = &apos;5px solid red&apos;&#125; &#125;);...// make fadeOut effect shorter$.unblockUI(&#123; fadeOut: 200 &#125;);...// use a different message$.blockUI(&#123; message: &apos;Hold on!&apos; &#125;);...// use a different message$(&apos;#myDiv&apos;).block(&#123; message: &apos;Processing...&apos; &#125;); 补充 xmlHttp.response 和 xmlHttp.responseText 都是获取响应 responseText 获取的永远是以文本格式，字符串形式的响应体 response 会 根据 responseType的变化而变化 xmlHttp.responseType = “json” 则 response 则为 json 格式 通过代码告诉请求代理对象服务器端响应的是JSON对象 模板引擎的使用（这里用的是art-template） 首先我们要选择模板引擎 市面上的模板引擎很多 art-template（国产） Handlebars（最火） ejs doT swig（不维护了） …… 下载模板引擎JS文件 引入到页面中 &lt;script src=”js/template-web.js”&gt;&lt;/script&gt; 准备一个模板 1234&lt;script id = "tmple" type="text/javascript"&gt;&lt;/script&gt;// 如果 type 不为 text/javascript 那么 标签内部的内容不会作为 js语句 执行` 准备一个数据 通过模板引擎的JS文件提供的一个函数/方法 将模板和数据整合的到渲染结果HTML 将渲染结果的HTML设置到某个元素的innderHTML中 跨域 跨域可以说Ajax没有一点关系，也可以说与Ajax有着绝对的联系 同源策略同源策略是浏览器的一种安全策略 所谓同源是指：域名，协议，端口 完全相同 只有同源的地址才可以通过Ajax的方式请求 不同源地址之间，默认不能相互进行Ajax请求 不同源地址之间的请求我们称之为跨域请求 不同源则报错：No ‘Access-Control-Allow-Origin’ header is present on the requested resource 翻译过来就是 目标地址 不允许不同源的地址对其进行Ajax操作解决方案]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cocos2dx基础]]></title>
    <url>%2F2017%2F11%2F04%2FCocos2dx%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Cocos2dx-网络通信 Socket通讯 http协议 WebSocket协议 Cocos2d-x封装了3个类来处理HTTP请求 HttpRequest HttpClient HttpResponse 他们在命名空间cocos2d::network中定义 WebSocket protocol是HTML5一种新的协议 实现了浏览器和服务器全双工通信 实现浏览器和服务器的即时通讯 使用Http协议进行网络通信 HttpRequest HttpClient HttpRespose 在使用上述三个类的时候，必须遵守一定的流程 创建HttpRequest实例 设置请求方式-Get/Post等 设置请求地址和发送数据 设置响应回调函数，在回调函数中处理获取的数据 创建HttpClient实例，发送请求 释放连接 HttpRequest 是一种数据类型 提供了一些定义或获取HTTP请求的参数的方法 常用方法 设置请求连接 void setUrl(const char *url) 设置请求类型 void setRequestType(Type type) Type是一个枚举类型 enum class Type{ GET, POST, PUT, DELETE, UNKOW, }; 设置回调函数 void setResponseCallback(Ref *pTarget, SEL_HttpResponse pSelector) 设置请求的数据，参数buffer是提交的数据，len是请求数据的长度 void serRequestData(const char *buffer, unsigned int len) HttpClient 在创建完HttpRequest之后，就需要创建HttpClient对象 HttpClient对象控制请求相关的参数 发送请求 设置请求超时时间 …… 使用单例模式，是唯一实例 常用方法 发送请求 send(Http Request* request) 设置连接超时时间 setTimeoutForConnect(int value) HttpRespose 包含服务器返回的数据等信息 使用HTTPResponse提供的方法可获取这些数据 获取请求返回的数据 std::vector* getResponseData(); 获取返回状态（200,300,404,500…） getResponseState() 判断是否返回成功 issucced() 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 引入头文件#include "network/HttpRequest.h"#include "network/HttpClient.h"#include "network/HttpResponse.h"// 引入名空间using namespace cocos2d::network;// 获取HttpRequest对象auto request = new HttpRequest();// 设置请求连接request-&gt;setUrl("http://httpbin.org/ip");// 设置请求方式request-&gt;setRequestType(HttpRequest::Type::GET);// 设置发送数据char data[50] = "data";request-&gt;setRequestData(data, strlen(data));// 设置回调函数request-&gt;setResponseCallback(CC_CALLBACK_2(HelloWorld::ConnetIntnet,this));// 获取唯一的clien实例auto client = HttpClient::getInstance();// 设置超时时间client-&gt;setTimeoutForConnect(60);// 设置读取时间client-&gt;setTimeoutForRead(100);// 发送请求client-&gt;send(request);void HelloWorld::ConnetIntnet(HttpClient * client, HttpResponse * response)&#123; CCLOG("response code = %d", response-&gt;getResponseCode()); if (response-&gt;isSucceed())&#123; std::vector&lt;char&gt; *data = response-&gt;getResponseData(); std::stringstream oss; for (int i = 0; i &lt; data-&gt;size(); i++) &#123; oss &lt;&lt; (*data)[i]; &#125; CCLOG(" response data is %s", oss.str().c_str()); &#125;else&#123; CCLOG("error msg is : %s", response-&gt;getErrorBuffer()); &#125;&#125; 发送POST请求 很简单 修改上述的部分代码即可 12345678910request-&gt;setUrl("http://httpbin.org/post");// 设置请求方式request-&gt;setRequestType(HttpRequest::Type::POST);// 设置发送数据char data[50] = "controller=cocos2d&amp;username=test";request-&gt;setRequestData(data, strlen(data));// 最后加上request-&gt;release(); 观察输出结构 form 表单中 controller 就是 cocos2d，username 是 test 12345678910111213141516171819202122response code = 200 response data is &#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "controller": "cocos2d", "username": "test" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "32", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org" &#125;, "json": null, "origin": "61.136.151.254", "url": "http://httpbin.org/post"&#125; 设置Content-Type POST请求需要设置 Content-type的格式 application/html 或者 xml 或 json 默认为text/html 一般来说 Content-Type:application/html;charset=uft-8 设置请求头信息12345set::vector&lt;std::string&gt; header;header.push_back("Content-Type:application/html;charset=utf-8");request-&gt;setHeaders(header);// 具体情况具体分析吧，有的服务器使用的是XML，有的是HTML，有的是Json 使用WebSocket发送请求WebSocket WebSocket类了跟websocket相关操作的方法。他的作用包括 创建socket对象 new 方法 向服务器发送数据，可以是文本数据，也可以是二进制数据 send方法 半段连接状态 等等 123456enum class ErrorCode&#123; TIME_OUT,// 连接超时 CONNECTION_FAILURE, // 连接失败 UNKNOW, // 为止错误&#125; 123456789cocos2d::network::WebSocket* wsSendText = new network::WebSocket();// 创建对象wsSendText-&gt;init(*this, "ws://echo.websocket.org");// 初始化请求地址weSendText-&gt;send("hello WebSocket, I'm a text message");// 发送数据 WebSocket::Delegete 类似Socket WebSocket::Delegete提供了四个纯虚函数 在使用WebSocket时，要先继承Delegete类，实现四个纯虚函数 12345678910111213virtual void onOpen(WebSocket* ws);// 当打开websocket连接时调用// 即WebSocket new 出来的时候调用的函数virtual void onMessage(WebSocket* ws, const Data&amp; data);// 当接收到数据时调用virtual void onClose(WebSocket* ws);// 当关闭连接时调用voirtual void onError(WebSocket* ws, const ErrorCode&amp; error);// 当发送数据但没有建立连接，或者收到断开连接信号时调用 12345wstest = new WebSocket();wstest-&gt;init(*this, "ws://echo.websocket.org");wstest-&gt;send("hello world");wstest-&gt;close(); Box2D物理引擎在Cocos的应用 为了能够使用BOX2D，所以需要在vs中配置 右键工程名，选择属性 在常规中 设置 附加包含目录（第一个） 修改 $(EngineRoot)external\chipmunk\include\chipmunk 为 $(EngineRoot)external\Box2D\include\ 在 预处理 器中 设置 预处理器定义 修改 CC_ENABLE_CHIPMUNK_INTEGRATION= 1 为 CC_ENABLE_BOX2D_INTEGRATION= 1 创建世界，设置边界 HelloWorld.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include "HelloWorldScene.h"#include "SimpleAudioEngine.h"USING_NS_CC;Scene* HelloWorld::createScene()&#123; return HelloWorld::create();&#125;HelloWorld::~HelloWorld()&#123; CC_SAFE_DELETE(world);//删除对象 并指向一个NULL&#125;static void problemLoading(const char* filename)&#123; printf("Error while loading: %s\n", filename); printf("Depending on how you compiled you might have to add 'Resources/' in front of filenames in HelloWorldScene.cpp\n");&#125;bool HelloWorld::init()&#123; if ( !Scene::init() ) &#123; return false; &#125; this-&gt;initpjysics(); this-&gt;scheduleUpdate(); EventListenerTouchOneByOne *listener = EventListenerTouchOneByOne::create(); listener-&gt;onTouchBegan = CC_CALLBACK_2(HelloWorld::onTouchBegan, this); _eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, this); auto visibleSize = Director::getInstance()-&gt;getVisibleSize(); Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); return true;&#125;void HelloWorld::update(float dt)&#123; // 同步精灵与物体 float timeStep = 0.03f; int32 velocityIterations = 8; int32 positionIterations = 1; // 设置刷新时间 world-&gt;Step(timeStep, velocityIterations, positionIterations); for (b2Body *b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()) &#123; if (b-&gt;GetUserData() != nullptr) &#123; // 运动只有两种运动 一个旋转 一个位移，因此只需要将物体角度，位置与精灵角度，位置同步 Sprite* sprite = (Sprite *)b-&gt;GetUserData(); // 物体的单位是 m ， 精灵的单位是 像素 sprite-&gt;setPosition(Vec2(b-&gt;GetPosition().x * PTM_PATIO, b-&gt;GetPosition().y * PTM_PATIO)); sprite-&gt;setRotation(-1 * CC_RADIANS_TO_DEGREES(b-&gt;GetAngle())); &#125; &#125;&#125;void HelloWorld::menuCloseCallback(Ref* pSender)&#123; Director::getInstance()-&gt;end(); #if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS) exit(0);#endif&#125;// 创建世界，引入世界边界void HelloWorld::initpjysics()&#123; auto visibleSize = Director::getInstance()-&gt;getVisibleSize(); Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); //设置重力 b2Vec2 gravity; gravity.Set(0.0f, -10.0f); //创建世界 world = new b2World(gravity); // 允许物体休眠 world-&gt;SetAllowSleeping(true); // 开启连续物理测试 // 防止 物体 间 出现 物体穿透 world-&gt;SetContinuousPhysics(true); // 物理世界的边界 b2BodyDef groundBody; groundBody.position.Set(0,0);//左下角 b2Body *ground = world-&gt;CreateBody(&amp;groundBody); b2EdgeShape groundBox; // 定义底部 groundBox.Set(b2Vec2(0,0), b2Vec2(visibleSize.width/PTM_PATIO,0)); // / PTM_PATIO 是 把像素换成 米 // 使用夹具 固定 形状到物体 // 参数是 形状指针， 密度 ground-&gt;CreateFixture(&amp;groundBox, 0); // 定义顶部 groundBox.Set(b2Vec2(0, visibleSize.height/PTM_PATIO), b2Vec2(visibleSize.width / PTM_PATIO, visibleSize.height/PTM_PATIO)); // / PTM_PATIO 是 把像素换成 米 ground-&gt;CreateFixture(&amp;groundBox, 0); // 定义左侧 groundBox.Set(b2Vec2(0, 0), b2Vec2(0, visibleSize.height/PTM_PATIO)); // / PTM_PATIO 是 把像素换成 米 ground-&gt;CreateFixture(&amp;groundBox, 0); // 定义右侧 groundBox.Set(b2Vec2(visibleSize.width/PTM_PATIO, 0), b2Vec2(visibleSize.width / PTM_PATIO, visibleSize.height/PTM_PATIO)); // / PTM_PATIO 是 把像素换成 米 ground-&gt;CreateFixture(&amp;groundBox, 0);&#125;void HelloWorld::addNewSprite(Touch * touch, Event * unused_event)&#123; auto p = touch-&gt;getLocation(); // 创建物理相关精灵 auto sprite = Sprite::create(""); sprite-&gt;setPosition(touch-&gt;getLocation()); this-&gt;addChild(sprite); // 定义物体 b2BodyDef bodyDef; bodyDef.type = b2_dynamicBody;//动态物体 bodyDef.position.Set(p.x/PTM_PATIO, p.y/PTM_PATIO); b2Body *body = world-&gt;CreateBody(&amp;bodyDef);//从物理世界创建body body-&gt;SetUserData(sprite); //将 物体 与 body 关联 //定义形状 auto contenSize = sprite.getContentSize(); b2PolygonShape dynamicBox;//这是个结构体 dynamicBox.SetAsBox(contenSize.width/PTM_RATIO/2,contenSeiz.width/PTM_PATIO/2); //设置形状大小，中心点到左边距，右边距 // 这里自动适配图片大小，又因为 是 中心点到左右两边的距离，所以要 除以 2 // 定义夹具 b2FixtureDef fixtrue; fixtrue.shape = &amp;dynamicBox; fixtrue.density = 1.0f;//密度 fixtrue.friction = 0.3f;// 摩擦系数 // 将夹具 与 body 连接 body-&gt;CreateFixture(&amp;fixtrue); // 但是物体并不会动，需要在update函数中设置&#125;bool HelloWorld::onTouchBegan(Touch * touch, Event * event)&#123; addNewSprite(touch, event); return false;&#125; HelloWorld.h文件 123456789101112131415161718192021222324252627282930313233#ifndef __HELLOWORLD_SCENE_H__#define __HELLOWORLD_SCENE_H__#include "cocos2d.h"#include "Box2D\Box2D.h"#include "ContactListener.h"USING_NS_CC;#define PTM_PATIO 32class HelloWorld : public cocos2d::Scene&#123;public: static cocos2d::Scene* createScene(); ~HelloWorld(); virtual bool init(); virtual void update(float dt); // a selector callback void menuCloseCallback(cocos2d::Ref* pSender); void initpjysics();//初始化物理引擎 void addNewSprite(Touch* touch, Event* unused_event); b2World *world; ContactListener* contactListener; bool onTouchBegan(Touch* touch, Event *event); // implement the "static create()" method manually CREATE_FUNC(HelloWorld);&#125;;#endif // __HELLOWORLD_SCENE_H__ 碰撞检测 ContactListener.h 1234567891011121314#pragma once#include "cocos2d.h"#include "Box2D\Box2D.h"using namespace std;USING_NS_CC;class ContactListener : public b2ContactListener &#123;private: virtual void BeginContact(b2Contact* contact); virtual void EndContact(b2Contact* contact); virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold); virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);&#125;; ContactListener.cpp 文件 12345678910111213141516171819202122232425262728293031323334353637383940#include "ContactListener.h"USING_NS_CC;void ContactListener::BeginContact(b2Contact * contact)&#123; CCLOG("begin"); b2Body* bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();// 通过夹具获得物体A的body b2Body* bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();// 通过夹具获得物体A的body auto spriteA = (Sprite *)bodyA-&gt;GetUserData(); // 通过body获取精灵，强转一下 auto spriteB = (Sprite *)bodyB-&gt;GetUserData(); // 通过body获取精灵，强转一下 if (spriteA != nullptr &amp;&amp; spriteB != nullptr) &#123; spriteA-&gt;setColor(Color3B::YELLOW); spriteB-&gt;setColor(Color3B::YELLOW); &#125;&#125;void ContactListener::EndContact(b2Contact * contact)&#123; CCLOG("end"); b2Body* bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();// 通过夹具获得物体A的body b2Body* bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();// 通过夹具获得物体A的body auto spriteA = (Sprite *)bodyA-&gt;GetUserData(); // 通过body获取精灵，强转一下 auto spriteB = (Sprite *)bodyB-&gt;GetUserData(); // 通过body获取精灵，强转一下 if (spriteA != nullptr &amp;&amp; spriteB != nullptr) &#123; spriteA-&gt;setColor(Color3B::WHITE); spriteB-&gt;setColor(Color3B::WHITE); &#125;&#125;void ContactListener::PreSolve(b2Contact * contact, const b2Manifold * oldManifold)&#123; CCLOG("PreSolve");&#125;void ContactListener::PostSolve(b2Contact * contact, const b2ContactImpulse * impulse)&#123; CCLOG("PostSolve");&#125; 关节 距离关节 两个物体之间保持固定的距离，每个物体上的点称为锚点。 关节定义是b2DistanceJoinDef 旋转关节 允许物体围绕公共点旋转。 关节定义是 b2RevoluteJoiDef 平移关节 两个物体之间的相对旋转是固定的，他们可以沿着一个坐标轴进行平移。 关节定义是 b2PrismaticJointDef 焊接关节 可以吧物体固定在相同方向上。 关节定义是 b2WeldJointDef 轮滑关节 轮滑关节用于创建理想的轮滑，两个物体唯一绳子两端，绳子通过某个固定点（轮滑的位置）将两个物体连接起来 当一个物体升起，另一个物体就会下降 关节定义是 b2PulleyJointDef 摩擦关节 降低两个物体之间的相对运动 关节定义是 b2FrictionJointDef 齿轮关节 控制其他两个关节（旋转关节或者平移关节），其中一个的愚弄的那个会影响另一个 关节定义是 b2GearJointDef 鼠标关节 点击物体上任意一个点可以在世界范围内进行拖动 关节定义是 b2MouseJointDef 动作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374Sprite * sp= Sprite::create("Icon.png");sp-&gt;setPosition(Vec2(150, 150));addChild(sp,0,922);// Action动作// MoveBy 创建一个移动的动作 参数1：移动到目标坐标所需的时间 参数2：目标坐标 // 支持reverse 可以获取其反向动作// MoveTo 一样的ActionInterval * moveBy = MoveBy::create(5,Vec2(300, 100));ActionInterval * actionmoveback= moveBy-&gt;reverse();sp-&gt;runAction(actionmoveback);// ScaleTo 作用：创建一个缩放的动作// 参数1：达到缩放大小所需的时间// 参数2 ：缩放的比例ActionInterval * scaleto = ScaleTo ::create(2, 2);sp-&gt;runAction(scaleto);// ScaleBy 作用:创建一个缩放的动作// 参数1：达到缩放大小的所需时间 参数2：缩放比例ActionInterval * scaleby = ScaleBy::create(2, 2);ActionInterval * actionbyback = scaleby-&gt;reverse();sp-&gt;runAction(actionbyback);// RotateTo// 作用创建一个旋转的动作// 参数1：旋转的时间 参数2：旋转饿角度 0 - 360ActionInterval * rotateto = RotateTo::create(2, 90);sp-&gt;runAction(rotateto);// SkewTo// 作用创建一个倾斜的动作// 参数1：倾斜到特定角度所需的时间// 参数2：x轴的倾斜角度// 参数3：y轴的倾斜角度ActionInterval * skewto = SkewTo::create(2, 10, 10);sp-&gt;runAction(skewto);// JumpTo// 作用：创建一个跳的动作// 参数1：跳到目标动作位子的所需时间// 参数2：目标位置// 参数3：跳的高度// 参数4跳到目标位置的次数ActionInterval* jumpto = JumpTo ::create(2, Vec2(300, 200), 50, 4 );sp-&gt;runAction(jumpto);// JumpBy// 作用：创建一个跳的动作// 参数1：跳到目标动作位子的所需时间// 参数2：目标位置// 参数3：跳的高度// 参数4跳到目标位置的次数// 这个支持方向动作reverseActionInterval * jumpby = JumpBy ::create(3, Vec2(300, 200), 50, 4);ActionInterval * ac= jumpby-&gt;reverse();sp-&gt;runAction(ac);// Bezier// BezierConfig结构体 BezierConfig bezierCon;bezierCon.controlPoint_1=Vec2(200, 150);//控制点1bezierCon.controlPoint_2=Vec2(200, 160);//控制点2bezierCon.endPosition =Vec2(340, 100);// 结束位置//BezierTo// 创建一个贝塞尔曲线运动的动作// 参数1：贝塞尔曲线运动的时间// 参数2 ： BezierConfig结构体ActionInterval * action = BezierTo::create(2, bezierCon);ActionInterval * action1 = BezierBy::create(3, bezierCon);//支持反向ActionInterval * action2 = action-&gt;reverse();sp-&gt;runAction(action1);//FadeIn//作用：创建一个渐变出现的动作//参数是时间ActionInterval * fadein = FadeIn::create(2);sp-&gt;runAction(fadein);// FadeOut// 作用：创建一个渐变消失的动作// 参数是时间ActionInterval * fadeout = FadeOut::create(2);sp-&gt;runAction(fadeout);// TintTo// 作用：创建一个色彩变化的消失动作// 参数1：色彩变化的动作// 参数2 ：红色分量// 参数3：蓝色分量ActionInterval * tinto = TintTo ::create(3, 255, 255, 0);sp-&gt;runAction(tinto);// TintBy// 作用：创建一个色彩变化的出现动作// 参数1：色彩变化的动作// 参数2 ：红色分量// 参数3：蓝色分量 但是家了reverse就是 反向的ActionInterval * tintby = TintBy::create(3, 0, 255, 255);ActionInterval * tintby1 = tintby-&gt;reverse();sp-&gt;runAction(tintby1);// Blink// 作用 :创建一额闪烁的动作// 参数1：闪烁完成的时间// 参数2:闪烁的次数ActionInterval * blink = Blink ::create(3, 10);sp-&gt;runAction(blink);// DelayTime// 创建一个延迟的动作// 参数 延迟的时间ActionInterval * delaytime = DelayTime::create(3);sp-&gt;runAction(delaytime);// OrbitCamera// 作用：创建一个球面坐标轨迹进行旋转的动作// 参数1 ： 旋转轨迹的时间// 参数2 ：起始半径// 参数3：半径差// 参数4：起始z角// 参数5：旋转z角的差// 参数6：起始x角// 参数7：旋转x角的差ActionInterval * orbitcameraa = OrbitCamera::create(3, 10, 0, 45, 180, 90, 0);sp-&gt;runAction(orbitcameraa);// CardinalSpline// 作用：创建数组 点的数组PointArray * array = PointArray::create(20);array-&gt;addControlPoint(Vec2(0,0));array-&gt;addControlPoint(Vec2(210,0));array-&gt;addControlPoint(Vec2(210,240));array-&gt;addControlPoint(Vec2(0,160));array-&gt;addControlPoint(Vec2(0,0));// CardinalSplineTo// 作用：创建一个样条曲线轨迹的动作// 参数1：完成轨迹所需的时间// 参数2：控制点的坐标数组// 拟合度 其值= 0 路径最柔和ActionInterval * CardinalSplineTo=CardinalSplineTo::create(3, array, 0);sp-&gt;runAction(CardinalSplineTo);// CardinalSplineBy// 作用：创建一个样条曲线轨迹的动作// 参数1：完成轨迹所需的时间// 参数2：控制点的坐标数组// 拟合度 其值= 0 路径最柔和ActionInterval * CardinalSplineBy = CardinalSplineBy::create(3, array, 0);sp-&gt;runAction(CardinalSplineBy);// CatmullRomTo CatmullRomBY// 作用：创建一个样条插值轨迹// 参数1：完成轨迹的时间// 参数2：控制点的数组坐标ActionInterval * catmullRomTo = CatmullRomTo::create(3, array);sp-&gt;runAction(catmullRomTo);// Follow// 作用：创建一个跟随动作// 参数1：跟随的目标对象// 跟随范围，离开范围就不再跟随//创建一个参照物spTSprite * spt = Sprite::create("Icon.png");spt-&gt;setPosition(Vec2(420,40));addChild(spt);sp-&gt;runAction(MoveTo::create(3, Vec2(940,sp-&gt;getPositionY())));Follow * follow = Follow::create(sp,Rect(0, 0, 960, 320));this-&gt; runAction(follow);// EaseBounceIn// 目标动作ActionInterval* move = MoveTo::create(3, Vec2(300, sp-&gt;getPositionY()));//// 让目标动作缓慢开始//// 参数：目标动作ActionInterval * EaseBounceIn = EaseBounceIn::create(move);sp-&gt;runAction(EaseBounceIn);// EaseBounceOut// 作用：让目标动作赋予反弹力，且以目标动作结束位子开始反弹// 参数目标动作ActionInterval * easeBounceOut = EaseBounceOut ::create(move);sp-&gt;runAction(easeBounceOut);// EaseBounceInOut// 作用：让目标动作赋予反弹力，且以目标动作起始与结束位子开始反弹ActionInterval * easeBounceInOut= EaseBounceInOut::create(move);sp-&gt;runAction(easeBounceInOut);// EaseBackIn// 作用：让目标动作赋予回力 ， 且以目标动作起点位置作为回力点// 参数：目标动作ActionInterval * easeBackIn = EaseBackIn::create(move);sp-&gt;runAction(easeBackIn);// EaseBackOut// 作用：让目标动作赋予回力 ， 且以目标动作终点位置作为回力点// 参数：目标动作ActionInterval *easeBackOut = EaseBackOut::create(move);sp-&gt;runAction(easeBackOut);// EaseBackInOut// 作用：让目标动作赋予回力 ， 且以目标动作起点和终点位置作为回力点// 参数：目标动作 ActionInterval * easeBackInOut = EaseBackInOut::create(move);sp-&gt;runAction(easeBackInOut);// EaseElasticIn// 作用：让目标动作赋予弹性 ，且以目标动作起点位子赋予弹性// 参数：目标动作 ActionInterval * easeElasticIn= EaseElasticIn::create(move);sp-&gt;runAction(easeElasticIn);// EaseElasticOut// 作用：让目标动作赋予弹性 ，且以目标动作终点位子赋予弹性// 参数：目标动作 ActionInterval *easeElasticOut = EaseElasticOut::create(move);sp-&gt;runAction(easeElasticOut);// EaseElasticInOut// 作用：让目标动作赋予弹性 ，且以目标动作起点和终点位子赋予弹性// 参数：目标动作 ActionInterval *easeElasticInOut = EaseElasticOut::create(move);sp-&gt;runAction(easeElasticInOut);// EaseExponentialIn// 让目标动作缓慢开始// 参数：目标动作 ActionInterval * easeExponentialIn= EaseExponentialIn::create(move);sp-&gt;runAction(easeExponentialIn);// EaseExponentialOut// 让目标动作缓慢中止// 参数：目标动作ActionInterval * easeExponentialInt= EaseExponentialOut::create(move);sp-&gt;runAction(easeExponentialInt);// EaseExponentialInOut// 让目标动作缓慢开始和中止// 参数：目标动作 ActionInterval * easeExponentialInOut= EaseExponentialInOut::create(move);sp-&gt;runAction(easeExponentialInOut);// EaseRateAction// 作用 ： 让目标动作设置速率// 参数1:目标动作// 参数2：速率 ActionInterval * moveto = MoveTo::create(5, p(300,sp-&gt;getPositionY())); ActionInterval * easeRateAction = EaseRateAction::create(move, 3);sp-&gt;runAction(easeRateAction);// EaseSineIn// 作用：动作由慢到快// 参数：目标动作 ActionInterval * easeSineIn = EaseSineIn::create(move);sp-&gt;runAction(easeSineIn);// EaseSineOut// 作用：动作由快到慢// 参数：目标动作 ActionInterval * easeSineOut = EaseSineOut::create(move);sp-&gt;runAction(easeSineOut);// EaseSineInOut// 作用：动作由慢到快再快到慢// 参数：目标动作 ActionInterval * easeSineInOut = EaseSineInOut::create(move);sp-&gt;runAction(easeSineInOut);// Speed// 作用：让目标动作运行速度加倍// 参数1：目标动作// 参数2:倍速 ActionInterval * move = MoveTo::create(10, p(300,sp-&gt;getPositionY())); Speed * speed = Speed::create(move, 100);sp-&gt;runAction(speed);// Spawn// 作用：让多个动作同时执行// 参数：目标动作的可变参数 ActionInterval * move1 = MoveTo::create(10, p(300,sp-&gt;getPositionY())); ActionInterval * scale = ScaleTo::create(2, 3); ActionInterval * rotate = RotateTo::create(4, 190); FiniteTimeAction * spawn = Spawn::create(move1,scale,rotate,NULL);sp-&gt;runAction(spawn);// Sequence// 作用：让多个动作按照前后顺序逐一执行// 参数：目标动作的可变参数 ActionInterval * move2 = MoveTo::create(2, p(300, sp-&gt;getPositionY())); ActionInterval * scalet = ScaleTo::create(2, 3); FiniteTimeAction * seq= Sequence::create(move2,scalet,NULL);sp-&gt;runAction(seq); // 扩展如果要对目标动作全部进行方向运动，可以使用如下形式操作 FiniteTimeAction *seqe= Sequence::create(moveby,scaleby,...NULL); FiniteTimeAction * reverseseq = Sequence::create(seqe,seq-&gt;reverse(),NULL)//注意 Sequence中的所有动作都必须支持reverse函数，否则会出现异常 ActionInterval * move = MoveBy::create(2, p(300, sp-&gt;getPositionY())); ActionInterval * scale = ScaleBy::create(2, 3); FiniteTimeAction * seq= Sequence::create(move,scale,NULL); FiniteTimeAction * reveseseq = Sequence::create(seq,seq-&gt;reverse(),NULL);sp-&gt;runAction(reveseseq);// Repeat// 作用：对目标动作进行重复运动（目标动作可以是 Sequence ， Spawn）// 参数1：目标动作// 参数2：重复次数 ActionInterval * move = MoveTo::create(2, p(300, sp-&gt;getPositionY())); ActionInterval * move2 = MoveTo::create(2, p(100,100)); FiniteTimeAction*seq = Sequence::create(move,move2,NULL); FiniteTimeAction *repeat = Repeat::create(seq, 3);sp-&gt;runAction(repeat);// RepeatForever// 作用：对目标动作进行永久性的重复运动（目标动作可以是 Sequence ， Spawn）// 参数：目标动作 ActionInterval * move = MoveTo::create(1, p(300, sp-&gt;getPositionY())); ActionInterval * move1 = MoveTo::create(1, p(100,100)); FiniteTimeAction* seq = Sequence::create(move,move1,NULL); ActionInterval * repeatForever = RepeatForever::create(( ActionInterval* )seq);sp-&gt;runAction(repeatForever);// CallFunc// 作用：创建一个回调动作（调用不带参数的回调方法）；// 参数1：目标动作// 参数2：目标回调函数 ActionInterval * move = MoveTo::create(1, p(300, sp-&gt;getPositionY())); CallFunc * funcall= CallFunc::create(this, callfunc_selector(HelloWorld::callbackC)); FiniteTimeAction * seq = Sequence::create(move,funcall,NULL);sp-&gt;runAction(seq);// CallFuncN// 作用：创建一个回调动作（调用 带一个参数的回调方法）；// 参数1：目标动作// 参数2：目标回调函数 ActionInterval * move = MoveTo::create(1, p(300, sp-&gt;getPositionY())); CallFuncN * funcall= CallFuncN::create(this, callfuncN_selector(HelloWorld::callbackN)); FiniteTimeAction * seq = Sequence::create(move,funcall,NULL);sp-&gt;runAction(seq);// CallFuncND// 作用：创建一个回调动作（调用 带两个参数的回调方法）；// 参数1：目标动作// 参数2：目标回调函数 ActionInterval * move = MoveTo::create(1, p(300, sp-&gt;getPositionY())); CallFuncND * funcall= CallFuncND::create(this, callfuncND_selector(HelloWorld::callbackND) ,(void*)0xbebabeba); FiniteTimeAction * seq = Sequence::create(move,funcall,NULL);sp-&gt;runAction(seq); 内存管理机制常用算法引用计数算法 每个对象都有一个引用，一个数来跟踪它被引用的次数 每增加一次 引用计数+1 ，每减少一次 应用计数-1 垃圾回收时 引用计数 为0 时就要被回收 最为致命的问题是无法解决循环引用 标记清除算法 根可达的集合，cocos中的所有对象都有一个同一个父节点 第一个阶段从应用节点开始标记所有被引用的对象 第二个阶段遍历整个堆，把未标记的对象清除 最为致命的问题是这个算法需要暂停整个应用，并且会产生内存碎片 复制算法 将内存分为连个区域，每次只使用其中一个区域。 垃圾回收时，遍历整个区域，将正在使用的对象复制到另一个区域中 复制成本较小，而且可以进行内存管理，不会出现内存碎片 最为致命的问题是这个算法需要两倍的内存空间 标记-整理算法 集合了标记清除和复制算法 第一阶段，从根节点开始标记所有的被应用的节点 第二阶段，清除未被标记的节点，同时将被标记的节点压缩到一起，按顺序排放 delete和newnew运算符使用的一般格式为 new 类型 [初值] 用new分配数组空间时不能指定初值。 如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。 new int;//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针) new int(100);//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 new char[10];//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4];//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);//开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p delete运算符使用的一般格式为 delete [ ]指针变量 例如要撤销上面用new开辟的存放单精度数的空间(上面第5个例子)，应该用 delete p； 前面用“new char[10];”开辟的字符数组空间，如果把new返回的指针赋给了指针变量pt，则应该用以下形式的delete运算符撤销该空间： delete [] pt；//在指针变量前面加一对方括号，表示是对数组空间的操作 Cocos2dx 的内存管理 使用的是 引用计数方法 所有的自动释放的对象都继承于Ref类 Node基类也继承与Ref类 Ref类用于管理引用计数 Ref的方法 retain() 增加引用计数 release() 减少引用计数 autorelease() 生成自动释放对象 getReferanceCount() 获取对象的引用计数 创建流程 创建一个对象的时候 首先调用对象的父类的构造函数 最终会调用到Ref这个基类 在Ref这基类中会初始化引用计数ReferanceCount为1 在release函数中，有判断引用计数的值，如果为0会自动释放对象 CREATE_FUNC()函数源码分析123456789101112131415161718192021/** * define a create function for a specific type, such as CCLayer * @__TYPE__ class type to add create(), such as CCLayer */ #define CREATE_FUNC(__TYPE__) \ static __TYPE__* create() \ &#123; \ __TYPE__ *pRet = new __TYPE__(); \ //创建传过来的东西 if (pRet &amp;&amp; pRet-&gt;init()) \ &#123; \ pRet-&gt;autorelease(); \ return pRet; \ &#125; \ else \ &#123; \ delete pRet; \ pRet = NULL; \ return NULL; \ &#125; \ &#125; 很明显上面的pRet 使用了 autorelease() 方法先使用C++的new方法创建一个对象，如果创建成功，则添加自动清除rc 什么是CREATE_FUNC()为类似CCLayer类的特定类增加一个create函数，我们也可以看到在宏的下面定义了一个create()函数返回到类型就是宏带入的参数&quot;__TYPE__&quot;指针类型 create（）函数做了什么？他执行了类的构造函数，执行了init()初始化函数，最后又设置创建出的对象为自动释放内存，这样其他人在使用这个类的时候，只要是用create（）函数创建出来的对象就是不用费心区管理释放内存 引用计数什么时候引用计数每一个对象都有一个关联的引用计数 —— 对该对象的活跃引用的数量。 如果对象的引用计数是零，那么它就是垃圾（用户程序不可到达它），并可以回收。 Cocos2dx内存管理分为两块1. 通过加入 `autorelease` 来自动释放那些创建后未使用的对象 2. 通过`节点管理`来保证对象在弃用后及时的删除 及时释放弃用的对象使用条件：该对象是Node的子类对象使用方法：addChild，removeChild 内存管理过程：addChild 添加对象后，对象可以被使用 removeChild 删除对象后，对象被立刻删除（通过 delete） 及时释放未使用的对象简述新创建的对象如果 一帧 内不使用，就会被自动释放。（所谓一针，即是一个gameloop） 使用条件对象通过CREAT_FUNC()宏创建或者对象使用autorelease加入了自动释放池 使用方法自动实现 管理过程对象不使用的情况对象创建 引用+1 对象自动释放 引用-1 对象使用的情况对象创建 引用+1 对象使用 引用+1//通过 addchild 使用对象 对象自动释放 引用-1 引用的初始值为0，如果一阵结束后对象的引用值还是0，那就会被delete掉 内存管理的实现原理第一部分Red类：进行引用计数，提供加入自动释放池的接口。AutoreleasePool类：管理一个vector数组来存放自动释放池的对象。提供对释放池的清空操作PoolManager类：管理一个vector数组来存放自动释放池。默认情况下引擎只创建一个自动释放池，因此这个类是提供给开发者使用的，例如处于性能考虑添加自己的自动释放池DisplayLinkDirector类：只是一个导演类，提供游戏的主循环，实现每一帧的资源释放。这个类继承自Director类，也是唯一一个继承了Director的类，也就是说完全可以合并为一个类。 Ref源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 引用计数变量unsigned int _referenceCount;// 对象被构造后，引用计数值为 1Ref::Ref(): _referenceCount(1) //当Ref对象被创建时，引用计数的值为 1&#123;#if CC_ENABLE_SCRIPT_BINDING static unsigned int uObjectCount = 0; _luaID = 0; _ID = ++uObjectCount; _scriptObject = nullptr;#endif #if CC_USE_MEM_LEAK_DETECTION trackRef(this);#endif&#125;// 引用+1void Ref::retain()&#123; CCASSERT(_referenceCount &gt; 0, "reference count should greater than 0"); ++_referenceCount;&#125;// 引用-1 。如果引用为0则释放对象void Ref::release()&#123; CCASSERT(_referenceCount &gt; 0, "reference count should greater than 0"); --_referenceCount; if (_referenceCount == 0) &#123;#if CC_USE_MEM_LEAK_DETECTION untrackRef(this);#endif delete this; // 注意这里 把对象 delete 了 &#125;&#125;// 提供加入自动释放池的接口。对象调用此函数即可加入自动释放池的管理。Ref* Ref::autorelease()&#123; PoolManager::getInstance()-&gt;getCurrentPool()-&gt;addObject(this); return this;&#125;//获取引用计数值unsigned int Ref::getReferenceCount() const&#123; return _referenceCount;&#125; AutoreleasePool源码1234567891011121314151617181920212223242526272829303132// 存放释放池对象的数组std::vector&lt;Ref*&gt; _managedObjectArray;// 往释放池添加对象void AutoreleasePool::addObject(Ref* object)&#123; _managedObjectArray.push_back(object);&#125;// 清空释放池，将其中的所有对象都 deletevoid AutoreleasePool::clear()&#123; // 释放所有对象 for (const auto &amp;obj : _managedObjectArray) &#123; obj-&gt;release(); &#125; // 清空vector数组 _managedObjectArray.clear();&#125;// 查看某个对象是否在释放池中bool AutoreleasePool::contains(Ref* object) const&#123; for (const auto&amp; obj : _managedObjectArray) &#123; if (obj == object) return true; &#125; return false;&#125; PoolManager源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 释放池管理器单例对象static PoolManager* s_singleInstance;// 释放池数组std::vector&lt;AutoreleasePool*&gt; _releasePoolStack;// 获取 释放池管理器的单例PoolManager* PoolManager::getInstance()&#123; if (s_singleInstance == nullptr) &#123; // 新建一个管理器对象 s_singleInstance = new PoolManager(); // 添加一个自动释放池 new AutoreleasePool("cocos2d autorelease pool");// 内部使用了释放池管理器的push，这里的调用很微妙，读者可以动手看一看 &#125; return s_singleInstance;&#125;// 获取当前的释放池AutoreleasePool* PoolManager::getCurrentPool() const&#123; return _releasePoolStack.back();&#125;// 查看对象是否在某个释放池内bool PoolManager::isObjectInPools(Ref* obj) const&#123; for (const auto&amp; pool : _releasePoolStack) &#123; if (pool-&gt;contains(obj)) return true; &#125; return false;&#125;// 添加释放池对象void PoolManager::push(AutoreleasePool *pool)&#123; _releasePoolStack.push_back(pool);&#125;// 释放池对象出栈void PoolManager::pop()&#123; CC_ASSERT(!_releasePoolStack.empty()); _releasePoolStack.pop_back();&#125; DisplayLinkDirector源码123456789101112131415161718void DisplayLinkDirector::mainLoop()&#123; //第一次当导演 if (_purgeDirectorInNextLoop) &#123; _purgeDirectorInNextLoop = false; purgeDirector();//进行清理工作 &#125; else if (! _invalid) &#123; // 绘制场景，游戏主要工作都在这里完成 drawScene(); // 清空资源池 PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear(); &#125;&#125; 过程分析首先，创建了一个 Node 对象A，Node 继承Ref，因此 Ref 的引用计数为1； 然后，A通过 autorelease 将自己放入自动释放池；drawScene() 完成后， 一帧结束，Director 通过释放池将池中的对象 clear()，即对 Node 对象A进行 release() 操作。 A的引用计数变为0，执行 delete 释放A对象。 Cocos2dx 文件读写简介 在Pc端，程序是可以读写任意电脑的文件夹的 在 IOC/安卓 端，程序可以安装在任意文件夹下，但是只能访问安装文件夹里的文件 这是一个安全机制 cocos2dx 中的resouce资源文件夹 在打包安装到 IOS/安卓 上的时候是写死的不能更改的 使用 使用到的类 FileUtils::getInstance() getWritablePath() 返回一个字符串string，获取一个可以写的文件路径 123456string filePath = FileUtils::getInstance()-&gt;getWritablePath() + "user,txt"; // 这里的getWriteablePath() 是获取可以写的路径string userData = FileUtils::getInstance()-&gt;getStringFromFile(filePath);FileUtils::getInstance()-&gt;writeStringToFile(userData, filePath); // 保存文本的文件信息 如果是获取安装路径的文件信息，则可以直接使用路径信息例如，在resouce资源文件夹下有个Data文件夹，里面有个user.txt文件，则直接使用FileUtils::getInstance()-&gt;getStringFromFile(“Data/user.txt”);就可以，而不需要使用可写路径 反蓄序列化 通过一个JSON文件，给一个类赋值 保存为UTF-8无dom格式 12345678[ &#123;"name":"tom", "age":12, "address":"******"&#125; &#123;"name":"lucy", "age":13, "address":"******"&#125; &#123;"name":"jack", "age":14, "address":"******"&#125; &#123;"name":"拉拉", "age":15, "address":"******"&#125; &#123;"name":"波", "age":16, "address":"******"&#125; &#123;"name":"树莓", "age":17, "address":"******"&#125;] 12345678910111213141516class Student&#123;public: Student(string _name, int _age, string _address); ~Student();private: string name, address; int age;&#125;Student::Student(string _name, int _age, string _address)&#123; this.name = _name; this.address = _address; this.age = _age;&#125; 如果是在代码中用new的方法写死这个Student类，很明显是很2的 在Cocos2dx 的代码中使用 #include &quot;spine/Json.h&quot; 1234567891011121314151617181920// 需要注意的是，这里并没有使用 上面的 可写路径std::string strRoles = FileUtils::getInstance()-&gt;getStringFromFile("Data/User.txt");// 反序列化，将字符串转为json格式Json* data = Json_create(strRoles.c_str());// 由于上述的json是一个数组，所以这里的data是一个数组Json* stu = js-&gt;child;// json数组的第一个元素while(stu)&#123; // 这里就是一个获取的过程 int id = Json_getItem(stu, "age"); // 由于返回的是一个string类型，所以使用valueString, 同理还有 valuefloat 等 std::string name = Json_getItem(stu, "name")-&gt;valueString; std::string address = Json_getItem(stu, "name")-&gt;valueString; Studen stu1 = new Student(name, age, address); // 往下走 stu = stu-&gt;next;&#125; 自带物理引擎setCategoryBitmask，setCollisionBitmask，setContactTestBitmask是什么意思呢？看了官方的文档，注释，还有不知其数的介绍物理引擎大神的文章，还是一头雾水不知所以。一般为了省事，都把这三个掩码设为1，这样不论什么物体都会发生碰撞，也能响应处理函数，但是这样做真的好吗？所谓不求甚解只求洒脱可能就是这个意思，但这可不是什么好的治学态度，也正是国人从古到今这个态度造就了我国自古以来就诞生不了科学这种奇葩景象还不以为耻反以为荣到现在沦落为到处抱别人大腿求施舍的窘境… CategoryBitmask好理解，表示一个物体所属哪个类别 可是CollisionBitmask和ContactTestBitmask就不好理解了，官方文档解释为前者与category掩码相与是否为1表示是否能发生碰撞，contactTest掩码与category掩码相于是否为1决定了是与能产生碰撞响应…. 这是什么话，我翻来覆去怎么看都觉得说了半天都是一个意思嘛！都是是否能产生碰撞响应。到底有什么区别呢？ 后来经过我不断的尝试修改，终于搞明白两者含义的区别： setCategoryBitmask，setCollisionBitmask决定了是否能产生碰撞。产生碰撞和发生碰撞响应是不同的概念。如人物奔跑时碰到了金币，这里如果没有碰撞处理函数，且把什么掩码都设为1，那么你会发现角色碰到金币时角色不再向前移动了，金币成了一个挡在路上的砖块，这时已经发生了碰撞 了，但如果你把人的类别设为1，金币的类别设为0，而两者的CollisionBitmask都为1，则金币和人的CategoryBitmask和CollisionBitmask掩码相与为0，则不会发生碰撞，在游戏里效果就是人奔跑时穿过了金币，金币就像空气一样，这就是没有发生碰撞的含义。 那么ContactTestBitmask呢，这个参数决定了是否能触发碰撞响应函数onContactBegin. 有些碰撞我们是不想处理的，如人物从空中落到一块大石头上，落到石头上只须停在石头上就行了，不需要做什么特殊的处理，这时你只需要将地面的类别设为0，人的类别设为1，ContactTestBitmask都设为1，这样相与的结果为0，就不会触发onContactBegin函数。那你该问了，你不处理那人怎么会停在石头上而不掉下去？不用担心，这是物理引擎的事，也正是物理引擎的强大之处，我们只要设置了刚体body就可以很轻松的写出一个像超级马里奥那种平台跳跃游戏也不需要判断马里奥脚上是否踩到地啦？跳的时候是不是头顶到地板啦？这种种复杂的情况，一个精灵设置了body，它就是一个硬硬的砖头，你只要掩码设好无论如何也穿不过去的。回到刚才人碰到金币的例子，如金币这种我们希望人碰到金币就Money + 1，并且金币消失，那么,就把金币和人的不论类别掩码还是ContactTest掩码都设为1，这样就瞎猫碰到死耗子一样触发了碰撞响应函数，在响应函数里再设置人的money++并且金币消失，也就达到了我们的效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[作死的学习Linux运维]]></title>
    <url>%2F2017%2F10%2F27%2Flinux-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux命令行大多是互联网企业在安装系统甚至不会安装图形管理软件包，而是直接使用文本模式安装，因此登陆后直接面对的就是命令行的界面 Linux命令行提示符介绍Linux命令行结尾的提示符有 “#” 和 “$” 两种不同的符号 # 是超级管理员root用户对应的命令行 $ 是普通用户oldboy对应的命令行 命令行的快捷键1234567891011121314151617181920tab 命令或路径等的补全键，Linux最有用的快捷键Ctrl+a 光标回到命令行行首Ctrl+e 光标回到命令行行尾Ctrl+f 光标向右移动一个字符（相当于方向键右键）Ctrl+b 光标向左移动一个字符（相当于方向键左键）Ctrl+insert 复制命令行内容shift+insert 粘贴命令行内容Ctrl+k 剪切（删除）光标处到行尾的字符Ctrl+u 剪切（删除）光标处到行首的字符Ctrl+w 剪切（删除）光标钱的一个单词Ctrl+y 粘贴上面三个剪贴的内容Ctrl+c 中断终端正在执行的任务或者删除整行!! 执行上一条命令!pw 执行最近以pw开头的命令!pw:p 仅打印最近以pw开头的命令，不执行!num 执行历史命令列表的第num条命令!$ 上一条命令的最后一个参数Esc+. 获取上一条命令最后的部分Esc+b 移动到当前单词的开头Esc+f 移动到当前单词的结尾 Linux命令行下查看命令帮助man命令man命令是Linux系统中最核心的命令之一，因为通过它可以查看其他linux命令的使用信息，当然还可以查看软件的配置文件、系统调用、库函数等的帮助信息 语法格式man 参数选项 命令/文件 参数选项数字参数说明解释说明1User Commands用户命令相关2System Calls系统调用相关3C Library FunctionsC的库函数相关4Devices and Special Files设备和特殊文件相关5File Formats and Conventions文件格式和规则6Games et. AI.游戏及其他7Miscellanea宏，包，及其他杂项8System Administration tools and Deamons系统管理员命令和进程 查阅的内容格式man帮助信息中的标题功能说明NAME命令说明介绍SYNOPSIS命令的基本使用语法DESCRIPTION命令行使用详细描述，以及相关参数选项说明OPTION命令相关参数选项说明COMMANDS在执行这个程序的时候，可以在此程序中执行的命令FILES程序涉及的相关文件EXAMPLES命令的一些例子SEE ALSO和命令相关的信息说明BUGS（REPORTIONG BUGS）命令对应缺陷问题的描述COPYRIGHT坂玄信息相关声明AUTHOR作者介绍 –help获取命令帮助使用起来很简单啦，就是 “ 命令 –help “ 使用方法--help 获取的是常用的帮助信息， man命令获取的是更过更复杂的帮助信息 例如： mv --help help获取bash内置命令在Linux系统里有一些特殊的命令，他们就是bash程序的内置命令，例如：cd，ls……这些命令并不存在真实的程序文件，对于这些命令，查看帮助的方式就是使用help 使用方法help 命令 例如： help cd info获取帮助信息Linux系统中的info命令是一个查看程序对应文档的命令，可以作为man及help命令的帮助补充，用的少 使用方法info 命令 例如： info ls 从互联网获取命令帮助信息简单一条 百度，google，总之怎么快怎么来。 Linux的关机，重启，注销命令shutdown命令使用方法及例子shutdown [OPTION]... TIME[MESSAFE] shutdown [选项] 时间 信息 通常形况下，一般用的比较多的就是 shutdown -h now 或者 shutdown -r now 例子： shutdown -h +1 #一分钟后关机 shutdown -r 11:00 #十一点关机 参数选项解释说明-r重启系统，而不是关机-h关机-H关机，但是并不是完全关机，不常用-P关机，不常用-c取消正在执行的shutdown命令-k只发送关机提示，但是并不关机，就闹着玩玩​##### 工作原理shutdown命令的工作原理为：一旦到达关机时间，shutdown命令就会发送请求给系统的init进程将系统调整到合适的运行级别（运行级别请参考runlevel命令，运行级别请查看/etc/inittab文件说明），其中0表示关机，6表示重启。所以，执行 “init 0”就表示关机，执行”init 6”表示重启#### halt/poweroff/reboot 重启关机命令##### 语法格式 reboot [OPTION]… halt [OPTION]… poweroff [OPTION]… 通常情况下，执行这三个命令不带任何参数##### 使用 halt #就是直接关机 reboot #就是直接重启 poweroff #就是直接关机#### 一些常见的关机，重启，注销命令命令说明shutdown -h now立刻关机shutdwn -h +1一分钟后关机，+1也可以是时间点，例如：11：00halt立刻停止系统，需要人工关闭电源init 0切换运行级别到0，关机poweroff立刻停止系统，并且关闭电源reboot立刻重启shutdown -r now立刻重启shutdown -r +1一分钟后重启init 6切换运行级别到6，重启logout注销退出当前用户exit注销退出当前用户窗口 文件和目录操作命令pwd 显示当前所在的位置命令详解pwd命令是 &quot;print working directory&quot;中每个单词的首字母缩写，其功能是显示当前工作目录的绝对路径。 语法格式pwd [option] pwd [选项] 选项说明参数选项解释说明-Llogical首字母缩写，表示显示逻辑路径，取PWD系统环境变量的值-Pphysical首字符缩写，表示显示物理路径时如果当前目录路径是软链接文件，则会显示软链接文件对应的源文件 查看命令帮助时，我们经常会看到 &quot;-L,--logical&quot; 这样的选项格式，这种写法的意思是 -L 和 --logical 的功能是一样的。 高级范例为什么管理员会用到pwd命令呢？这是因为我们通过命令行管理Linux时，经常会切换到不同的路径，而输入pwd命令可以随时查看当前的路径是什么。其实，在喜荣忠使用Bash命令行就会自动显示用户当前所在的路径，但是默认情况下这种路径显示不全。 当然可以通过修改PS1对应的值来改变； 修改PS1PS1含义\d代表日期，格式为 weekday month date\H完整的主机名称\h仅取主机的第一个名字\t显示时间为24小时格式，如：HH：MM：SS\T显示时间为12小时格式\A显示时间为24小时格式，如：HH：MM\u当前用户的账号信息\vBASH的版本信息\w显示完整的路径，其中家目录会以~替代\W利用basename取得工作目录名称，所以只会列出最后一个目录#执行的第几条命令\$提示字符，root用户为#，否则为$ 因此，要查看当前PS1变量的值，可采用如下命令： echo $PS1 #打印超级管理员对应的PS1值 打印出：[\u@\u \W]\$ # @时一个分隔符，和邮箱地址中的@作用类似 修改PS1变量对应的值： PS1=&apos;[\u@\h \w]&apos; #此命令仅临时生效 编辑 /etc/bashrc 文件，找到这个语句 [&quot;$PS1&quot;=&quot;\\s-\\v\\\$&quot;]&amp;&amp;PS1=&quot;[\u@\h \W]\\$&quot; 修改为：[&quot;$PS1&quot;=&quot;\\s-\\v\\\$&quot;]&amp;&amp;PS1=&quot;[\u@\h \w]\\$&quot; 最后注销重启就行了 cd 切换目录功能说明cd命令时 &quot;change direcotry&quot;中每个单词的首字母缩写，其功能时从当前工作目录切换到制定的工作目录 语法格式cd [option] [dir] cd [选项] [目录] 参数选项解释说明-P如果切换的目标目录是一个软链接，则会直接切换到软链接指向的真正物理目标目录，和pwd命令的-P选项功能类似-L功能与-P相反，如果切换的目标目录是一个软连接，则直接切换到软链接所在的目录-当只使用”-“选项时，将会从当前目录切换到系统环境变量”OLDPWD”对应值的目录路径~当只是用”~”选项时，将会从当前目录切换到系统环境变量”HOME”对应值的目录路径..当只是用”..”选项时，将会从当前目录切换到当前目录的上一级目录所在的路径 使用范例 cd /etc 进入系统etc目录 cd .. 返回上一级目录 cd ../../ 退回当前目录的上两级目录 cd ~ 切换到家目录 cd - 返回当前用户上一次所在的目录 mkdir创建目录 mkdir命令是”make directories”中每个单词的字母组成，其功能是创建目录，默认情况下要创建的目录已存在，则会报错。 语法格式mkdir [optioin] [directory] mkdir [选项] [目录] mkdir 可以同时创建多个目录，格式为 mkdir dir1 dir2 dir3 ... 选项说明参数选项解释说明-p递归创建目录，即使要创建的目录已经存在也不会报错提示目录存在-m设置新创建目录的默认目录对应的权限-v显示创建目录的过程 例子 mkdir data #创建data文件夹 mkdir oldboy/test #创建oldboy文件夹并在oldboy目录下创建test目录 mkdir -pv oldboy1/test#创建oldboy目录并在oldboy目录下创建test目录，同时显示过程 mkdir -m 333 dir2 #创建dir2目录，并且设置权限为333 mkdir -pv oldboy/{dir1_1,dir1_2}/{dir2_1, dir2_2}… 解释： mkdir: created direcory ‘oldboy/dir1_1’ mkdir: created direcory ‘oldboy/dir1_1/dir2_1’ mkdir: created direcory ‘oldboy/dir1_1/dir2_2’ mkdir: created direcory ‘oldboy/dir1_2’ mkdir: created direcory ‘oldboy/dir1_2/dir2_1’ mkdir: created direcory ‘oldboy/dir1_2/dir2_2’ touch 创建空文件或改变文件的时间戳属性 touch 有两个功能 创建新的空文件 改变已有文件的时间戳属性 语法格式touch [optioini] [file] touch [选项] [文件] touch 是创建空的文件， mkdir 是创建空的目录，是不一样的 选项说明参数选项解释说明-a只更改指定文件的最后访问时间-d STRING使用字符串STRING代表的时间作为模板设置指定文件的时间属性-m只更改指定文件的最后修改时间-r file将指定问及爱你的时间属性这是为与模板文件file的时间属性相同-t STAMP使用[[CC]YY]MMDDhhmm[.ss]格式的时间设置文件的时间属性，从左到右依次是：世纪，年，月，日，时，分，秒 使用范例 touch test.txt #创建空的文件test.txt touch a.txt b.txt #同时创建多个文件 touch stu{01..05}.txt #同时创建01~05文件 stat test.txt #用stat命令查看文件是时间戳属性 touch test.txt #更改最后的修改的时间为当前时间 touch -d 20201001 test.txt#修改时间更改为2020年 touch -r a.txt test.txt #修改test.txt的时间属性与a.txt时间属性一致 时间戳形式 stat命令对应的时间戳 Access: 最后访问时间 Modify: 最后修改文件时间 Change: 最后改变文件状态的时间 ls命令对应的时间戳 mtime: 最后修改时间(ls -lt) ctime: 状态改变时间(ls -lc) atime: 最后访问时间(ls -lu) ls 显示目录下的内容及相关属性 ls命令可以理解为英文单词list的缩写，其功能是列出列表的内容及其内容属性 语法格式ls [option] [file] ls [选项] [&lt;文件或目录&gt;] 选项说明参数选项解释说明-l使用长格式列出文件及目录信息-a显示目录下的所有文件，包括以’.’字符开始的隐藏文件-t根据最后的修改时间(mtime)排序，默认是按文件名排序-r以相反次序排序-F在条目后加上文件类型的只是符号(*,.,=,@,|中的一个)-p直在目录后面加上 ‘/‘-i显示inode节点信息-d当遇到目录时，列出目录本身而非目录内的文件，并不跟随符号链接-h以人类可读的信息显示文件或目录大小-A列出所有文件，包括隐藏文件，但不包括’.’’..’-S根据文件大小排序-R递归列数所有子目录-x逐行列出项目而不是逐栏列出-X根据扩展名排序-c根据状态改变时间排序(ctime)-u根据最后访问时间排序(atime)-color={never,always,auto}不同的文件类型显示不同的颜色参数，never不现实，auto自动，always总是显示–full-time以完整的时间格式输出–time-style={full-iso,long-iso,iso,local}以不同的时间格式输出，long-iso效果最好–time={atime,ctiom}按不同的时间属性输出 使用范例 ls #不带参数 ls -a #显示’.’ ls -A #显示所有文件，包括隐藏文件 ls -l #长格式输出文件类型，权限，链接数，属组，时间等 ls -l –time-style=long-iso #以long-iso方式显示时间 ls -F #显示文件，文件夹后加上’/‘ 当然你也可以用alias方法给原本很长ls命令取个别名 alias lst=’ls -l –time-style=long-iso’ 给 ls -l –time-style=long-iso 起别名为 lst ls -F #给文件夹后加上’/‘，其他文件加上其他字符 ‘*’ 可执行的普通文件 ‘/‘ 目录 ‘=’ 套接字(sockets) ‘|’ FIFOS ‘@’ 符号链接 ls -lhi 命令对应列数意义 第一列： inode索引节点的编号 第二列: 文件类型及权限 第三列： 硬连接个数 第四列: 文件或目录所属的用户 第五列： 文件或目录所属的组 第六列： 文件或目录的大小 第七，八，九列： 文件或目录的修改时间 第十列： 实际的文件名或目录名 cp 复制文件或目录 cp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录 语法格式cp [option] [source] [dest] cp [选项] [源文件] [目标文件] 选项说明参数选项解释说明-p复制文件时保持源文件的所有者，权限信息及时间属性-d如果复制的源文件是符号链接，那么仅复制链接本身，而且保留符号链接所指向的目标文件或目录-r递归复制目录，即复制目录下的所有层级的子目录及文件-a等同于上面的p,d,r这三个选项功能的综合-i覆盖已有文件前提示用户确认-t默认情况下命令格式是 ‘cp源文件 目标文件’，使用-t后变成 ‘cp 目标文件 源文件’ 使用范例 cp -i test.file file1.test 系统信息arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 文件和目录cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \*.rpm -exec chmod 755 &apos;{}&apos; \; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &apos;%10{SIZE}t%{NAME}n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=&apos;${Installed-Size;10}t${Package}n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户 grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;{print $1}&apos; 查看一行第一栏 echo a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &apos;eth0&apos; 网络设备 ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &apos;eth0&apos; route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &apos;192.168.0.0/16&apos; route del 0/0 gw IP_gateway remove static route echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &apos;eth0&apos; ethtool eth0 show statistics of network card &apos;eth0&apos; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database]]></content>
  </entry>
  <entry>
    <title><![CDATA[BootStrap框架]]></title>
    <url>%2F2017%2F10%2F22%2FBootStrap%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[什么是BootStrap bootstrap 是当下非常经典且流行的前端框架（界面工具集）很多公司的前后端项目都有继承bootstrap bootstrap的特点：灵活借简洁，代码优雅，美观大方，直观强悍的前端开发框架 GitHub：https://github.com/twbs/boostrap 官网： http://www.bootcss/com/ http://getbootstrap.com/ 使用Bootstrap npminstall bootstrap –save (通过npm进行安装，适合工程化开发，比如集成到react或者Node项目中) gitHub直接下载 (适合起步，全面学习) Bootstrap初始化模板123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;test1&lt;/title&gt; &lt;link rel="stylesheet" href="utlise/bootstrap-3.3.7-dist/css/bootstrap.min.css"&gt; &lt;link href="css/index.css" rel="stylesheet"&gt; &lt;!-- &lt;script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt; --&gt; &lt;script src="utlise/jquery-3.3.1.js" &gt;&lt;/script&gt; &lt;script src="utlise/bootstrap-3.3.7-dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自己的定义的css和js一定要在bootstrap定义的css和js之后，以免bootstrap定义的东西覆盖了我们定义的 使用Boosstrap在官网中查看信息即可 https://v3.bootcss.com/components/#glyphicons https://v3.bootcss.com/css/#overview 例如字体图标1&lt;span class="glyphicon glyphicon-envelope" style="font-size:40px"&gt;&lt;/span&gt; 这样的一个文字信息图标就出来了 进图条12345&lt;div class="progress"&gt; &lt;div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%;"&gt; 60% &lt;/div&gt;&lt;/div&gt; 面板 panel123456&lt;div class="panel panel-default panel-success"&gt; &lt;!-- 面板类似于一个栏目框，heading为标题，panel-success 只可以改变标题颜色 --&gt; &lt;div class="panel-heading"&gt;面板标题&lt;/div&gt; &lt;div class="panel-body"&gt;面板内容&lt;/div&gt; &lt;div class="panel-footer"&gt;面板脚注&lt;/div&gt;&lt;/div&gt; 模态框1234567891011121314151617181920212223 &lt;!-- Button trigger modal --&gt;&lt;button type="button" class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal"&gt; Launch demo modal&lt;/button&gt;&lt;!-- Modal --&gt;&lt;div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; ... &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;Close&lt;/button&gt; &lt;button type="button" class="btn btn-primary"&gt;Save changes&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 轮播图Carousel1234567891011121314151617181920212223242526272829303132333435&lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="..." alt="..."&gt; &lt;div class="carousel-caption"&gt; ... &lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; 其他的自行学习综合案例响应式页面因为页面不仅要跑到pc端，还要跑到手机端，所以页面要做成响应式的页面 开启视口模式 1&lt;meta name="viewport" content="width=decice-witdth, initial-scalse=1.0"&gt; 自己写自适应css123456789101112131415161718192021222324@media screen and (max-width: 768px)&#123; .contariner&#123; width: 100%; &#125;&#125;@media screen and (min-width: 760) and (max-width: 992px)&#123; .contariner&#123; width: 750px; &#125;&#125;@media screen and (max-width: 992) and (max-width: 1200px)&#123; .contariner&#123; width: 970px; &#125;&#125;@media screen and (min-width: 1200)&#123; .contariner&#123; width: 1170px; &#125;&#125; 这些参数值都是根据上面的 栅格参数 制定的 js12345678910111213141516171819window.addEventListener("load", functino()&#123; //获取常量 类 和 屏幕宽高 let contariner = document.querySelector(".container"); let clientw = 0; // 监听窗口的大小变化 window.addEventListener("resize", function()&#123; clientw = window.innerWidth; if(clientw &gt;= 1200) &#123;//超大屏幕 container.styler.width = "1170px"; &#125; else if(client &gt;= 992) &#123;//大屏幕 container.styler.width = "970px"; &#125; else if(client &gt;= 760) &#123; //小屏幕 container.styler.width = "750px"; &#125; else &#123; container.styler.width = "100%"; &#125; &#125;)&#125;); 设计页面栅格布局，bootstrap 把一行分成12列，可以通过自由组合，去组成12列 bootstrap 也帮你定义好了这 12 种去实现 如果想要某些模块在小屏幕不显示 可用： 文字样式 之后选择下载，解压，导入到工程种 其中 icon-wifi 的 content 的值 来自于 网页demo中 注意 content 中 &quot; \ &quot;的方向，切忌写反 然后就可以直接在 &lt;span class=&quot;icon-wifi&quot;&gt;&lt;/span&gt;中使用即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux 基础]]></title>
    <url>%2F2017%2F10%2F16%2FKali-Linux-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Proxy基本原理正向代理 终端机访问外部互联网资源，并不是直接连接到互联网上，而是通过一个代理主机，或者代理软件 可能是在一个路由器中，网关上，或者在某个终端机中 数据回来的时候也是通过代理返回的 访问本无法访问的服务器通过在香港的主机的代理服务，访问Google官网 Cache作用把一些请求直接缓存到代理服务器上 客户端访问授权对某些资源只允许代理服务器访问，而不允许终端机访问，从而禁止终端用户直接连接服务器上的资源 隐藏访问者的行踪配置代理服务用到的ip或者Cookie信息，来隐藏访问者的行踪 反向代理透明代理]]></content>
  </entry>
  <entry>
    <title><![CDATA[从0开始的JavaWeb---java篇]]></title>
    <url>%2F2017%2F10%2F13%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb-java%E7%AF%87%2F</url>
    <content type="text"><![CDATA[软件系统体系结构B/S1. B/S结构即浏览器/服务器（Browser/Server） 优点只需要编写服务器端程序 缺点安全性差 C/S1. C/S 结构即 客户端/服务器（Client/Server），例如QQ 2. 需要编写服务器程序，以及客户端程序，例如我们安装的就是QQ的客户端 缺点软件更新时需要同时更新客户端和服务器两端，比较麻烦 优点安全性比较好 Web资源Web资源介绍1. html：静态资源 2. Jsp/Servlet：动态资源 当然除了JavaWeb程序，还有其他Web程序，例如：ASP，PHP等。 静态资源和动态资源的区别 访问Web资源打开浏览器，输入URL： 协议名：//域名：端口/路径，例如：https://www.baidu.com:8080/index.html Web服务器Web服务器的作用时接收客户端的请求，给客户端做出响应。 对于JavaWeb程序而言，还需要有Jsp/Servlet容器，Jsp/Servlet容器的基本功能是把动态资源转会为静态资源，当然Jsp/Servlet容器不知这些功能。 我们需要使用的是Web服务器和Jsp/Servlet容器，通常这两者会集于一身。下面是对JavaWeb的服务器： 1. Tomcat(Apache):当前应用最广的JavaWeb服务器 2. JBoss(RedHat红帽):支持JavaEE，应用比较广 3. GlassFlsh(Orcale):ORacle开发JavaWeb服务器，应用不是很广 4. Resin(Caucho)：支持JavaEE，应用越来越广 5. Weblogic(Orcale):要钱的！支持JavaEE，适合大型项目 6. Websphere（IBM）：要钱的！支持JavaEE，适合大型项目 TomcatTomcat简述Tomcat服务器由Apache提供，开源免费。由于Sun和其他公司参与到了Tomcat的开放中，所以最新的Jsp/Servlet规范总是能在Tomcat中体现出来。 配置Tomcattomcat的安装自行百度 tomcat端口改变自行百度 tomcat配置自行百度 Tomcat目录结构 /work tomcat把由jsp生成的servlet放于目录下 /webapps 当发布web应用时，默认情况下把web应用文件放于次目录下 /logs 存放tomcat的日志文件 /share/lib 存放所有web应用都可以访问的jar文件 /common/lib 存放tomcat服务器以及所有web应用都可以访问的jar应用 /server/webapps 存放tomcat自带的两个web应用：admin应用和manager应用 /server/lib 存放tomcat服务器所需的jar文件 /server 包含三个子目录：classes。lib和webapps /conf 存放tomcat服务器的各种配置文件，其中最重要的文件是server.xml /bin 存放Windows平台以及linux平台上启动和关闭tomcat的脚本文件 Web应用创建一个静态网站1. 在webapps目录下创建一个目录（命名必须不包含中文和空格），这个目录则为项目目录 2. 在项目目录下创建一个html文件 创建一个动态网站1. 在webapps目录下创建一个项目目录 2. 在项目目录下创建如下内容 1. WEB-INF目录 1. WEB-INF目录下创建web.xml文件 1. xml文件中的内容，可以从其他的项目中复制 2. 创建一个lib目录，用户存放jar包 3. classes目录，用于存放自己写的class 2. 创建静态或动态页面 WEB-INF下的项目，浏览器是不能访问的，所以为了安全起见，所以一些文件必须放到WEB-INF文件 配置外部应用方法一conf/server.xml:打开server.xml文件，找到&lt;Host&gt;元素，在其中添加&lt;Context&gt;元素： &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeplay=&quot;true&quot;&gt; &lt;Context path=&quot;hello&quot; docBase=&quot;C:/hello&quot;/&gt; &lt;/Host&gt; 1. path：制定当前应用的名称 2. docBase：指定应用的物理位置 3. 浏览器访问路径：http://localhost:8080/hello/index.xml ​ 方法二conf/catalana/localhost：在该目录下创建hello.xml文件，在该文件编写&lt;Context&gt;元素 &lt;Context docBase=&quot;C:/hello&quot;&gt; 1. 文件名：指定当前应用的名称 2. docBase：指定应用的物理位置 3. 浏览器访问路径：http://localhost:8080/hello/index.xml servet.xml的配置1. &lt;Service name=&quot;Catalina&quot;&gt; 服务，名字为catalina 服务中又有很多连接 &lt;Connector&gt; 2. &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt; 用于接待HTTP/1.1的服务，端口是80端口，不处理请求 3. &lt;Engine&gt; 引擎，用于处理请求，引擎下又分很多主机&lt;Host&gt; 4. &lt;Host name=&quot;主机名&quot; appBase=&quot;基础目录&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;主机下又有&lt;Context&gt;上下文 5. &lt;Context&gt; 上下文，对应的就是一个项目 6. servet.xml中还有很多监听器 7. 引擎唯一的，Service唯一的，Host可以多个，Context可以多个 Servlet什么是ServletServlet是javaWeb的三大组件之一，它属于动态资源。 Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 1. 接收请求数据 2. 处理请求 3. 完成响应 例如客户端发出登陆亲求，或者输出注册请求，这些请求都应该由Servlet来完成处理！ Servlet需要我们自己来编写，每个Servlet必须实现javax.servlet.Servlet接口 实现Servlet的方式实现Servlet的三种方式： 1. 实现javax.servlet.Servket接口 2. 继承javax.servlet.GenericServlet类 3. 继承javax.servlet.http.HttpServlet类 我们通常会去继承HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口开始 使用Servlet servlet的方法是由tomcat调用的方法 1. init() 1. 在Servlet对象创建之后马上执行，并且只执行一次 2. service() 1. 会被调用多次，每次处理请求都是调用这个方法 3. destroy() 1. 在Servlet被销毁之前调用，并且它只会被调用一次 4. getServletConfig() 1. 获取Servlet的配置信息（从init函数中，可以获得Servlet的配置信息） 5. getServletInfo() 1. 获取Servlet的信息（没什么用） 浏览器访问Servlet1. 给Servlet指定一个Servlet路径（让Servlet与一个路径绑定在一起） 1. 需要在web.xml中对Servlet配置 2. &lt;servlet&gt; &lt;servlet-name&gt;XXX随意&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet的路径&lt;servlet-class&gt; &lt;/servlet&gt; 3. &lt;servlet-mapping&gt; &lt;servlet-name&gt;与上面的name相同&lt;/servlet-name&gt; &lt;url-pattern&gt;/虚拟路径 例如：/aa/b/c&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2. 浏览器访问Servlet路径 1. localhost:8080/项目名/虚拟路径名 特性1. 单例，一个类只有一个对象；当然可能存在多个Servlet类 2. 线程不安全的，效率高 3. Servlet由程序员写，但对象由服务器创建，调用响应的方法 Servlet细节Servlet与线程安全因为一个类型的Servlet只有一个实例对象，那么就有可能会出现同一个时间一个Servlet同属处理多个请求 那么Servlet是否为线程安全呢？ 答案是“不是线程安全的” 这说明Servlet的工作效率很高，但也存在线程安全问题 所以我们不应该在Servlet中随意创建成员变量 因为可能会存在一个线程这个成员变量进行写操作，另一个线程对这个成员变量进行读操作 1. 不要在Servlet中创建成员！创建局部变量即可 2. 可创建无状态成员 3. 可以创建有状态成员，但是状态必须为只读的 让服务器在启动时就创建Servlet默认情况下，服务器在某个Servlet第一次收到请求时创建它，也可以在web.xml中进行配置，使服务器启动的时候就创建Servlet &lt;servlet&gt; &lt;servlet-name&gt;hello1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.servlet.HelloWorld&lt;servlet-class&gt; &lt;load-on-startup&gt;非负整数&lt;/load-on-startup&gt; &lt;!-- 非负数，越小越先创建 --&gt; &lt;servlet&gt; &lt;url-pattern&gt;是&lt;servlet-mapping&gt;的子元素，用来指定Servlet的访问路径，即URL 它必须是以 &quot;/&quot; 开头 &lt;servlet-mapping&gt; &lt;servlet-name&gt;text&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;url-pattern&gt;/b&lt;/url-pattern&gt; &lt;url-pattern&gt;/c&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 那么说明这个Servlet绑定了多个url，一般也就一个，你设置多个也没什么用 ServletContext一个项目只有一个ServletContext对象！application 我们可以在N个Servlet中获取这个唯一的对象，使用它可以给多个Servlet传递数据 Servlet之间互不一般是互不联系的，所以信息传递只能通过ServletContext servletContext概述服务器会为每个应用创建一个ServletContext对象： 1. ServletContext 对象的创建时在服务器启动时完成 2. ServletContext 对象的销毁时在服务器关闭时完成 ServletContext对象的作用是在整个Web应用的动态资源之间共享数据！ 例如： 在A_Servlet中项 ServletContext对象中保存一个值，然后再B_Servlet中就可以获取这个值，这就是共享数据 获取ServletContext在Servlet获取ServletContext对象： 1. 在 void init(ServletConfig config)中：ServletContext context = config.getServletContext(); 在GenericeServlet 或 HttpServlet 中获取ServletContext对象： 1. GenericSeriet类中由getServletContext()方法，所以可以直接使用this.getServletContext()来获取 2. HttpServlet中有getServletContext()方法获取 在ServletContextEvent中 1. getServletContext()方法获取 在HttpSession中 1. getServletContext()方法获取 设置，获取对象1. void serAttribute(String name,Objcet value): 这是一个键值对，name与value对应 2. Object getAttribute(String name): 通过名为name 的键，去获得object类型的值 3. void removeAttribute(String name): 移除名为name 的键值对 4. Enumeration getAttributeNames(): 获取所有域属性的名称 获取资源获取真实路径使用ServletContext对象来获取web应用下的资源 例如在hello应用的根目录下出创建a.txt文件，获取方法： String realpath = servletContext.getRealPath(&quot;/a,txt&quot;),realpath的为a.txt的绝对路径 获取资源流可以通过ServletContext获取资源流，即把资源以输入流的方式获取： 1. 获取a.txt资源流 InputStream in = ServletContext.getResourceAsStream(&quot;/a.txt&quot;); 获取指定目录下所有资源路径通过ServletContext获取指定目下所有资源路径 例如获取/WEB-INF下所有的资源路径： Set set = context.getResourcePaths(&quot;/WEB-INF&quot;); Java画图（可用于验证码）BufferedImage bi = new BufferedImage(150, 35, BufferedImage.TYPE_INT_RGB); //得到图片缓冲区，这是长宽，图片格式RGB还是RGBA //得到它的绘制环境（画这张图片的笔） Graphics2D g2 = (Graphics2D) bi.getGraphics(); g2.setColor(Color.WHITE);//设置颜色 g2.fillRect(0,0,79,35);//填充图片，就是设置背景色 g2.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 25));//设置字体 //Font.BLOD 为字体格式，比如blod就是粗体 g2.setColor(Color.BLACK);//设置颜色 ge.drawString(&quot;hell0&quot;, point.x, point.y);//向图片区域中写String的内容 ImageIO.write(bi, &quot;JPEG&quot;, new FileOutputStream(&quot;F:/a.jpg&quot;));//输出流，bi为图片缓冲区，&quot;JPEG&quot;为图片格式 response和request都是由服务器产生 服务器每次收到请求时，都会为这个请求开辟一个新的线程 服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体 服务器还会创建response对象，这个对象和客户端连接在一起，他可以用来向客户端发送响应 responseServletResponse ---&gt; 与协议无关的类型 HtppServletResponse ----&gt; 与http协议相关的类型 二者无关，传入到Servlet中的时HttpServletResponse，所以可以强转为response http协议中响应内容包括什么呢？ 状态码200 表示成功， 302 表示重定向， 404 表示客户端错误， 500表示服务器端错误 1. sendError(int sc) 2. sendError(int sc, String msg) 3. setStatus(int sc) 例如： 发送404 response.sendError(404, &quot;您访问的资源存在，就是不给你看&quot;); 响应头响应头：Content-Type,Refresh,Location等 1. setHeader(String name, String value):适用于单值的响应头 2. addHeader(String name, String value):适用于多值的响应头 3. setIntHeader(String name, String Value):适用于单值的int类型的响应头 4. addIntHeader(String name, String value):适用于多值int类型的响应头 5. setDateHeader(String name, long value):适用于单值的毫秒类型的响应头 6. addDaTeHeader(String name, long value):适用于多值的毫秒类型的响应头；long型值为 毫秒值，代表过期时间， 例如： 发送302，设置location头，完成重定向 response.setHeader(&quot;Location&quot;,&quot;/项目名/servlet路径&quot;); response.setStatus(302); 定时刷新，设置Refresh头，其实就是定时重定向 PrintWriter write = rsponse.getWriter(); writer.print(&quot;欢迎登陆，5秒后自动跳转到主页&quot;); response.setHeader(&quot;Redresh&quot;, &quot;5;URL=/项目名/重定向的servlet或jsp&quot;); 禁用浏览器缓存：Cache-Control, prama, expires response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); response.setHeader(&quot;prame&quot;,&quot;no-cache&quot;); response.setDateHeader(&quot;expires&quot;,-1);//过期时间-1，立马过期 &lt;meta&gt;标签可以代替响应头 响应体通常是html，也可以是图片 response的两个流： 1. ServletOutPutStream,用来向客户端发送字节数据 ServletOutputStream out = response.getOutputStream(); 2. PrintWriter,用来向客户端发送字符数据!需要设置编码 PrintWriter writer = response.getWriter(); 两个流不能同时使用 发送字节流： String s = &quot;hello world&quot;; byte[] bytes = s.getBytes(); response.getOutputStream().write(bytes); 发送字节图片： //运用commons-io库 String path = &quot;a.jpg&quot;; FileInputStream in = new FileInputStream(); //读取输入流内容的字节到字节数组中 byte[] bytes = IOUtils.toByteArray(int); response.getOutputStream().write(bytes); 重定向这个重定向不同与上面的重定向，这个更快 sendRedirect(String location)方法 response.sendRedirect(&quot;/项目名/servlet虚拟路径或jsp名&quot;); request封装了客户端所有的请求数据 Http协议中的数据都可以通过request对象来获取 获取常用信息获取客户端Ip，请求方式 Ip：request.getRemoteAddr(); 请求方式：request.getMethod(); 获取请求头String getHeader(String name),适用于单值头 int getIntHeader(String name),适用于单值int类型的请求头 long getDateHeader(String name),适用于单值毫秒类型的请求头 Enumeration&lt;String&gt; getHeaders(String name),适用于多值请求头 例如： 通过user-agent识别用户浏览器类型 request.getHeader(&quot;User-Agent&quot;); 防盗链：如果请求不是通过本站发出的超链接发出的，发送错误状态码404 Refere这个请求头，表示请求的来源 String referer = req.getHeader(&quot;Rederer&quot;); if(referer == null || referer.contains(&quot;localhost&quot;)){ resp.sendRedirect(&quot;https://www.baidu.com&quot;); System.out.println(&quot;baidu&quot;); } else{ System.out.println(&quot;hello&quot;); } 获取请求URLString getScheme();获取协议 String getServerName();获取服务器名 String getServerPort();获取服务器端口 String getContextPath();获取项目名 String getServletPath();获取Servlet路径 String getQueryString();获取参数部分，即问好后面的部分 String getRequestURI();获取请求URI，等于项目名+Servlet路径 String getRequestURL();获取请求URL，等于不包含参数的整个请求路径 获取请求参数请求参数时由客户端发送给服务器的 1. 有可能在请求体中（post） 2. 可能在URL中（get） 1. String getParameter(String name):获取指定名称的请求参数值，适用于单值请求 2. String[] getParameterValues(String name);获取指定名称的请求参数值，适用于多值请求参数 3. Map&lt;String, String[]&gt; getParameterMap():获取所有请i去参数，其中key为参数名，value为参数值， 例如： 超链接参数 表单数据 请求转发和请求包含RequestDispatcher rd = request.getRequestDispatcher(&quot;/MyServlet&quot;);//参数是被包含或被转发的Servlet虚拟路径 请求转发：rd.forward(request,response);（常用） 请求包含：rd.include(request,response); 有时一个请求需要多个Servlet协作才能完成，所以需要一个Servlet跳到另一个Servlet 1. 一个请求跨多个Servlet，需要使用转发和包含 2. 请求转发：由下一个Servlet完成相应体，当前Servlet可以设置响应头（留头不留体） 1. 即request.setHeader()中的内容，可以传递到第二个servlet 2. response.write()这类的内容不会传递回去，即第一个Servlet的内容不会输出浏览器 3. 请求包含：由两个Servlet共同完成相应体（都留） 4. 物理是请求转发还是请求包含，都在一个请求范围内，使用同一个resquest和response 请求转发与重定向不同1. 请求转发是一次请求，重定向是两次转发 2. 请求转发地址栏不变，重定向后会显示一个请求的地址 3. 请求转发只能转发到本项目其他servet，而重定向哪都能去 4. 请求转发为服务端行为，重定向是客户端行为 request域Servlet中三大域对象：request,session,application, 1. void setAttribute(String name); 2. Object getAttribute(String name); 3. void removeAttribute(String name); 同一个请求范围内使用request.getAttribute()和request.setAttribute()可以使用 但是如果是重定向则不能获取，因为不是同一个请求 编码常见字符编码：iso-8859-1（不支持中文），gbk（系统默认编码，中国的国标码），utf-8（万国码，支持全世界的编码，所以我们要使用这个） 响应编码1. 当使用response.getWriter()来向客户端发送字符数据时 如果在之前没有设置编码，那么默认使用iso，以为不支持中文，所以一定是乱码 2. 在使用response.getWriter()之前可以使用response.setCharaceterEncoding() 来设置字符流的编码为gbk或utf-8 3. 在使用response.getWriter()之前可以使用resonse.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;) 来设置响应头，通知浏览器服务器这边使用的utf-8 4. serHeader(&quot;Content-Type&quot;,&quot;text/html;charset=utf-8&quot;)的快捷方式是:setContentType(&quot;text/html;charset=utf-8&quot;); 请求编码1. 客户端发送给服务器的请求参数是什么编码： 请求页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是是什么 2. 服务器默认使用ISO-8859-1来解码，所以中文肯定出现乱码 3. 请求编码处理分为两种：get，post：get请求参数不再请求体中，而post请求参数在请求体中，所以处理方式不同 GET请求编码处理1. Sting username = request.getParameter(&quot;name&quot;); 2. byte[] bytes = name.getBytes(&quot;ISO-8859-1&quot;); 3. name = new String(bytes, &quot;utf-8&quot;); 4. 在server.xml中配置URIEncoding=utf-8 POST请求编码处理1. String usernmae = new String(request.getParameter(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); 2. 在获取参数之前调用request.setCharacterEncoding(&quot;utf-8&quot;); URL编码表单的类型：Content-Type:application/x-www-form-urlencoded 就是把中文转换为%后面跟随两位16进制 1. 他不是字符编码 2. 它是用来在客户端和服务器之间传递参数用的一种方式 3. URL编码需要先指定一种字符编码，把字符串解码后得到byte[], 然后把小于0的字节+256，再转换为16进制，前面再加% 4. POST请求默认就是使用URL编码，tomcat会自动使用URL编码 5. URL编码：String name = URLEncoder.encode(name, &quot;utf-8&quot;); 6. URL解码：String name = URLDecoder.decode(name,&quot;utf-8&quot;); 路径1. web.xml中&lt;url-pattern&gt;路径 要么以“*”开头要么以&quot;/&quot;开头 2. 转发和包含路径 1. 以&quot;/&quot;开头：相对当前项目路径 2. 不以&quot;/&quot;开头：相对当前Servlet路径 3. 重定向路径（客户端路径） 1. 以&quot;/&quot;开头：相对当前主机，所以必须后面自己加上项目名 4. 页面中超链接和表单路径 1. 与重定向相同，都是客户端路径，需要添加项目名 2. &lt;form action=&quot;/项目/servlet&quot;&gt; 3. 如果不已&quot;/&quot;开头，那么相对当前页面所在路径 4. 建议使用以&quot;/&quot;开头的路径，因为如果页面路径改变，那么servlet就找不到了 5. ServletContext获取资源路径 1. 相对于当前项目目录，即index.jsp所在路径 6. ClassLoader获取资源路径 1. 相对classes目录 7. Class获取资源路径 1. 以&quot;/&quot;开头，相对Classes目录 2. 不以&quot;/&quot;开头，相对当前.class文件所在目录 JSPjsp程序是java为了适应web开发而扩展的一种程序形式，是java程序针对web开发进行的简化。 用户通过浏览器向服务器发送指定页面的请求，接下来web服务器读取jsp文件，jsp文件会被转换为一个普通 java文件，java文件进行编译，得到一个class文件，web服务器装在解释执行class文件，并将执行结果响应至客户端。 tomcat把为每个jsp页面创建的java文件和class 文件，放在安装目录下的 \work\Catalina\localhost\同名文件夹内。 JSP的作用Servlet： 1. 缺点：不适合设置html响应体，需要大量的response.getWriter().print(html); 2. 优点：动态资源，可以编程 html: 1. 缺点：html是静态页面，不能包含动态信息 2. 优点：不用为输出html标签而发愁 JSP： 1. 优点：在原有html的基础上添加java脚本，构成jsp页面 JSP和Servlet的分工JSP： 1. 作为请求发起页面，例如显示表单，超链接 2. 作为请求结束页面，例如显示数据 Servlet： 1. 作为请求中处理数据的环节 JSP的组成1234561. JSP = html + java脚本 + jsp标签（指令）2. jsp中无创建既可使用的对象有9个，被称为9大内置对象，例如：request,out等3. 3中java脚本： 1. &lt;% .... %&gt;：Java片段，用于定义0~N条Java语句 2. &lt;%=....%&gt;：java表达式，用于输出，用于输出一条表达式的结果 3. &lt;%!....%&gt;：声明，用来创建类的成员变量和成员方法(基本不用) jsp声明语法：123456789101112&lt;%! String str = "hello world"; String getStr()&#123; return "hello world2"; &#125;%&gt;声明必须再"&lt;%!" 和 "%&gt;" 之间进行。声明部分只能定义成员方法（函数）和成员变量，不能直接包含程序域。这里定义了一个str变量在jsp文件中使用， 例：&lt;hr&gt;// &lt;hr&gt; 是分割线的意思&lt;% out.println(this.str) %&gt;//通过this 的方法调用变量或者方法（函数）&lt;hr&gt;&lt;% = this.getStr()%&gt;//注意加了一个“=” jsp程序脚本：1234567891011121314151617181920212223242526包括变量的声明，表达式和程序逻辑声明的变量转换为_service 方法中的变量，因而是局部变量语句块可以自由的与页面代码组合使用&lt;% int i = 100; %&gt;// 这里的 i 是脚本变量 上面的 加了 “!”的是成员变量&lt;% if (i &gt; 10) &#123; %&gt; &lt;h1&gt;i &gt; 10 &lt;/h1&gt;&lt;% &#125;else&#123; %&gt; &lt;h1&gt; i &lt;= 10 &lt;/h1&gt;&lt;% &#125; %&gt; // 这里就是 java 和 jsp 的交叉写法。当然而可以直接用out.prinln 但是正常网页中，显示的不会是单调的黑字输出，而是有样式的输出。从下面的例子中可以看出 脚本变量 与 成员变量 的区别：&lt;!% int global = 0 %&gt;&lt;% int test = 0 global ++; test ++;%&gt;&lt;% out.println(global); out.println("&lt;br&gt;"); out.printlin(test);%&gt;将其在加载到eclipse的工程中，然后不断刷新页面，会发现global的值会每次刷新都“+1”，但是test的值总是从0 加到 1就像是全局变量与局部变量的区别。 jsp注释：1234567语法格式：&lt;%--你要注释的内容--%&gt;有点像html 的注释写法，就是多了两个%。但是，jsp既然嵌套了java语言，那么java的注释写法依然是可用的。“//” 单行注释“/* */”多行注释java注释一般多用于 "&lt;%%&gt;" 中 jsp内容输出表达式123456语法格式：&lt;% = 输出的变量名 %&gt;例如：&lt;% int i = 10 %&gt;i 的值是 ：&lt;% = i %&gt;当然你也可以直接用 &lt;% out.println(i) %&gt;，但是嘛 写得多还不好控制格式 jsp包引入语法1234语法格式：&lt;% @ page import = "java.util.Date" %&gt; // 引入一个 java.util.Date 的包&lt;% @ page import = "java.io.*" %&gt; //一次进入多个 java.io. 的包&lt;% @ page import = "java.util.Date, java.io.* "%&gt; //一次引入多个包，用逗号隔开。 JSP的内置对象 out对象 用于向客户端浏览器输出各种数据 request对象 封装了来自客户端浏览器的各种信息 response对象 封装了服务器的响应信息 exception对象 封装了程序执行中的异常和错误信息 config对象 封装了引用程序的配置信息 page对象 指向当前程序本身 session对象 用来保存回话信息，保存同一用户不同请求之间可以共享数据 application对象 代表当前应用程序的上下文，在不同的用户之间共享信息 pageContext对象 提供了对jsp所有命名空间以及对象的访问 out对象 out对象输出 123out.println("文本1"); //向客户端浏览器输出一行文本，最后输出一个换行out.print("文本2"); //想客户端浏览器输出一行文本out.newLine(); //输出一个换行效果 out对象对输出缓冲区进行管理 12out.println("获取当前缓冲区大小：" + out.getBufferSize());out.printlb("当前缓冲区剩余字节数目：" + out.getRemaining()); out.flush()方法，用于强制刷新服务器缓冲区里的数据，也就是说可以手工将缓冲区里的数据输出到浏览器out.clearBuffer()方法，用于清空缓冲区的数据out.clear()方法，用于清空缓冲区的数据，但是（不同于clearBuffer()）如果之前调用过.flush()方法，那么clear()方法则会抛出异常 1234567out.println("文本1"); //向客户端浏览器输出一行文本，最后输出一个换行out.print("文本2"); //想客户端浏览器输出一行文本out.newLine(); //输出一个换行效果//out.flush();out.clearBuffer()l 上述情况中，如果注释了out.flush()方法，那么上述print 将没有输出，因为被clearBuffer了但是如果 放开了注释out.flush()，那么将print到页面中，因为先强制输出了，再清空就没有意义了 request对象 Web 应用程序应该是双向的，不仅仅是服务器向客户端展示数据，同时也有客户端向服务器提交信息 request对象 封装了从客户端到服务器发出的请求信息 客户端ip 用户提交的表单信息 cookie 主机名 …… 服务器通过.getParameter 方法获取用户提交的表单数据 request的大部分方法都是用于处理客户端提交请求中的各种参数和选项 12345678910111213&lt;form action="" method="post"&gt; &lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;请求方法名：&lt;%= request.getMethod() %&gt;获取请求URI字符串，请求的资源：&lt;%= request.getRequestURI() %&gt;(从请求的主机名之后的第一个字符开始，到查询字符串结束的字符串)请求所使用的协议：&lt;%= request.getProtocol() %&gt;获取服务器的名称：&lt;%= request.getServerName() %&gt;请求的服务器端口：&lt;%= request.getServerPost() %&gt;获取客户端的IP地址：&lt;%= request.getRemoteAddr() %&gt;获取客户端的主机名：&lt;%= request.getRemoteHost() %&gt;获取提交的表单数据：&lt;%= request.getParameter("username") %&gt; response对象 用于服务器对客服端的请求进行回应，负责处理http连接信息 设置文件头 cookie信息 …… 12345678910&lt;body&gt; &lt;% response.setHeader("Cache-Control","no-cache"); //设置网页缓存策略为no-cache response.setIntHeader("Refresh", 2);//设置int类型的信息，这里是设置2s刷新一次网页 response.sendRedirect("http://www.baidu.com");//设置跳转 Coolie myCookie = new Cookie("darkmi","Test");//设置键值对 myCookie.setMaxAge(3600);//Cookie的最大存活时间3600s response.addCookie(myCookie);//添加Cookie %&gt;&lt;/body&gt; ​ application对象 代表当前的应用程序，存在于服务器的内存空间中，应用一旦启动，就会自动生成一个application对象 12345&lt;% application.getServerInfo();//返回当前服务器的详细信息 application.getServletContextName();//放回当前应用的名称 application.getVirtualServerName();//获取主机名称%&gt; config对象 代表当前jsp程序的配置信息 config对象是servletConfig类的一个实例 在web.xml文件中添加如下信息 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;config&lt;/servlet-name&gt; &lt;jsp-file&gt;/13/config.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;darkmi&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;Testroot&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;config&lt;/servlet-name&gt; &lt;url-pattern&gt;/13/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 上述代码，添加了两个配置信息 username 和 password 在如下的代码中可以获得config数据 12&lt;%= config.getInitParameter("username") %&gt;&lt;%= config.getInitParameter("password") %&gt; session对象 服务器本身不会记录之前客户端请求的任何信息 用session进行辅助则可以记录客户端之前的信息 12345678&lt;body&gt; 获取session的ID（唯一标识符）：&lt;%= session.getID() %&gt; session的创建时间：&lt;%= new java.util.Date(session.getCreationTime().toString()) %&gt; session的最后访问时间：&lt;%= new java.util.Date(session.getLastAccessedTime()) %&gt; session的失效时间(单位为s)：&lt;%= session.getMaxInactiveInterval() %&gt; 判断session是否是新创建：&lt;%= session.isNew()%&gt; 清除session对象：&lt;%= session.invalidate() %&gt;&lt;/body&gt; 上述代码中，创建时间和访问时间都是long 型，所以需要通过java的Date 类来转换为 可读的时间 exception对象 JSP引擎在执行编译好的代码的时候，可能会抛出异常 exception表示jsp引擎在执行的时候抛出的异常 exception对象需要配置 12&lt;%@ page errorPage="handle_error.jsp" %&gt; &lt;!-- 设置处理异常的jsp --&gt;&lt;%@ page isErrorPage="true" %&gt;&lt;!-- 在处理异常的jsp中配置 --&gt; 12345&lt;%exception.getMessage()方法用于返回描述异常的信息：out.println(exception.getMessage())exception对象的字符串描述：exception.toString()打印异常的堆栈轨迹：exception.printStackTrace()%&gt; page对象 有点类似Java中的this指针，因为page对象指向当前jsp本身 123456&lt;%page对象的字符串描述：out.println(page.toString()) // 字符串 @ 之前是 jsp的完全限定名 之后是HashCode值返回当前的Object类：page.getClass()返回page对象的hashcode值：page.hashCode()比较是否相等：page.equals(object)%&gt; 还有一些与线程相关的方法 pageContext 是jsp中所有对象最大的集成者 12345&lt;% JspWriter myout = pageContext.getOut()// 其他八个内置对象同理%&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法入门 嘤嘤嘤]]></title>
    <url>%2F2017%2F10%2F12%2F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%98%A4%E5%98%A4%E5%98%A4%2F</url>
    <content type="text"><![CDATA[学习算法的建议必备条件1. 数理基础，着力加强 2. 兴趣爱好，能否持久的喜欢它 3. 做事有系统，规范，着眼于大的方面 C++或Java熟练掌握C++或者Java，语言作为基础，即使算法能理解，也无法表示出来 数理基础对于数学定理，公式推导等，要熟悉 数据结构对于数据结构，吃透了能够受益终身。不要指望数据结构，这个东西方面太广，不要只去看你有什么没学，你更要看你学了什么 计算思维思维方式在前人的基础上，形成自己的方式；同时学习一些套路，解题的套路，等等 计算几何计算几何重于计算 凸包问题（计算几何的核心）什么是凸包 凸包就是这样的，由外部的点连成边能够包住所有的点 颜料混合颜料混合问题能够帮助你了解凸包 题目： 给你 x 颜料：红色 10%，绿色 35% 给你 y 颜料：红色 16%，绿色 20% 问你能否组成 U 颜料：红色12%，绿色30% V 颜料：红色13%，绿色22% 如果再给你 Z 颜料：红色7%，绿色15% 你能否组成 V 颜料呢？ 解法将每种颜料构成一个点，我们所拥有的点作为顶点，只要目标点在顶点围成的边界里面，那么就可以得到颜料 如果新生成的颜料正好在边上，那么我们称这个点凸相关，因为这个点对生成新的比例颜料毫无帮助 In-Triangle Test(判断点是否在三角形内) 只要点在直线 PQ，QR，RP 的左边，那么点就在三角形内部。 计算几何中，一般以逆时针方向 bool InTriangle(P, Q, R, S){ bool a = ToLeft(P, Q, S); bool b = ToLeft(Q, R, S); bool c = ToLeft(Q, R, S); return a == b &amp;&amp; b == c; } //因为不知道PQR的排列顺序，虽然图片上是逆时针，但是实际中可能是逆时针可能是顺时针，所以全为True和全为False都成立 转化的思想我们把现实生活转化为数学图形 凸包判断 每个点都有一条穿过它的直线，使得所有的点都落在这条直线的一侧 那么，我们只需要先用前三个点围成一个三角形，再从第四个点判断是否在多边形内，在内部则不加， 不在内部则定位新的顶点，如果新增加的顶点可以围住旧的顶点，那么就去除旧的顶点 InsertionSort栈（Stack）last in,first out 后进先出的数据结构 操作出栈（pop） 入栈（push） InsertionSort（插入排序）对于一串数字进行排序，所用的空间复杂度为O(1),且必须用栈进行排序。 这里我们定义两个栈——L，R，和一个额外的变量int 一开始，数据全部都在R里面，然后依次移动到L栈中： 当 R 中的要移动的数据(R.top()) T 比 L 中最后的数据(L.top())小的时候，将要移动的数据 T 存到 额外空间 int 中 再将 L 中的数据，依次出栈，入栈到R中，直到 L 栈中最后的数据(L.top())比 T 小的时候停止 循环执行上述内容，直到 R 的内容为空的时候停止 这里 用到 new 和 delete 方法，保证内存为O(1) 比较 t 和 L.top()的大小关系的时候，需要判断 L 是否为空 Largest Rectangle in a Histogram(直方图中最大的矩形) 在很多不规则的图形中，找到面积最大的矩形，然后裁剪出来 从某方面看，就是找某种意义上的极值点 分而治之求出最低点K maxRect(h,low,high) k = findPoint(h,low,high); 然后是分别查看最低点的左边和右边 maxRect(h, low, k); maxRect(h, k+1, high); H[k]*(hi-low);]]></content>
  </entry>
  <entry>
    <title><![CDATA[web安全]]></title>
    <url>%2F2017%2F10%2F03%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[安全问题： 1. 用户身份被盗用 2. 用户密码泄露 3. 用户资料被盗取 4. 网站数据库是否泄露 5. 其他 攻击种类： 1. 跨站脚本攻击XSS 2. 跨站请求伪造攻击 3. 前端Cookies安全性 4. 点击劫持攻击 5. 传输过程安全问题 6. 用户密码安全问题 7. SQL注入攻击 8. 信息泄露和社会工程学 配置环境： 1. 安装npm 2. 安装node.js 3. npm install nodemon -g（一旦更改代码就自动重启，不用手动重启了 -g 是global全局的意思） 4. 安装mysql XSSCross Site Scripting ：跨站脚本攻击 跨站：我的网站，自然希望网站里面所有的逻辑都来自自己写的代码。如果我的网站运行了来自其他网站的脚本，就叫跨站。 这样一来人为的给网页一个脚本，一般来说只要是网页脚本能做的事情，xss注入的脚本都能做。 1. 获取页面数据 2. 获取Cookies 3. 劫持前端逻辑（改变原有的逻辑） 4. 发送请求（通过图片，form等方式发送到攻击者指定的网站） 5. 偷取网站的用户数据 6. 偷取网站任意数据 7. 欺骗用户 8. ...... 例如，我在QQ空间内一个说说内混杂了XSS，所有访问的我空间的看到那篇说说的人都会在不知情的情况下向我规定的地方发送我想要的数据 XSS攻击分类反射型直接由url带过去的，页面直接显示这段代码 写好url，再发给别人访问，以此获取访问者数据。 但是可能网址很长，或者一眼能看出 网址包含的脚本，所以用长网址生成短网址这改一下 https://dwz.cn/#/?_k=uu9n2n 存储型XSS被保存在网站数据中，在其他用户访问的时候被其他用户执行 XSS攻击注入点1. HTML节点内容 1. 标签内内容是由用户输入，动态生成的 2. HTML属性 1. 某个标签的属性是由用户输入，定义的 3. JavaScript代码 1. js代码中存在由后台注入的变量，或者用户的输入的数据，有可能导致js代码的逻辑改变 4. 富文本 1. 有各式的html文本 2. qq空间发的说说这种就叫富文本 例如： &lt;img src=&quot;&quot; /&gt; 其中src是用户上传或者输入的 这时，我们上传一个名为 1&quot; onerror=&quot;alert(0) 的文件，这样原本的src就被替换成 &lt;img src=&quot;1&quot; onerror=&quot;alert(0)&quot; /&gt; 例如： js代码从后台拿用户数据，但是用户数据是XSS的脚本 var data = &quot;hello &quot;;alert(1);&quot;&quot;; 例如： qq邮箱中，有文本编辑器，即为富文本。富文本传输的其实就是一堆复杂的html代码，也就是说可以人为的修改其原本想表达的东西 防御XSS1. 浏览器自动拦截 当你的js参数出现在连接中，浏览器会进行自动拦截。 但是防御极其有限，只能防御注入在html和属性中的部分XSS，而js中的和富文本中的并不能拦截 2. 对文本中进行转义 当XSS注入的时候，对 &quot;&lt;&quot; 和 &quot;&gt;&quot;进行转义，使之失去标签的作用 &quot;&lt;&quot; ——&gt; &amp;lt; &quot;&gt;&quot; ——&gt; &amp;gt; 除此之外，html的属性需要 双引号，单引号，或者不需要引号，所以继续转义 &quot; &quot; &quot; ——&gt; &amp;quto; &quot; &apos; &quot; ——&gt; &amp;apos; &quot; &quot; ——&gt; &amp;#32; 3. 对js从后台数据库提取的数据进行转义 转义字符 或者 转换成 json 4. 对于富文本设置 黑名单 或者 白名单 黑名单：禁止某些属性或者标签的出现 优点：好写，只需要进行正则 缺点：html标签属性繁杂，一不小心就容易疏忽某些标签属性 白名单：只允许某些标签或者属性的出现 优点：完全防止禁用标签或者属性的出现 缺点：不好写 CSPContent Security Policy 内容安全策略，用于指定哪些内容可执行 CSP是http的头，规定了有哪些来源，可以限制 1. child-src(页面的自内容), connect-src(网络连接，如ajax), default-src(当其他没指定，就用default) 2. font-src(字体), frame-src(框架), img-src(图片) 3. manifest-src9Webapp的信息), media-src(视频音频), object-src(插件) 4. script-src(脚本), style-src(css), worker-src(servers work等) 定义了一些来源： 1. &lt;host-source&gt;(host规定信任域名)&lt;scheme-source&gt;(根据信任协议判断是否信任) &apos;self&apos;(同域可信任) 2. &apos;unsage-inline&apos;(指定是否信任直接插入页面的内容) &apos;unsafe-eval&apos; (是否调用eval，函数)&apos;none&apos;(不信任任何内容) 3. &apos;nonce-&lt;base64-value&gt;&apos;(指定一个一次性的内容，) &lt;hash-source&gt;(后台定义hash表，前端计算跟hash相同的才会执行) 4. &apos;strict-dynamic&apos;(信任脚本之后，脚本新链接的网站或者其他脚本是否信任) 基本格式： Content-security-Policy:default-src &apos;self&apos; http://example.com;connect-src &apos;non1&apos;; Content-Security-Policy:connect-src http://example.com;script-src http://example.com/ &lt;meta http-equiv=&quot;Content-Srcurity-Policy&quot; content=&quot;default-src https;&quot;&gt; CSRFCross Site Request Forgy 跨站请求伪造 例如： 我在A网站登陆了A网站的账号，我打开了B网站，B网站有脚本可以让我在不知情的情况下对A网站进行了操作，比如获取隐私数据，转账等 CSRF的运行顺序1. B网站向A网站 2. 带A网站的Cookies 3. 不访问A网站前端 4. referer为B网站 CSRF的特征1. 利用用户登陆态 2. 用户不知情 3. 完成业务请求 4. ...... CSRF的危害1. 盗取用户资金（转账，消费） 2. 冒充用户发帖背锅 3. 损害网站名誉 4. ...... CSRF的防御进制第三方网站带CookiesCookies新带了 same-site属性，也就是说只有来自同一网站的请求才能带Cookies Cookies添加SameSite属性： SameSite = Strict：不允许任何链接带Cookies SameSite = Lax：允许部分带Cookies，但是像ajax这种不能带Cookies SameSite = true 在前端页面加入验证信息既然CSRF不经过前端，那么设置一下，只有你经过前端才能访问到数据，那么也许可以拦截CSRF的攻击 验证码通过图形验证码的方式，攻击者网站是无法知道随机的验证码是多少的 缺点： 1. 有局限性，毕竟不能给所有操作加上验证码 2. 用户体验不好 tokentoken是服务端生成的一串字符串，以作用户端进行请求的一个令牌，当第一次登陆之后，服务器生成一个token并将此返回给客户端。 以后客户端只要带上这个token就行了，不需要带上用户密码 提交的时候必须加上token信息才能生效，而只有经过前端才能获得token，也就是说通过这种方式可以防止第三方平台的不知情操作 什么是referer上面 &quot;CSRF的运行顺序&quot; 中提到了referer是什么呢？ referer是HTTP协议中的一个请求头，包含了请求时来自哪里的信息。 所以CSRF中的referer中的请求位置时 攻击者 网站 很容易的我们可以想到，验证请求位置是否是正常用户端来防止CSRF的发生 其实 referer 的拼写应该是 referrer，所以这个是为数不多的错误拼写的单词 前端Cookies问题Cookies是什么？ 1. 它是一个前端数据的存储，它的存储是放在前端的。 2. 后端可以通过http头设置Cookies的值。 3. 请求时通过http头传给后端 4. 前端也可以读写Cookies 5. 遵守同源策略：当协议，域名，端口全部一致的时候才能读写 前端只要通过 &quot;document.cookie&quot; 就可以取到Cookies了，追加可以直接 &quot; document.cookie = &quot;userId=2&quot; &quot; Cookies 可以修改原来的值，也能追加新的值，而且Cookies有自己的结构 Cookies 的特性1. Cookies 有一个域名，表明在哪些地方可以使用 2. Cookies 有一个有效期，表明在那段时间可以用 3. Cookies 有一个路径，表明用在网络的哪一级，就像url层级一样 4. Cookies 只能被http协议使用，即http-only 5. secure 指定Cookies能否在 https中使用 以上都可以在开发者工具中看到，可以通过js查看： document.cookie 在 父路径中无法查看 子路径的Cookies 例如： 127.0.0.1:8080 界面无法看到 127.0.0.1:8080/user/login 中的Cookies，但反过来就可以 Cookies没有删除方法，想删除Cookies只有设置Cookies的有效期为过去的时间，才能删除Cookies Cookies作用1. 存储个性化设置 1. 用户在我的网站用的什么皮肤 2. 用户上次浏览到那个界面 3. 某个菜单是打开还是关闭 2. 存储未登录时用户唯一标识 3. 存储已登录用户的凭证 4. 存储其他业务数据 Cookies-登陆用户凭证1. 前端提交用户名和密码 2. 后端验证用户名和密码 3. 后端设置http头，设置用户凭证 1. 用户ID（不安全，容易被篡改） 2. 用户ID+签名（签命通过自己的算法算出，安全性高） 3. SessionID（随机的字符串） Cookies 和 CSS的关系XSS可能偷取Cookies http-only的Cookies有几率避免Cookies被盗 Cookies 和 CSRF的关系CSRF利用了用户的Cookies发送数据等 但是攻击站点无法读写Cookies 最好能阻止第三方使用Cookies Cookies-安全策略1. 加签命放篡改（数据是明文，只是验证有没有被修改） 2. 私有变换（加密） 3. http-only（防止XSS） 4. secure 5. same-site 点击劫持操作是用户完成，但是并不是用于自主意愿完成的 通过用户的点击完成某个操作，但是用户并不知情。 例如： 用户登录网站A，此时打开网站B，在网站B上的点击操作，实际上应用在的网站A中 B网站里面其实是一个&lt;iframe&gt;，将A网站的架构放在了&lt;iframe&gt;中，然后通过设置opcity来隐藏这个&lt;iframe&gt;，再然后就给&lt;body&gt;一个背景贴图 贴图中有按钮样子的图片，也有其他的图片，混淆视听，当用于点击贴图中的图片的时候，其实点的是&lt;iframe&gt;中的按钮 点击劫持的特征1. 用户亲手操作 2. 用户不知情 3. ...... 点击劫持的危害1. 盗取用户资金（转账，消费） 2. 获取用户敏感信息 3. ...... 点击劫持的防御点击劫持攻击的前提是 通过&lt;iframe&gt;将目标网站嵌套到自己网站 用Javascript禁止内嵌在js中，如果没有内嵌那么 top === window 如果被内嵌了，top 并不是 === window，&lt;iframe&gt;中的window就是&lt;iframe&gt;的window 但是 top 指的是 &lt;body&gt;的window if(top.location != window.location){ top.location = window.location } 通过上面的代码，窗口会进行跳转，跳转到&lt;iframe&gt;的界面，也就是原界面 但是 &lt;iframe&gt;中，有一个sandbox属性来限制&lt;iframe&gt;的功能，例如禁掉js的能力，所以js并不能百分百解决点击劫持 X-FRAME-OPTIONS 直接禁止内嵌ctx.set(&apos;X-FRAME-OPTIONS&apos;, &apos;DEMY&apos;); DENY 禁止内嵌 SAME-ORIGIN 同一个网站可以使用 SAMEORIIN 嵌入页和被嵌入页在同一域下 ALLOW-FROM+网站 允许指定网址内嵌 其他辅助手段1. 验证码 2. ...... HTTP传输窃听HTTP是一个明文协议，也就是说不会对数据进行加密 客户端和服务器的发送都是明文的 而数据包会经过很多中间节点，而这些节点愿意的话可以修改这些数据 1. 窃听 开启服务器代理，http请求可以直接查看文件请求头，响应头，响应body。 2. 篡改 在代理软件中，修改资源文件为我电脑中的资源文件，那么在客户端看到或显示的我的资源 窃听和篡改窃听：你传输过程中的所有数据可以直接被别人看到 1. 窃听用户密码 2. 切丁患处敏感信息 3. 非法获取个人资料 篡改：在传输过程中，修改或者插入信息 1. 插入广告 2. 重定向网站 3. 无法防御的XSS和CSRF攻击（如果修改了html或者js，那么我们做的防御没有任何意义） HTTPSHTTP协议是明文协议，中间方就可以直接查看篡改。 HTTPS TLS(SSL)加密 在 传输层加密 TLS 就是 SSL，现在称之为TLS，以前是SSL 中间人攻击中间人对客户端来说是服务器，对服务器来说是客户端，它是一个伪装的设备 也就是说，中间人可以查看客户端与服务器之间的通信，而不受TLS加密的影响 确认服务器身份CA：数字证书中心 保证安全的点： 1. 证书无法被伪造 2. 证书私钥不被泄露（恶意攻击者盗用私钥，可以查看篡改） 3. 域名管理权不能泄露（一旦泄露，被恶意攻击者指向自己的服务器，证书就会给攻击者的服务器而不给你） 4. CA坚守原则（验证不通过，不给证书） 密码安全密码的作用&quot;证明你是你&quot;，说白了就是证明一下登陆操作的人是合法用户 原理很简单，就是申请账号的时候是你最开始设置的密码和你现在使用的密码相同，对比一下就是了 密码泄露渠道1. 数据库被偷 2. 服务器被入侵 3. 通讯过程被窃听 4. 内部人员泄露数据 5. 其他网站（撞库，A网站的数据泄露，攻击者拿着用户的密码试用户在其他网站的密码） 6. ...... 密码存储1. 严禁密码的明文存储（防泄露，数据库中存储不用明文，加密） 2. 单向变换（一个密码对应一个密文） 3. 变化复杂度要求（防猜解） 4. 密码复杂度要求（防猜解） 5. 加盐（放猜解） 哈希算法——信息摘要算法明文-密文 一一对应 雪崩效应 只要明文有一点不一样，密文完全不一样 密文-明文 无法反推 密文固定长度 一般来说32为字符串 常见哈希算法 md5, sha1, sha256 密码单项变化彩虹表以md5为例，先暴力出所有的可能的明文的密文，然后根据窃听得到的密文去反过来查明文。这样子存着所有结果的密文表就被成为彩虹表 1. 混合加密 但是我们可以 混合多种加密算法，例如： md5(明文) = 密文 md5(md5(明文)) = 密文 md2(sha1(明文)) = 密文 md5(sha256(sha1(明文))) = 密文 这样子就算是查彩虹表，最后得到的可能很难是正确的 2. 复杂密码 虽然可以用算密文反过去映射明文，但是位数越多，越复杂的密码，破解所需的时间和内存就越大，一个20为的密码需要900G的硬盘来存储密码 加盐md5（ID + 原始密码 + 盐（随机生成的字符串） + 固定随机串（服务器一开始就定义的不变的字符串）*N个（顺序随意））= 最终密码 就是自动的给原始密码一个复杂的字符串，让其安全 密码变化次数越安全1. 加密成本几乎不变（生成密码时速度慢一些，但是只生成一次） 1. 对使用者来说，这点时间几乎是小事 2. 对解密者来说，破解时间成倍增加 2. 彩虹表失效（数量太大，无法建立链接） 3. 解密成本增加N倍 密码传输的安全性1. https传输 2. 频率限制（限制固定时间内只能登陆多少次） 3. 前端加密意义有限（传输层窃听并不知道明文密码，但是攻击者也可以传输你传输的密文） 生物特征密码1. 指纹（唇纹） 2. 声纹 3. 虹膜 4. 人脸 缺陷1. 私密性-容易泄露（指纹随时可以提取，圣文也是，人脸也是） 2. 安全性-碰撞（可能出现识别错误） 3. 唯一性-终身唯一 无法修改（如果别人获取了你的密码，你不能去改你的指纹密码对吧） 接入层注入问题关系型数据库1. 存放结构化数据 2. 可搞笑操作大量数据（维护，查询） 3. 方便处理数据之间的关联关系 4. 常见的：access/sqlite/mysql/mssql server SQL语言数据库查询语言 1. 被广泛接受的语言，各大数据库都能接受，已经被标准化 2. 但是标准话并不代表完全语言，每个数据库的SQL都有一点不一样 3. 类似自然语言 4. 用于关系型数据库 SQL注入在web中，数据库操作都是通过事先定义的代码实现的，毕竟用户不可能直接操作数据库 例如： select * from table where id = ${id}; 什么是注入如果用户传入的是一个 &quot; 1 or 1 = 1 &quot;，这个是一个id 但是插入到sql中变成了： select * from table where id = 1 or 1 = 1; 类似于XSS，去用传入的数据修改原本的逻辑结构 例如： select * from user where username = &apos;${data.username}&apos; and password = &apos;${data.password}&apos; 这个时候，用户传入的是 &quot;username&quot; &quot;1&apos; or &apos;1&apos;=&apos;1&quot; 那么原本的查询语句就变成了： select * from user where username=&apos;username&apos; and password = &apos;1&apos;or&apos;1&apos;=&apos;1&apos; 那么很容易发现， &quot; or &quot;这个关键字 否认了前面所有的判断，导致攻击者随便找个账户都能登陆 注入方法1. 在网址后加上 &quot; and 1=1 &quot;网页不会产生变化 2. 但是加上 &quot; and 1=0 &quot; 网页就变化报错了，通过这个可以检查是否有sql注入的危险 3. 或者插入 &quot; or 1=1 &quot;访问一些当前用户没有权限访问的页面 4. 同理通过 &quot;and union(version(), 1, 1)=6&quot;来判断数据库的版本位数第一位是否是6，这种方式获得数据库信息 5. 知道数据库的信息，可以查看该版数据库的漏洞 6. 还有通过其他的sql语句可以探测到 数据库的字段，例如ID，password是否存在，来推测表的结构 7. 这里只介绍了很小很小的一部分，还有很多可以去搜索 sql注入的危害1. 猜解密码（用工具很快） 2. 获取数据（信息泄露） 3. 删库删表 4. 拖库 5. ...... SQL注入防御1. 关闭错误输出 1. 攻击者通过错误输出信息来判断注入方向是否正确 2. 检查数据类型 例如： 120.0.0.1/post/10中10是页面的id 但是 攻击者通过 120.0.0.1/post/100 or 1=1来随机的查看页面 这个时候只要判断后面的值是否是数字，就能判断出是否是攻击者，我们只接收前面的10，不接受后面的字符串 3. 对数据进行转义（escape()模块） 因为上面只是简单的id，但是有的时候搜索需要字符，所以不能一棒子打死 对于某些情况，可以通过转义来限制用户输入的意思，防止注入语句 4. 使用参数化查询（需要安装mysql2） 先告诉数据库，我要传一个id，你帮我找一下 再传一个id过去，不管这个id是什么，数据库只会查找id而不会执行这个id 先给个意图，再给参数 npm install mysql2 --save 5. 使用ORM（对象关系映射） 把数据库的数据，通过代码的对象映射出来，一个对象就是一个记录 一般语言都有人写好了ORM npm install sequelize --save（node.js的ORM） NoSQL非关系型数据库，不同于sql，一定程度上可以防御sql注入 但是也是可以sql注入的 防御方式1. 检查数据类型 2. 类型转换 3. 写完整条件 接入层上传问题上传问题1. 上传文件 2. 再次访问上传的文件 3. 上传的文件被当成程序解析 如果上传的文件只是图片，音频就还行，但是如果是可执行文件就会出现大问题，因为攻击者的逻辑会被执行 所以需要判断上传文件的后缀等，防止不符合要求的文件上传 社会工程学信息泄露1. 泄露系统敏感信息 2. 泄露用户敏感信息 3. 泄露用户密码 信息泄露的途径1. 错误信息失控 2. sql注入 3. 水平权限控制不当 4. XSS/CSRF 5. 快递单/房产中介 6. ...... 社会工程学通过渠道挖出你的个人信息 仅仅通过你的昵称，查出你的姓名，进而查到更多隐私信息，然后建立出一个个人数据模型 你的身份由你掌握的资料确定，当你的个人信息被别人掌握，别人就可以伪装成你的身份，然后用你的身份去做坏事 社会工程学案例电信诈骗（徐玉玉案件）为什么会出现电信诈骗，因为骗子通过掌握的关于你的信息去获取你的信任 高考录取之后，成绩公示，报纸公示，让徐玉玉的个人信息被不法分子获取，并且利用这些信息进行诈骗 伪装公检法处于对公检法的信任，外加对方可以报出你的个人信息，甚至一些私人信息，你不会怀疑对方 QQ视频借钱伪装好友，发送QQ视频，由于信息泄露可以获取一个人的视频，声音 微信伪装好友就算一开始你不信，但是久而久之你就以为她是你的好友 OAuth思想即 现在网站的 授权登陆 的思想 access Token为每个用户对应的那一个Token，所以每次查询，只能查一个人，一定范围内保护用户资料 特点： 1. 一切行为由用户授权 2. 授权行为不泄露敏感信息 3. 授权会过期 利用OAuth思想防止资料泄露 1. 用户授权读取票据 2. 无授权的资料不能读取（防止一个人查询其他人的资料） 3. 不允许批量获取数据、 4. 数据接口可风控审计（获取查询数据的时间，位置等） 其他安全问题拒绝服务 DOS模拟正常用户访问网站，但是访问量成千上万甚至过亿，来占用服务器大量的资源，以至于网站不能正常打开访问 攻击方式1. TCP半连接 TCP的三次握手，我们只发送第一次请求，让服务器处于准备好并等待我们第三次握手的状态，这个时候就会影响服务器工作 2. HTTP链接 3. DNS 当TCP和HTTP的潮水攻击都被防下来的时候，转而攻击你的DNS（域名解析服务器） 大范围分布式拒绝服务攻击DDOS在DOS的基础上，用大范围的机器攻击网站服务器 1. 流量可达几十到上百G 2. 分布式（肉鸡，代理） 3. 极难防御（无法辨别正常用户和恶意用户） DOS攻击防御1. 防火墙（防火墙有办法尝试过滤恶意流量） 2. 交换机，路由器（只能防护小范围） 3. 流量清洗（对流量进行分析，找出特征，分辨正常访问） 4. 高防IP（云服务提供的，当面对DOS攻击时，把IP转为服务器提供商提供的另一个IP，而另一个IP拥有大规模的流量清洗服务） 5. 编写代码时 避免重逻辑业务 6. 快速失败快速返回 7. 防雪崩机制 8. 有损服务 9. CDN（静态网页发送到CDN上，减少服务器的压力） 重放攻击请求被窃听或记录，再次发送相同的请求，产生意外的结果 例如： 1. 用户被多次消费 2. 用户登陆态被盗取（重新发送之后，伪装成原用户） 3. 多次抽奖 重放冲击防御1. 加密（HTTPS） 2. 请求加时间戳（防止二次发送） 3. 加上token（session，每次发送的token都会变化，那么同样的请求 token就会很容易识别出来） 4. nonce（num+once，是只用一次的数字，就像ID一样） 5. 数字签名]]></content>
  </entry>
  <entry>
    <title><![CDATA[从0开始的JavaWeb---H5篇]]></title>
    <url>%2F2017%2F09%2F29%2F%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%2F</url>
    <content type="text"><![CDATA[Html什么是Html？HyperText Markup Language：超文本标记语言 ** 超文本：超出文本的范畴，使用html可以轻松实现 ** 标记：html所有的操作都是通过标记实现的。标记，就是标签 ** 网页语言：超文本标记语言 第一个html程序：例如：创建Java文件 后缀名为.java **先编译，后运行（jvm） 同理：html文件后缀是.html **直接通过浏览器就可以运行 html规范：1. 一个html文件开始标签和结束的标签&lt;html&gt;&lt;/html&gt; 2. html包含两个部分内容： &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; 3. html的标签有开始标签，也要有结束标签 4. html的代码不区分大小写&lt;font&gt; == &lt;FONT&gt; 5. 部分标签没有结束标签： 例如：&lt;br /&gt;//内部加个&quot;/&quot;，标签内结束 *html的操作思想：网页中有很多的数据，不同的数据可能需要不同的显示效果，这个时候需要使用标签把要操作的数据封装起来，通过修改标签的属性值实现标签内数据样式的变化。 一个标签就像等于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内的数据样式的变化。 html中常用的标签文字标签和注释标签*文字标签：修改文字的样式例如：&lt;font&gt; &lt;/font&gt; 属性：color : 文字颜色(颜色的英文单词，或者十六进制rgb) size : 文字大小（1~7） 注释标签Java的注释有三种：&quot;//&quot; , &quot;/* */&quot; &quot;/*****/&quot; html的注释: &lt;!-- 注释内容 --&gt;(源文件可以查看的注释) 标题标签，水平线标签和特殊字符标题标签&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt; ~~~~ &lt;h6&gt;&lt;/h6&gt; 文字大小 从h1 到 h6 以此变小，并且每个标签都会自动换行 水平线标签&lt;hr /&gt; 标签内结束 属性： **size：水平线的粗细 **color：水平线的颜色 特殊字符想在网页中显示 &quot;&lt;html&gt;是一个特殊标签&quot; 如果直接写 &quot;&lt;html&gt;是一个特殊标签&quot;，则只会显示 &quot;是一个特殊标签&quot; 需要转义&quot;&lt;html&gt;&quot;： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 &amp;nbsp; ---&gt; &quot; &quot; 空格转义 列表标签如果想在网页显示 列表的效果。 &lt;dl&gt;&lt;/dl&gt;：表示列表的范围 在&lt;dl&gt;里面 &lt;dt&gt;&lt;/dt&gt;：上层内容 在&lt;dl&gt;里面 &lt;dd&gt;&lt;/dd&gt;：下层内容 例如： &lt;dl&gt; &lt;dt&gt;学习内容&lt;/dt&gt; &lt;dd&gt;java&lt;/dd&gt; &lt;dd&gt;C++&lt;/dd&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dt&gt;学习进度&lt;/dt&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;dd&gt;没学&lt;/dd&gt; &lt;/dl&gt; 学习内容javaC++Python学习进度没学没学没学 &lt;ol&gt;&lt;ol&gt;：有序列表的范围 在&lt;ol&gt;&lt;/ol&gt;标签内部：&lt;li&gt; 属性： type：这是排序方式 默认（缺省）为 1. 2. 3.... type = &quot;a&quot; type = &quot;i&quot; 例如： &lt;ol type=&quot;a&quot;&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;/ol&gt; javaC++Python &lt;ul&gt;&lt;/ul&gt;：无序列表的范围属性： type： circle 空心圆 disc 实心圆（默认） square 实心方块 &lt;ol type=&quot;a&quot;&gt; &lt;li&gt;java&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;/ol&gt; java C++ Python &lt;img&gt;图像标签（重点）&lt;img src=&quot;a.jpg&quot; width=&quot;宽像素&quot; height=&quot;高像素&quot; alt=&quot;显示的文字&quot;/&gt; --src：图片的路径 --width：图片的宽度 --height：图片的高度 --alt：图片上显示的文字，把鼠标移动到图片上面，停留片刻显示内容 路径的介绍第一类：绝对路径D:\blog\lc_love_hehe\source\_posts\p.jpg http://www.baidu.com/b.jag 第二类：相对路径一个文件相对于另外一个文件的位置 三种写法： 当图片与html在同一个文件夹内，直接使用 b.jpg 当图片在html的同级文件夹img中，使用img/b.jpg 当图片在html的上级文件夹中，../b.jpg 超链接连接资源&lt;a href=&quot;连接到资源的路径&quot;&gt;显示在页面上的内容&lt;/a&gt; href：连接的资源的地址 target：设置打开的方式，默认是当前页打开。 _blank：在新窗口打开 _self：当前页打开 当超链接不需要到任何地址的时候，href=&quot;#&quot; &lt;a href=&quot;https://usuiforhe.github.io/&quot; target=&quot;_blank&quot;&gt;test&lt;/a&gt; 定位资源&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;//定义顶部的位置 &lt;a name=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;//定位到网页中name为top的位置，记得加上# &lt;pre&gt;原样输出 例如： public static void main(String[] args){ Syste.out.println(&quot;hello world&quot;); } &amp;lt;pre&amp;gt; public static void main(String[] args){ Syste.out.println(&quot;hello world&quot;); } &amp;lt;/pre&amp;gt; public static void main(String[] args){ Syste.out.println(“hello world”);} public static void main(String[] args){ Syste.out.println(“hello world”);}加上了 &lt;pre&gt; 标签后，原本一行的代码，变成了我们要的换行的效果 表格标签可以对数据进行格式化，使数据显示更加清晰 &lt;table&gt;&lt;/table&gt;:表示表格的范围 在&lt;table&gt;里面： &lt;caption&gt;表格标题 在&lt;table&gt;里面： &lt;tr&gt; 在&lt;tr&gt;里面：&lt;td&gt; 画图分析表格的写法： 首先定义一个表格的范围使用table 定义一行使用 tr 定义一个单元格使用 td 操作技巧： 首先数有多少行，数每行里有多少个单元格 例如： &lt;table&gt; &lt;tr&gt; &lt;td&gt;学科&lt;/td&gt; &lt;td&gt;学习进度&lt;/td&gt; &lt;td&gt;梦想&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;python&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;td rowspan=&quot;3&quot;&gt;想学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C++&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;没学&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 属性： &lt;table&gt;中： border：表格线的粗细 bordercolor：表格线的颜色 cellspacing：表格之间的距离 align：left center right 框中文字的位置 &lt;td&gt;中： colspan：0~无穷大，跨列 rowspan：0~无穷大，跨行 学科 学习进度 梦想 python 没学 想学 C++ 没学 Java 没学 表单标签可以提交数据到服务器的标签，这个过程可以使用表单标签实现 &lt;form&gt;&lt;/form&gt;：定义表单范围输入项：可以输入内容或者选择内容的部分 大部分的输入项 使用 &lt;input type = “输入类型” /&gt; Input 类型：type = &quot;email/url/number/range/date picker/search/color/tel&quot; &lt;input type=&quot;password&quot;&gt;密码框 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男 单选框 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;苹果&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;香蕉&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;栗子 多选框 &lt;input type = &quot;url&quot; name = &quot;url&quot;&gt; 手机端弹出字母键盘，电脑端无差别 &lt;input type = &quot;email&quot; name = &quot;email&quot;&gt; 手机端弹出字母键盘，电脑端无差别 &lt;input type = &quot;tel&quot; name = &quot;tel&quot;&gt; 手机端弹出数字键盘，电脑端无差别 &lt;input type = &quot;number&quot; name = &quot;number&quot;&gt; 手机端弹出数字键盘，电脑端右边多处两个按钮控制加减，只能输入参与运算的内容“+ - . 1 2 3 4 5 6 7 9 e” data picker input类型: date —— 选取 日， 月， 年 month —— 选取月，年 week —— 选取 周和年 time —— 选取时间（小时和分钟） datetime —— 选取时间，日，月，年（utc时间） datetime-local —— 选取时间，日，月， 年（本地时间） 使用方法一样 &lt;input type = &quot;date&quot; name = &quot;date&quot; &gt; 手机端显示的是 日期键盘 &lt;input type = &quot;range&quot; name = &quot;range&quot; min = &quot;最小值&quot; max = &quot;最大值&quot;&gt; &lt;input type = &quot;image&quot; src=&quot;a.jpg&quot;/&gt;设置按钮为图片，作用是提交 &lt;input type = &quot;search&quot; name = &quot;search&quot; &gt; &lt;input type = &quot;color&quot; name = &quot;color&quot;&gt;弹出颜色选择 &lt;input type = &quot;hidden&quot;/&gt; 隐藏项，不会显示在页面中的 &lt;input type = &quot;button&quot; /&gt; 普通按钮 &lt;input type = &quot;submit&quot; /&gt; 提交按钮 &lt;input type = &quot;reset&quot; value=&quot;你想显示的文字&quot;/&gt; 重置按钮 &lt;selsect&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt;下拉选项 &lt;textarea cols=&quot;列数&quot; rows=&quot;行数&quot;&gt;&lt;/textarea&gt; 文本域 最好每个输入项都有个name属性，方便后台提取数据。后台通过name属性获取对应输入的值 表单属性： autocomplete/autofocus/multiple/placeholder/required/action/method action 是提交数据到的那个页面 method 常用的就两种“get”“post”，默认get enctype 关于文件上传的属性 &lt;form autocomplete = &quot;on&quot;（#自动完成功能，存下之前提交过的字段#）action = &quot;****&quot; ausofocous = &quot;&quot;&gt; &lt;input type = &quot;text&quot; name = &quot;text&quot; autofocus = &quot;autofocus&quot;&gt;(#不写 autocomplete 默认开启存储 autofocus 光标自动确定该input#) &lt;input type = &quot;email&quot; name = &quot;email&quot; autocomplete = &quot;off&quot;&gt;（#关闭自动存储#） &lt;input type = &quot;file&quot; multiple = &quot;muliple&quot; / &gt;(#muliple 是乘法，代表多个的意思，同时上传多个文件#) ps. multiple 在类型为type的时候，也可以用，多个邮箱之间用 分号 隔开。 如果没有multiple ，email类型也可以传多个email，但是用了multiple 的 input，会传出一个数组到后台，而没有用的则会传出一整个字符串，难以操作。 &lt;input type = &quot;text&quot; placeholder = &quot;用户名&quot; /&gt;(#提示输入用户名，开始输入时提示消失#) ps. placeholder 适用于： text, search, url, tel, email, password。 &lt;input type = &quot;text&quot; required = &quot;required&quot; /&gt; （#required 规定必须在提交之前填写输入域（不能为空）#） &lt;input type = &quot;submit&quot;&gt; &lt;/form&gt;` 其他标签&lt;b&gt; 加粗 &lt;s&gt; 删除线 &lt;u&gt; 下划线 &lt;i&gt; 斜体 &lt;pre&gt; 原样输出 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;div&gt; 盒子，自带换行 &lt;span&gt; 盒子，不带换行 html的头标签html由两部分组成 head 和 body 在head里面的标签就是头标签 title：显示在标签上显示的内容 base：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标（target属性） 例如： &lt;base target=&quot;_blank&quot;&gt; //这是所有的超链接都是新窗口打开 meta：可以提供有关页面的基本信息 例如： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=01-hello.html&quot;&gt; // refresh 模拟页面请求， 3 3秒后， url 跳转的目标页面 link：定义文档与外部资源的关系 框架标签（过时）&lt;frameset&gt; 属性： rows：按行进行划分 cols：按列进行划分 &lt;frameset rows=&quot;80,*&quot;&gt;划分为两行，第一行高80 &lt;frame&gt; 具体显示的页面 &lt;frame name = &quot;lower_left&quot; src=&quot;b.html&quot;&gt; 使用框架标签时候，不能写在body里面，需要把body去掉。 HTML样例&lt;body&gt; &lt;header&gt; &lt;div&gt;logo&lt;/div&gt; &lt;nav&gt; &lt;a href=&quot;test.html&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;介绍&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;案例&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section&gt; &lt;aside&gt; &lt;a href=&quot;#se1&quot;&gt;setcion1&lt;/a&gt; &lt;a href=&quot;#se2&quot;&gt;section2&lt;/a&gt; &lt;a href=&quot;#se3&quot;&gt;section3&lt;/a&gt; &lt;/aside&gt; &lt;article&gt; Today, Rikka is going to learn how to use BIT to solve some simple data structure tasks. While studying, She finds there is a magic expression x&amp;(−x) in the template of BIT. After searching for some literature, Rikka realizes it is the implementation of the function lowbit(x). lowbit(x) is defined on all positive integers. Let a1...am be the binary representation of x while a1 is the least significant digit, k be the smallest index which satisfies ak = 1. The value of lowbit(x) is equal to 2 k−1 . After getting some interesting properties of lowbit(x), Rikka sets a simple data structure task for you: At first, Rikka defines an operator f(x), it takes a non-negative integer x. If x is equal to 0, it will return 0. Otherwise it will return x − lowbit(x) or x + lowbit(x), each with the probability of 1 2 . Then, Rikka shows a positive integer array A of length n, and she makes m operations on it. There are two types of operations: • 1 L R, for each index i ∈ [L, R], change Ai to f(Ai). • 2 L R, query for the expectation value of ∑R i=L Ai . (You may assume that each time Rikka calls f, the random variable used by f is independent with others.) Input The first line contains a single integer t(1 ≤ t ≤ 3), the number of the testcases. The first line of each testcase contains two integers n, m(1 ≤ n, m ≤ 105 ). The second line contains n integers Ai(1 ≤ Ai ≤ 108 ). And then m lines follow, each line contains three integers t, L, R(t ∈ {1, 2}, 1 ≤ L ≤ R ≤ n). Output For each query, let w be the expectation value of the interval sum, you need to output (w × 2 nm) mod 998244353. It is easy to find that w × 2 nm must be an integer. &lt;/article&gt; &lt;/section&gt; &lt;input placeholder=&quot;选择手机品牌&quot; list=&quot;phtonlist&quot; /&gt;&lt;!--input的list 必须和datalist的id相同--&gt; &lt;datalist id=&quot;phtonlist&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt; &lt;/datalist&gt; &lt;meter value=&quot;220&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt;&lt;!-- 当前值为220 最低为20 最高为380 标准在200~240之间 最好的取值为220--&gt; &lt;meter value=&quot;180&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt; &lt;meter value=&quot;260&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt; &lt;meter value=&quot;0.75&quot;&gt;75%&lt;/meter&gt; &lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;progress max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;details&gt; &lt;summary&gt;你要显示的标题&lt;/summary&gt; 内容：。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 &lt;/details&gt; &lt;menu type=&quot;toolbar&quot;&gt; &lt;li&gt; &lt;menu aria-label=&quot;File&quot;&gt; &lt;button type=&quot;button&quot;&gt;new1&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new2&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new3&lt;/button&gt; &lt;/menu&gt; &lt;/li&gt; &lt;li&gt; &lt;button type=&quot;button&quot;&gt;new4&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new5&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;new6&lt;/button&gt; &lt;/li&gt; &lt;/menu&gt; &lt;footer&gt; copyright...... &lt;/footer&gt; &lt;p&gt;我们来&lt;ruby&gt;聊&lt;rt&gt;liao&lt;/rt&gt;&lt;/ruby&gt;天&lt;/p&gt; &lt;/body&gt; CSS-层叠样式表解释层叠一层一层的，与优先级有关 样式表有很多的属性和属性值，改变标签的属性值，是标签变换 作用CSS将网页内容和显示样式进行分离，提高了显示功能，解决了html代码对样式定义的重复，提高了后期样式代码的可维护性。 CSS和Html的结合方式1. 在每个html标签上都有一个style属性。通过style属性修改标签样式 &lt;span style=&quot;background-color:red; color=green;&quot;&gt;测试&lt;/span&gt; 2. 使用html的一个标签实现 &lt;style&gt; 标签，写在head里面 &lt;style type=&quot;text/css&quot;&gt; div{ background-color:red; color = green }//所有div的样式都这样 &lt;/style&gt; 3. 在&lt;style&gt;标签中使用语句 @import url (css文件的路径) &lt;style type=&quot;text/css&quot;&gt; @import url(div.css) &lt;/style&gt; 4. 使用头标签&lt;link&gt;,引入外部css文件 &lt;link rel=&quot;srtlesheet&quot; type=&quot;text/css&quot; href=&quot;css_3.css&quot; /&gt; Ps.第三种结合方式，缺点：在某些浏览器下不支持。一般来说，是用第四种结合方式。 CSS的优先级从上到下，从外到内，CSS的优先级从低到高。后加载的优先级高。 CSS书写规范1. 选择器名称{ 属性名：属性值； 属性名：属性值； } 2. 属性与属性之间用分号隔开 3. 属性与属性值之间用冒号链接 4. 如果一个属性有多个属性值的话，那么多个值用空格隔开 选择器id选择器&lt;标签 id=&quot;test&quot;&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 #test{ background-color: red; }来选择 id 为test的标签。也就是说 id 前面加上 &quot; # &quot; 类选择器&lt;标签 class=&quot;test&quot;&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 .test{ background-color:red; }来选择 class 为test的标签。也就是说 class 前面加上 &quot; . &quot; 标签选择器&lt;标签&gt;文字内容&lt;/标签&gt; 在CSS文件中： 通过 标签{ background-color:red; }来选择 标签 class 选择器的优先级 &gt; 标签选择器的优先级id选择器的优先级 &gt; class选择器的优先级标签内部的style属性的优先级 &gt; id 选择器的优先级 关联选择器&lt;div&gt;&lt;p&gt;test&lt;/p&gt;&lt;/div&gt; 要选中 p 标签 那么CSS这样写 div p{ background-color:red; }两个中间一个空格，这样就选中 div 子标签中的 p 标签 组合选择器&lt;div&gt;test111&lt;/div&gt; &lt;p&gt;test222&lt;/p&gt; 想把div和p设置成一样的样式，那么CSS中这么写 div,p{ background-color:red; }中间用逗号连接，表示两个都选中 伪类元素选择器CSS里面提供了一些定义好的样式，可以拿过来使用 原始状态 鼠标放上去的状态 点击 点击之后 ：link ：hover ：active visited 例如CSS文件中： a:link{ background-color: red; } a:hover{ background-color: blue; } a:active{ background-color: black; } 第一个字符 第一行 在文字标签前面加上 :first-letter :first-line ：before 例如CSS文件中： p:before { content:&quot;台词：&quot;; }那么 所有的 p 标签前面 都会加上 &quot;台词&quot; 这两个字 选择符类型 表达式 描述子串匹配的属性选择符 E[att^=”val”] 匹配具有att属性、且值以val开头的E元素 子串匹配的属性选择符 E[att$=”val”] 匹配具有att属性、且值以val结尾的E元素 子串匹配的属性选择符 E[att*=”val”] 匹配具有att属性、且值中含有val的E元素 结构性伪类 E:root 匹配文档的根元素。在HTML中，根元素永远是HTML 结构性伪类 E:nth-child(n) 匹配父元素中的第n个子元素E 结构性伪类 E:nth-last-child(n) 匹配父元素中的倒数第n个结构子元素E 结构性伪类 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E 结构性伪类 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E 结构性伪类 E:last-child 匹配父元素中最后一个E元素 结构性伪类 E:first-of-type 匹配同级兄弟元素中的第一个E元素 结构性伪类 E:only-child 匹配属于父元素中唯一子元素的E 结构性伪类 E:only-of-type 匹配属于同类型中唯一兄弟元素的E 结构性伪类 E:empty 匹配没有任何子元素（包括text节点）的元素E 目标伪类 :target 匹配相关URL指向的E元素 UI元素状态伪类 E:enabled 匹配所有用户界面（form表单）中处于可用状态的E元素 UI元素状态伪类 E:disabled 匹配所有用户界面（form表单）中处于不可用状态的E元素 UI元素状态伪类 E:checked 匹配所有用户界面（form表单）中处于选中状态的元素E UI元素状态伪类 E::selection 匹配E元素中被用户选中或处于高亮状态的部分 否定伪类 E:not(s) 匹配所有不匹配简单选择符s的元素E 通用兄弟元素选择器 E ~ F 匹配E元素之后的F元素 盒子模型div+CSS，给div一个样式，设置它的位置以及外观。又因为这div就像一个盒子一样，所以也叫做盒子模型。 在进行布局前需要把数据封装到一块一块的区域内 边框属性： border：统一设置 none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset 无边框| 隐藏边框|点线或实线|虚线或实线| 实线 |双线边框 | 3D凹槽 | 3D凸槽 |3D凹边 |3D凸边 border-top：上边框 border-bottom：下边框 border-left：左边框 border-right：右边框 border: 粗细（px） 样式（上述）颜色； 内边距padding：length（px）//统一设置 padding-bottom : 文字内容距离下边框的距离 padding-left : 文字内容距离左边框的距离 padding-right : 文字内容距离有边框的距离 padding-top : 文字内容距离上边框的距离 外边距margin：外边距，边框距离外边框的距离 margin：length（px）//统一设置 margin-top : 边框距离上外边框的距离 margin-bottom : 边框距离下外边框的距离 margin-right : 边框距离右外边框的距离 margin-left : 边框距离左外边框的距离 CSS的布局的漂浮float：none | left | right none ：默认值。对象不漂浮 left ：文本流向对象的右边 right ：文本流向对象的左边 CSS的布局的定位Position 属性： static:默认值。无特殊定位，对象遵循HTML定位规则 absolute：将对象从文档流中脱出，使用left,right,top,bottom等属性相对于其进行绝对定位 ——————即，这个盒子独立出来，不由html自动按文档流分配位置，后面的盒子自动补齐该和自动空位 relative：对象不可层叠，但将依据left,right,top,bottom等属性在正常文档流中偏移位置。 ——————即，这个盒子没有从文档流中拖出，位置还在，但是可以移动而不影响其他的盒子的原有位置 JavascriptJavaScript简介JavaScript是基于对象和时间驱动的脚本语言，主要应用在客户端 基于对象提供好了很多对象，可以直接拿过来使用 事件驱动html做网站是静态效果，加入了js后就可以完成动态的效果 特点1. 交互性（信息的动态交互） 2. 安全性（不可以直接访问本地磁盘） 3. 跨平台性（只要是可以解析js的浏览器都可以执行，与平台无关） JavaScript的组成三部分： 1. ECMAScript ECMA：欧洲计算机协会 由ECMA组织指定的js语法，语句...... 2. BOM broswer object model：浏览器对象模型 3. DOM document object model：文档对象模型 JavaScript与HTML的结合1. 使用一个标签 &lt;script type=&quot;text/javascript&quot;&gt;JavaScript代码&lt;/script&gt; 2. 使用script引入外部标签文件 创建一个js文件，写js代码 &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt; 这样写的话 &lt;script&gt;&lt;/script&gt;中间的代码不会执行 JavaScript基本语法js的原始类型和声明变量1. string：字符串 var str=&quot;abc&quot;; 2. number：数字类型 var m = 123; 3. boolean：数字类型 var flag=true; 4. null:对象引用为空 5. undifined：定义了一个变量，但是这个变量没有赋值 var aa； 用typeof（变量名）；查看当前变量的数据类型 js的语句1.判断语句： 1. if语句 if(a == 5){ alert(&quot;5&quot;); }else{ alert(&quot;不是5&quot;) } 2. switch语句（支持所有的数据类型） switch(变量){ case 5:操作;break; case 6:操作;break; case 7:操作;breal; default:操作;break; } 2. 循环语句 1. for循环 for(var i=0; i&lt;10; i++){ alert(i); } 2. whilt循环 var i=4; whilt(i--){ alert(i); } js的运算符1. - 2. + 3. * 4. / 5. &amp; 6. ++ 7. -- 8. += 9. -= 字符串加减j=123 alert(j/1000*1000) java中输出的 0； 但是JavaScript中输出的 123； js中不区分整形浮型点 var str = &quot;457&quot; alert(str+1); Java和JavaScript中输出的都是4571; 加法做的是字符串相见 alert(str-1); JavaScript输出的是 456，即进行了减法运算 alert(&quot;abc&quot;-1); JavaScript输出NAN，提示错误，不是一个数字。 Boolean的操作var flag=true; alert(flag+1); JavaScript中输出的是 2。也就是说 true = 1； 反之，flase = 0。 === 和 == 的区别JavaScript中， == 用于判断两个参数的值是否相等 === 用于判断两个参数 类型和值是否都相等 例如： var x = &quot;5&quot;, y = 5; x == y 则为 true x === y 则为false 引入知识直接向页面输出的语句（可以直接把内容显示在页面上） document.write(&quot;aaa&quot;); document.write(&quot;&lt;hr /&gt;&quot;); 可以直接写入数据，也可以写入html代码，当然也可以混合都写 js的数组js数组中，写什么都可以,可以是数据的混合，可以同时包括int，string或者其他类型 定义数组的三种方式1. var arr=[1,2,&quot;34&quot;]; 2. 使用内置的对象 Array对象 var arr = new Array(5);//定义一个数组，数组长度是5 3. 使用内置对象 Array对象 var arr2 = new Array(3,4,5);//定义一个数组，数组里面的元素为 3，4，5 数组的属性length：表示数组的长度 var len = arr.length; 数组的长度是可以变的 数组可以存放不同的数据类型的数据 js的函数在js里面定义函数有三种定义方式1. 关键字：function funciton 方法名（参数列表）{ 方法体； 返回值；（返回值可有可无） } 2. 匿名函数：function var func = funtion （参数列表）{ 方法体和返回值； } 调用直接 func(); 3. 内部对象：Function（用的少，了解就行）`动态函数` var func = new Function(&quot;参数列表&quot;，“方法体和返回值”); var test = new Function(&quot;x,y&quot;,&quot;var sum;sum=x+y;return sum;&quot;); js的全局变量和局部变量全局变量在script标签内部顶一个变量，这个变量在页面中js部分都可以使用 局部变量在方法内部定义一个变量，只能在方法内部使用 测试全局变量： &lt;script&gt; var a = 10; function func(){ alert(a); } func(); &lt;/script&gt; &lt;script&gt; alert(a); &lt;/script&gt; 可以跨script标签使用的变量。称之为全局变量 局部变量： &lt;script&gt; function func(){ var a = 10; alert(a); } func(); alert(a);//报错 &lt;/script&gt; 局部变量只能在方法内部使用 script应该放的位置位置差别&lt;script&gt;原则上放任意位置都可以执行，但是还是要注意位置 html文档是从上到下解析的，如果用js去获得html的标签，一定要在获取标签的后面，不然会得到一个 null 的变量，导致错误。 建议把script标签放到&lt;/body&gt;后面，&lt;/html&gt;前面 js的重载function add1(a, b){ return a+b } function add1(a, b, c){ return a+b+c } function add1(a, b, c, d){ return a+b+c+d } add1(2,3) add(2,2,3) add(2,2,3,3) 第一个得出结果NAN，第二个得出结果NAN，第三个得出正确结果 为什么呢？JavaScript基础DOMjs的String对象方法属性属性只有一个需要注意：length 字符串的长度 方法####### 与html相关的方法 设置数据样式的方法 1. bold() 使用粗体显示字符串 document.write(str.bold()); 2. fontcolor() 使用指定的颜色来显示字符串 document.write(str.fontcolor(&quot;red&quot;)); 3. fontsize() 使用指定的尺寸来显示字符串 document.wirte(str.fontsize(1));//参数值为1~7 4. link() 将字符串显示为链接 document.write(str.link(www.baidu.com));//即字符串成为一个超链接 5. big() 用大号字体显示字符串 document.write(str.big()); 6. blink() 显示闪动字符串 document.write(str.blink()); 7. sup() 把字符串显示为上标 8. sub() 把字符串显示为下标 9. small() 使用小字号来显示字符串 10. strike() 使用删除线来显示字符串 ####### 与Java相似的方法 对数据进行操作的方法 1. split() 把字符串分割为字符串数组 2. charAt() 返回在指定位置的字符 str.cjarAt(1); 3. concat() 连接字符串 str.concat(str2); 4. indexOf() 检索字符串 str.indexof(&quot;as&quot;);//不存在返回-1 5. charCodeAt() 返回在指定的位置的字符的 Unicode 编码 6. fixed() 以打字机文本显示字符串 7. fromCharCode() 从字符编码创建一个字符串 8. italics() 使用斜体显示字符串 9. lastIndexOf() 从后向前搜索字符串 10. localeCompare() 用本地特定的顺序来比较两个字符串 11. match() 找到一个或多个正则表达式的匹配 12. replace() 替换与正则表达式匹配的子串 str.replace(&quot;a&quot;, &quot;c&quot;);//把a替换成c 13. search() 检索与正则表达式相匹配的值 14. slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 15. substr() 从起始索引号提取字符串中指定数目的字符 str.substr(start, length);截取从start开始长度为length的字符串 16. substring() 提取字符串中两个指定的索引号之间的字符 str.substring(start, end);截取从start开始 end 截至的字符串 17. toLocaleLowerCase() 把字符串转换为小写 18. toLocaleUpperCase() 把字符串转换为大写 19. toLowerCase() 把字符串转换为小写 20. toUpperCase() 把字符串转换为大写 21. toSource() 代表对象的源代码 22. toString() 返回字符串 23. valueOf() 返回某个字符串对象的原始值 js的Date对象js获取当前事件 var date = new Date(); Date对象的方法1. toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串 date.toLocaleString(); 2. toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串 3. toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串 4. setFullYear() 设置 Date 对象中的年份（四位数字） 5. setMonth() 设置 Date 对象中月份 (0 ~ 11) 注意是 0~11，而不是1~12 ！！！！ 6. setHours() 设置 Date 对象中的小时 (0 ~ 23) 7. setMinutes() 设置 Date 对象中的分钟 (0 ~ 59) 8. setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59) 9. setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999) 10. getFullYear() 从 Date 对象以四位数字返回年份 11. getMonth() 返回 Date 对象的月份 (0~11) setMonth() 设置 Date 对象中月份 (0 ~ 11)。 12. getHours() 返回 Date 对象的小时 (0 ~ 23) 13. getMinutes() 返回 Date 对象的分钟 (0 ~ 59) 14. getSeconds() 返回 Date 对象的秒数 (0 ~ 59) 15. getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999) 16. getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 js的Math对象全都是静态方法，调用函数时直接 Math.方法名（参数） Math对象的方法1. abs(x) 返回数的绝对值 2. acos(x) 返回数的反余弦值 3. asin(x) 返回数的反正弦值 4. atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 5. atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） 6. ceil(x) 对数进行上舍入 7. cos(x) 返回数的余弦 8. exp(x) 返回 e 的指数 9. floor(x) 对数进行下舍入 10. log(x) 返回数的自然对数（底为e） 11. max(x,y) 返回 x 和 y 中的最高值 12. min(x,y) 返回 x 和 y 中的最低值 13. pow(x,y) 返回 x 的 y 次幂 14. random() 返回 0 ~ 1 之间的随机数 15. round(x) 把数四舍五入为最接近的整数 16. sin(x) 返回数的正弦 17. sqrt(x) 返回数的平方根 18. tan(x) 返回角的正切 19. toSource() 返回该对象的源代码 20. valueOf() 返回 Math 对象的原始值 Math对象的属性1. E 返回算术常量 e，即自然对数的底数（约等于2.718） 2. LN2 返回 2 的自然对数（约等于0.693） 3. LN10 返回 10 的自然对数（约等于2.302） 4. LOG2E 返回以 2 为底的 e 的对数（约等于 1.414） 5. LOG10E 返回以 10 为底的 e 的对数（约等于0.434） 6. PI 返回圆周率（约等于3.14159） 7. SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） 8. SQRT2 返回 2 的平方根（约等于 1.414） js的全局函数由于不属于任何一个对象，直接名称使用 1. decodeURI() 解码某个编码的URI 2. decodeURIComponent() 解码一个编码的URI组件 3. encodeURI() 把字符串编码为URI 4. encodeURIComponent() 把字符串编码为URI组件 5. escape() 对字符串进行编码 6. eval() 计算JavaScript字符串，并把它作为脚本代码来执行 7. getClass() 返回一个javaObject的JavaClass 8. isFinite() 检查某个值是否为有穷大的数 9. isNaN（） 检查某个值是否是数字 10. parseFloat() 解析一个字符串并返回一个浮点数 11. parseInt() 解析一个字符串并返回一个整数 12. unescape() 对由escape()编码的字符串进行解码 js函数的重载js的重载是否存在？不存在重载。函数名相同的以后定义的为准。也就是说方法名相同的情况下，后定义的会覆盖掉先定义的方法。 js可以通过其他的方式去模拟重载在js的函数中，传入的参数列表，可以通过一个js自带的 aruguments[]数组去访问传入的参数。 例如： function add(a, b, c){ arguments[0] == a; arguments[1] == b; arguments[2] == c; } js的函数你可以传入多个参数，例如 add(1,2,3,4,5,6)，虽然定义的 add函数只有三个参数， 但是通过arguments可以获得 传入的所有参数 1,2,3,4,5,6 只是 a=1,b=2,c=3 罢了 通过arguments.length 判断传入参数大小，以此来手动进行重载 js的bom对象bom：broswer object model 浏览器对象模型 通过bom对象，可以直接对浏览器进行操作。 有哪些对象navigatorNavigator 对象包含有关浏览器的信息。 对象属性1. appCodeName 返回浏览器的代码名 2. appMinorVersion 返回浏览器的次级版本 3. appName 返回浏览器的名称 alert(navigator.appName); 4. appVersion 返回浏览器的平台和版本信息 5. browserLanguage 返回当前浏览器的语言 6. cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 7. cpuClass 返回浏览器系统的 CPU 等级 8. onLine 返回指明系统是否处于脱机模式的布尔值 9. platform 返回运行浏览器的操作系统平台 10. systemLanguage 返回 OS 使用的默认语言 11. userAgent 返回由客户机发送服务器的 user-agent 头部的值 12. userLanguage 返回 OS 的自然语言设置 对象方法1. javaEnabled() 规定浏览器是否启用 Java 2. taintEnabled() 规定浏览器是否启用数据污点 (data tainting) screen（屏幕对象）Screen 对象包含有关客户端显示屏幕的信息。 对象属性1. availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外) 2. availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外) 3. bufferDepth 设置或返回调色板的比特深度 4. colorDepth 返回目标设备或缓冲器上的调色板的比特深度 5. deviceXDPI 返回显示屏幕的每英寸水平点数 6. deviceYDPI 返回显示屏幕的每英寸垂直点数 7. fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑 8. height 返回显示屏幕的高度 9. logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数 10. logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数 11. pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）9 12. updateInterval 设置或返回屏幕的刷新率 13. width 返回显示器屏幕的宽度。 location对象包含有关当前 URL 的信息。 对象属性1. ash 设置或返回从井号 (#) 开始的 URL（锚） 2. host 设置或返回主机名和当前 URL 的端口号 3. hostname 设置或返回当前 URL 的主机名 4. href 设置或返回完整的 URL`(重点)` 1. location.href;//得到当前请求的url地址。 2. location.href=&quot;你要跳转的地址,例如：www.baidu.com&quot;这样就会跳转页面 5. pathname 设置或返回当前 URL 的路径部分 6. port 设置或返回当前 URL 的端口号 7. protocol 设置或返回当前 URL 的协议 8. search 设置或返回从问号 (?) 开始的 URL（查询部分） 对象方法1. assign() 加载新的文档 2. reload() 重新加载当前文档 3. replace() 用新的文档替换当前文档。 history（历史）请求的url的历史记录 对象属性1. length 返回浏览器历史列表中的 URL 数量 对象方法1. back() 加载 history 列表中的前一个 URL history.back() 2. forward() 加载 history 列表中的下一个 URL history.forward() 3. go() 加载 history 列表中的某个具体页面 windowWindow 对象表示浏览器中打开的窗口。包含location,navicator,history,screen对象 它是一个顶层对象 属性opener 获得创建窗口的窗口 即用a.html打开b.html，在b.html中通过window.opener获得a.html的窗口对象 对象方法（都要记住）1. alert() 显示带有一段消息和一个确认按钮的警告框 2. blur() 把键盘焦点从顶层窗口移开 3. clearInterval() 取消由 setInterval() 设置的 timeout 1. window.clearInterval(id); 2. id为 setInterval()返回的id值 4. clearTimeout() 取消由 setTimeout() 方法设置的 timeout 1. window.clearTimeout(id); 2. id为 setTimeout()返回的id值 5. close() 关闭浏览器窗口 1. windown.close(); 2. 浏览器兼容性差 6. confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框 1. window.confirm(&quot;传入的消息&quot;) 2. 返回一个Boolean类型值。确定为ture，取消为false 7. createPopup() 创建一个 pop-up 窗口 8. focus() 把键盘焦点给予一个窗口 9. moveBy() 可相对窗口的当前坐标把它移动指定的像素 10. moveTo() 把窗口的左上角移动到一个指定的坐标 11. open() 打开一个新的浏览器窗口或查找一个已命名的窗口 1. window.open(URL, name, features, replace); 2. url 要打开页面的url name 自己定,可以不要 features 窗口特征 宽高 3. window.open(&quot;www.baodu.com&quot;,&quot;&quot;,&quot;width=200,height=200&quot;); 12. print() 打印当前窗口的内容 13. prompt() 显示可提示用户输入的对话框 1. window.prompt(&quot;提示输入的值&quot;,&quot;默认的文本框的内容&quot;)； 2. 现在用的少，因为不好看，还不能改样式表 14. resizeBy() 按照指定的像素调整窗口的大小 15. resizeTo() 把窗口的大小调整到指定的宽度和高度 16. scrollBy() 按照指定的像素值来滚动内容 17. scrollTo() 把内容滚动到指定的坐标 18. setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 1. 一般用来做定时器,有一个返回值ID，代表这个定时器 2. window.setInterval(&quot;js代码&quot;,毫秒数); 3. 1s = 1000ms 4. 例如：window.setInterval(&quot;alert(&apos;123&apos;);&quot;, 3000); 19. setTimeout() 在指定的毫秒数后调用函数或计算表达式 1. 一般用来做定时器，但是只会执行一次。返回一个ID值，代表这个定时器 2. 例如：window.setTimeout(&quot;alert(&apos;123&apos;);&quot;, 4000); js的dom对象什么是domdom：document object model：文档对象模型 文档：超文本标记文档：html，xml 对象：提供了属性和方法 模型：使用属性和方法操作超文本标记型文档 可以使用js里面的dom里面提供的对象，使用这些对象的属性和方法，对标记型文档进行操作 想要对标记型文档进行操作，首先需要 对标记型文档里面的所有内容封装成对象，需要把HTML里面的标签，属性，文本内容都封装成对象 要想对标记型文档进行操作，解析标记型文档 解析过程根据html的层级结构，在内存中分配一个属性结构，需要把html中的每部分封装成对象 1. 上图中，整个蓝色框住的可以当成一个document对象，表示整个HTML文档 2. 同时一个标签/元素也是一个对象，我们成为标签对象 element 3. 属性对象（id属性之类的） 4. 文本对象（标签括起来的数据） 5. Node（节点）对象是属性，文本，标签对象的父对象 常用方法nodeName String 节点的名字：根据节点的类型定义 nodeValue String 节点的值：根据节点的类型而定义 nodeType Number 节点的类型常量值之一 ownerDocument Document 指向整个节点所属的文档 firstChild Node 指向在childNodes列表中的第一个节点 lastChild Node 指向在childNodes列表中的最后一个节点 childNodes NodeList 所有子节点的列表 parentNode Node 返回一个给定节点的父亲节点 previousSibling Node 指向前一个兄弟节点：如果这个节点就是第一个兄弟节点，那么值为null nextSibling Node 指向后一个兄弟节点 hasChildNodes() Boolean 当childNodes包含一个或多个节点时，返回真 attributes NameNodeMap 包含了代表一个元素的特性的Attr对象，仅用于Element节点 appendChild(node) Node 将node添加到childNodes的末尾 removeChild(node) Node 从childNodes中删除node replaceChild(newnode, node) Node 替换 insertBefore(newnode, refnode) Node 在ChildNodes中的refnode之前插入newnode DHTMLDHTML是很多技术的简称 DHTML=html+css+dom+javascript html：封装数据 css：使用属性和属性值设置样式 dom：操作html文档 JavaScript：专门指的是js的语法语句 document对象每个载入浏览器的HTML文档都会成为document对象 属性1. cookie 设置或返回与当前文档有关的所有 cookie 2. domain 返回当前文档的域名 3. lastModified 返回文档被最后修改的日期和时间 4. referrer 返回载入当前文档的文档的 URL 5. title 返回当前文档的标题 6. URL 返回当前文档的 URL 方法1. close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据 2. getElementById() 返回对拥有指定 id 的第一个对象的引用 3. getElementsByName() 返回带有指定名称的对象集合 4. getElementsByTagName() 返回带有指定标签名的对象集合 5. open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出 6. write() 向文档写 HTML 表达式 或 JavaScript 代码 7. writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符 案例：在末尾添加节点&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1();&quot; /&gt; &lt;script&gt; //任务是，点击按钮，添加一行 555 在 444 后面 function add1(){ var ul = document.getElementById(&quot;ulid&quot;); var text = document.createTextNode(&quot;555&quot;); var li = document.createElement(&quot;li&quot;); li.appendChild(text); ul.appendChild(li); } &lt;/script&gt; 元素对象-element对象在 HTML DOM 中，Element 对象表示 HTML 元素。 Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。 NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。 要操作element对象，首先必须要获取到element，使用document里面对应的方法获取 操作element对象的属性1. 获取属性：getAttribute(name)方法 2. 设置属性：setAttribute(name, valure)方法 例如：input1.setAttribute(&quot;class&quot;,&quot;haha&quot;); 这是 input1元素的class为haha 3. 删除属性：removeAttribute(name)方法 不能删除value属性 获得element中的element对象&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var ull = document.getElementById(&quot;ulid&quot;); var lis = ull.childNodes; alert(lis.length); &lt;/script&gt; 上面的代码在IE中输出4， 在火狐中输出9 因为火狐把 回车 空格 也算作数据了 所以直接通过childNodes直接获得准确的子类是不现实的 在Element对象的范围内，可以用来查找其他节点的唯一有效方法就是getElementsByTagName()方法。 上面的例子中，直接通过 ull.getElementsByTagName(&quot;li&quot;)获得子Element对象就行了。 Node对象属性1. nodeName 节点名称 2. nodeType 节点类型 3. nodeValue 节点的值 标签节点对应的值nodeType 1 nodeName 大写的标签名称 nodeValue null 属性节点对应的值获取方法 getAttributeNode(&quot;属性名称&quot;); nodeType 2 nodeName 属性名称 nodeValue 属性的值 文本节点对应的值获取方法 element.firstChild 或者 lastChild nodeType 3 nodeName #text nodeValue 文本内容 例子使用dom解析html的时候，需要html里面的标签，属性和文本都封装成对象 &lt;span id=&quot;spanid&quot;&gt;呵呵呵&lt;/span&gt; &lt;script&gt; //标签节点 var span1 = document.getElementById(&quot;spanid&quot;); alert(span1.nodeType); //输出 1 alert(Span1.nodeName); //输出 SPAN alert(span1.nodeValue); //输出 null //属性节点 var id1 = span1.getAttributeNode(&quot;id&quot;); alert(id1.nodeType); //输出 2 alert(id1.nodeName); //输出 id alert(id1.nodeValue); //输出 spanid //文本节点 var text = span1.firstChild; alert(text.nodeType); //输出 3 alert(text.nodeName); //输出 #text alert(text.nodeValue); //输出 呵呵呵 &lt;/script&gt; 父节点，子节点，同辈节点&lt;ul id=&quot;ulid&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/ul&gt; ul 是 li 的父节点， li 是 ul 的子节点 li 与 li 是 同辈节点，因为他们是同一级 父节点parentNode 子节点childNodes的到所有的子节点，但是兼容性查 firstChild 第一个子节点 lastChild 最后一个子节点 同辈节点nextSibling 下一个子节点 previousSibling 前一个子节点 操作DOM树appendChild方法添加子节点到末尾 特点：类似于剪切粘贴的效果 例子CSS内容#div1{ width:200px; height:150px; border:2px solid red; } #div2{ width:250px; height:150px; border: 5px dashed green; } HTML内容&lt;div id=&quot;div1&quot;&gt; &lt;ul id=&quot;ulidll&quot;&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1()&quot; /&gt; js内容function add1(){ var div2 = document.getElementById(&quot;div2&quot;); var ull = document.getElementById(&quot;ulidll&quot;); div2.appendChild(ull); } 通过结果可以看到，ul 的内容 从 div1 移动到 div2 中。 insertBefore(newnode, oldNode)方法在oldnode节点之前插入一个新的节点 1. 创建标签 li2 = document.createElement(&quot;li&quot;); 2. 创建文本 text = document.createTextNode(&quot;啦啦啦啦&quot;); 3. 把文本添加到标签下 li2.appendChild(text); 4. 获取 oldNode var li3=document.getElementById(&quot;li3&quot;); 5. 插入 var ul = document.getElementById(&quot;ul1&quot;);//获得父节点 ul.insertBefore(li2, li3); removeChilid 删除节点只能通过父节点删除，不能自己删自己 1. 获取要删除标签 var li3 = document.getElementById(&quot;li3&quot;); 2. 获取父节点 var par = document.getElementById(&quot;ul&quot;); 3. 删除 par.removeChild(li3); replaceChild(newnode, oldnode)替换节点只能通过父节点进行替换，不能自己替换自己 1. 创建新节点 var li = document.createElement(&quot;li&quot;); var text = document.createTextNode(&quot;文本内容&quot;); li.appenChild(text); 2. 获取旧节点 var oldli = document.getElementById(&quot;oldli&quot;); 3. 获取父标签 var ul = document.getElementById(&quot;ul&quot;); 4. 替换标签 ul.replaceChild(li, oldli); cloneNode(boolean) 复制节点//复制ul列表到另一个div中 1. 获取ul var ul = document.getElementById(&quot;ul&quot;); 2. 复制ul，放到类似于剪切板里面 var copyul = ul.cloneNode(true); 3. 获取新的div var newdiv = document.getElementById(&quot;newdiv&quot;); 4. 复制进去 newdiv.appendChild(copyul); 因为 copyul 是复制的新的，所以appendChild的剪贴方法并不会删除掉原 ul innerHTML属性1. 浏览器几乎都支持该属性，但不是DOM标准的组成部分 2. innerHTML属性可以用来读某给定元素里的HTML内容 var span1 = document.getElementById(&quot;span1&quot;); alert(span1.innerHTML);//获取文本内容 3. innerHTML属性可以用来写给定元素里的html内容 var div1 = document.getElementById(&quot;div1&quot;); div1.innerHTML += &quot;&lt;h1&gt;AAA&lt;/h1&gt;&quot;; 案例：动态显示时间1. 获取当前时间： var date = new Date(); date = date.toLocaleString(); 2. 需要让页每秒执行 setInterval()方法 3. 用一个&lt;span&gt;来承接时间 function gettime(){ var date = new Date(); date = date.toLocaleString(); var div = document.getElementsById(&quot;time&quot;); div.innerHtml = date; } //使用定时器，每秒写一次 setInterval(&quot;gettime();&quot;, 1000); 案例：一键全选&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 排球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 篮球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 足球 &lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt; 羽毛球 &lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;setall();&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;全不选&quot; onclick=&quot;setNo();&quot;/&gt; &lt;script&gt; // 复选框中 的 chexked = true 即为选中，反之为没选中 function setall(){ //获取复选框 var loves = document.getElementsByName(&quot;love&quot;); //遍历 loves 数组，整体修改值 for(var i=0; i&lt;loves.length; i++) { var love1 = loves[i]; love1.checked = true; } } &lt;/script&gt; 案例：省市联动选择 湖北省的时候，只会显示湖北省的市，选择湖南省的时候，只会显示湖南省的市 &lt;select id=&quot;sheng&quot; onchange=&quot;add1();&quot;&gt; &lt;option&gt;湖北省&lt;/option&gt; &lt;option&gt;湖南省&lt;/option&gt; &lt;option&gt;山西省&lt;/option&gt; &lt;option&gt;江西省&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;shi&quot;&gt; &lt;/select&gt; // onchange 是 当 select 改变的时候执行的操作 &lt;script&gt; //通过数据库，可以获得每个省份，有哪些城市 var arr = [];//arr存的读取的城市 var select = document.getElementById(&quot;shi&quot;); //一定要先清空 select，否则第二次选择会进行二次添加 var chils = select.getElementsByTagName(&quot;option&quot;); for(var i=child.length-1; i&gt;=0; i--){ var op = option[i]; select.removeChild(op); } for(int i=0; i&lt;arr.length; i++){ var opt = document.createElement(&quot;option&quot;); var text = document.createTextNode(arr[i]); opt.appendChild(text); select.appendChild(opt); } &lt;/script&gt; XML文档什么是xmleXtensible Markup Language：可扩展标记型语言 1. 标记型语言：html也是标记型语言，通过使用标签来操作 2. 可扩展：html里面每个标签都是固定的，有特定的含义。xml中，标签可以自定义，也可以是中文的标签 3. xml技术是W3C组织发部分，目前遵循的是2000发布的XML1.0规范 xml的用途html用于显示数据，xml也可以用来显示数据，但是更主要的功能和目的是同来存储数据。 1. 用于不同系统之间传输数据 1. 如果数据直接用 字符串 传输，接收方并不能解析数据 例如：&quot;120.0.0.1;2018.10.01;hello world&quot;发送方知道这是 &quot;ip地址，时间，内容&quot;，但是接收方并不知道 2. &lt;message&gt; &lt;ip&gt;120.0.0.1&lt;/ip&gt; &lt;time&gt;2018.10.01&lt;time&gt; &lt;content&gt;hello world&lt;/content&gt; &lt;/message&gt; 3. 这样写接收方能懂，并且可以扩展更多标签在&lt;message&gt;中 2. 同来表示生活中有关系的数据 例如： &lt;中国&gt; &lt;湖北&gt; &lt;武汉&gt;&lt;/武汉&gt; &lt;荆州&gt;&lt;/荆州&gt; &lt;/湖北&gt; &lt;湖南&gt; &lt;/湖南&gt; &lt;中国&gt; 3. 经常用在配置文件 1. 用于链接数据库，例如用于存储用户密码，修改密码值用修改xml中的密码、 xml的语法xml的文档声明创建文件，后缀名为 .xml #####写一个文档声明，必须写在第一行第一列 &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 属性version：xml的版本 1.0，1.1 encoding：xml 编码 gbk utf-8 iso8859-1 standalone：yes/no 表示xml文件是否可以独立存在 声明元素（标签）标签的定义1. 标签定义有开始必须有结束：&lt;person&gt;&lt;/person&gt; 2. 标签没有内容，也可以标签内结束：&lt;person /&gt; 3. 标签可以嵌套，必须要合理嵌套 4. 一个xml文档有且必须只有一个根标签 5. 标签的包含的空格和换行会被解析成文本内容处理：&lt;person&gt; 1&lt;person&gt; 和 &lt;person&gt;1&lt;/person&gt;是不一样的 6. xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致 7. 标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头 8. 不能包括 ‘&lt; &gt; , $’ 9. 标签名尽量不要出现英文冒号“:”, 除非是在使用名空间 10. 标签名不能以字符“xml”等任意大小写组合开始 11. 标签名不能包含空格 定义属性html是标记型文档，所以标签有属性。同理，xml也可以用属性 &lt;person id1=&quot;aa&quot;&gt;&lt;/person&gt; 属性定义的要求1. 一个标签上可以有多个属性 2. 同一个标签，不能有属性名相同的属性 3. 属性值一定要用引号，单引号，双引号都行 4. 属性名的命名规范和标签命名规范相同 注释写法&lt;!-- 注释的内容 --&gt; 注释不能嵌套 特殊字符 &amp;&amp; CDATA区开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序 但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。 解决方法： 1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 2. 使用CDATA标记 在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理 实体引用也会失去作用，变成纯文本 语法： &lt;![CDATA[文本内容]]&gt; PI指令（处理指令）可以在xml中设置样式，其实就是外部引入css 引入css：&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt; 但是，对中文的标签元素不起作用，毕竟外国人定义的东西 xml的约束比如定义人的信息的xml，肯定不能出现猫猫狗狗的信息，所以需要约束 由于xml的标签是自定义，所以不加约束容易出现问题。 dtd约束创建一个后缀名为 .dtd 的dtd文件 步骤： 1. 查看xml中有多少个元素 例如： &lt;message&gt; &lt;ip&gt;120.0.0.1&lt;/ip&gt; &lt;time&gt;2018.10.01&lt;time&gt; &lt;content&gt;hello world&lt;/content&gt; &lt;/message&gt; 有四个元素（标签） 2. 有多少个元素，就在dtd文件中写多少个&lt;!ELEMENT&gt; 3. 判断元素是简单元素还是复杂元素 1. 有子元素的元素是复杂元素 &lt;!ELEMENT 元素名称(子元素名称逗号隔开)&gt; &lt;!ELEMENT message(ip+,time？,content*)&gt; `其中 + ? * 是选择性加上，代表子标签在根标签下出现的次数 1. + 代表出现一次或多次 2. ？ 代表出现0次或1次 3. * 打表出现0次或多次 默认是只出现一次` 逗号连接子元素名称时，子元素必须按顺序出现用 | 隔开时，表示只能出现范围中的一个 2. 没有子元素的元素是简单元素 &lt;!ELEMENT 元素名称 (#PCDATA)&gt; &lt;!ELEMENT ip (#PCDATA)&gt; &lt;!ELEMENT time (#PCDATA)&gt; &lt;!ELEMENT content (#PCDATA)&gt; 4. 在xml中引入外部dtd文件，写在&lt;xml&gt;标签行下 &lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd文件路径&quot;&gt; 4. 在xml内部定义dtd &lt;!DOCTYPE 根元素名称[ &lt;!ELEMENT 子标签 (#PCDATA)&gt; ]&gt; 例如： &lt;!DOCTYPE message[ &lt;!ELEMENT ip (#PCDATA)&gt; &lt;!ELEMENT time (#PCDATA)&gt; &lt;!ELEMENT content (#PCDATA)&gt; ]&gt; 4. 使用外部/网络的dtd文件 &lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt; 用浏览器打开的时候，浏览器之校验语法，不校验约束，所以用浏览器打开不能查看是否约束上 使用dtd定义属性语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 属性的约束&gt; 1. 属性类型有三种 1. CDATA：表示属性的取值为普通的文本字符串 2. ENUMERATED：表示枚举，只能从枚举列表中任选其一 例如：（鸡肉|鸭肉|鱼肉|牛肉）这种方法定义枚举 3. ID：表示属性的取值不能重复，只能是字母，下划线开始 2. 属性的约束有三种 1. #REQUIRED：表示该属性必须出现 2. #IMPLIED：表示该属性可有可无 3. #FIXED：表示属性的取值为一个固定值 4. 直接写一个值上去：表示属性的默认值为你直接协商的值 例如：&lt;!ATTLIST ip ID1 CDATA &quot;wwww&quot;&gt; 则ID1属性的值默认为www schema约束空 xml解析xml是标记型文档 js使用dom解析标记型文档 根据html的层级结构，在内存中分配一个属性结构，把html的标签属性和文本封装成对象 document对象，element对象，属性对象，文本对象，node节点对象 xml的解析方式：dom 和 sax dom方式解析根据 xml 的层级结构在内存中分配一个树形结构，把xml的标签，属性和文本都封装成对象 缺点：如果文件过大，造成内存溢出 优点：方便实现增删改操作 sax方式解析采用事件驱动方式，边读便解析，从上到下，一行一行的解析，解析到某个对象，返回对象名称 缺点：不能实现增删改 优点：不会造成内存溢出，方便实现查询操作 dom和sax方式的解析器不同的公司和组织提供了针对dom和sax方式的解析器，通过api方式提供 1. sun公司提供 jaxp 2. dom4j组织提供 dom4j（实际开发中用的比较多） 3. jdom组织提供 jdom jaxp的api的查看jaxp是javase的一部分 jaxp解析器在jdk的javax.xml.parsers包里面 DocumentBuilder 定义API，使其从xml文档获取DOM文档实例 DocumentBuilderFactory 定义工厂API，是应用程序能够从xml文档获取生成DOM对象数的解析器 SAXParser 定义包装XMLReader实现类的API SAXParserFactory 定义工厂API，是应用程序能够配置和获取基于sax的解析器以解析XML文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2F2017%2F09%2F26%2Fxml%2F</url>
    <content type="text"><![CDATA[xml概述：可扩展标记语言。(Extensible Markup Language) 允许开发者自由定义标签，可以将标签和内容有效分离。 xml不再侧重于数据如何展示，二十更过的关注数据如何存储和传输。 xml应用场景：1. xml把数据从HTML分离出来。那温度距离，用html注重于显示而无关数据，用xml改变数据，让html读取。 2. 简化数据共享。提供了独立于软件和硬件的存储方式。 3. 简化数据的传输。通过xml，可以在不兼容的系统之间传输数据。 4. 简化平台的变更。 xml的优势：1. 简单易用的标记预语言。xml标签可以自己自由定义。 2. 严格的格式。比html标签控制更严格。 3. 数据逻辑和显示逻辑分离。html注重于显示，xml注重于数据存储。 xml文档规则：1. 有且只有一个根元素 2. 元素必须合理结束 3. 元素之间必须合理嵌套 4. 元素的属性必须有值 xml存储信息：例如：书名 作者 价格 java思想 小王 79.00 Spring指南 小李 89.00 xml的写法字符集：1. 简体中文：GBK 或 GB2312 2. 繁体中文：BIG5 3. 西欧字符：ISO8859-1 4. 通用的国际编码：Unicode 5. 针对Unicode的可变长度字符编码UTF8 合法标签名：xml元素由开始标签和结束标签组合，结束标签比开始标签多一条斜线 xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致 标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头 不能包括 ‘&lt; &gt; , $’ 标签名尽量不要出现英文冒号“:”, 除非是在使用名空间 标签名不能以字符“xml”等任意大小写组合开始 标签名不能包含空格 空元素：例：&lt;元素名 属性名=&quot; &quot; /&gt; 空元素不是内容为空的元素，空元素不接受子元素，也不接受字符内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; standalone = &quot;yes&quot; ?&gt; &lt;书籍列表&gt; &lt;书名&gt; java思想&lt;/书名&gt; &lt;价格&gt;79.00&lt;/价格&gt; &lt;作者&gt;小王&lt;/作者&gt; &lt;书名&gt;Spring指南&lt;/书名&gt; &lt;价格&gt;89.00&lt;/价格&gt; &lt;作者&gt;小李&lt;/作者&gt; &lt;/书籍列表&gt; 那么 &lt;书籍列表&gt; 就是根元素 字符数据：开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序 但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。 解决方法： 1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）： &amp;lt; ---&gt; &quot;&lt;&quot; 小于符号 &amp;gt; ---&gt; &quot;&gt;&quot; 大于符号 &amp;amp; ---&gt; &quot;&amp;&quot; and符号 &amp; &amp;apos; ---&gt; &quot;&apos;&quot; 英文单引号 &amp;quot; ---&gt; &quot;&quot;&quot; 英文双引号 2. 使用CDATA标记 在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理 实体引用也会失去作用，变成纯文本 语法： &lt;![CDATA[文本内容]]&gt; 换行处理：目前主流的操作系统，主要由3种换行符： 1. Windows平台：回车符（CR） 和 换行符 （LF） 的组合存储换行 2. Unix和Linux平台：以换行符（LF）存储换行 3. Macintosh平台：以回车符（CR）存储换行 xml同一换行符（LF） 存储换行 命名空间：同一份xml文档中可能出现多个同名的元素和属性。必须添加标记判断 语法： xmlns[:prefix]= &quot;命名空间字符串&quot; xmlns -&gt; xml namespace 例如： xmlns:hehe = &quot;http://www.***.com&quot; &lt;hehe:name&gt;java思想&lt;/hehe:name&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL命令]]></title>
    <url>%2F2017%2F09%2F26%2FMySQL%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Windows下进入命令行ssh 用户名@ip地址 或者 mysql -h ip地址 -u root -p 然后输入密码 mysql -u 数据库用户名 -p 然后输入密码 修改密码：`mysqladmin -u root -p 密码 password 新密码` 增加用户：`insert into mysql.user(Host,User,Password) values (&quot;localhost&quot;,&quot;test&quot;,password(&quot;1234&quot;));（登陆地址，用户名，密码） ` 用户授权：`grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;; ` `权限包括：select,insert,update,delete，all privileges ` `记得创建授权之后，flush privileges;//刷新系统权限表 ` 删除用户：`root权限下 Delete FROM user Where User=&apos;用户名&apos; and Host=&apos;ip地址&apos;; ` `flush privileges; ` 修改密码：`update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;test&quot; and Host=&quot;localhost&quot;; ` 查看数据库：`show databases; ` 链接数据库：`use 库名； ` 查看数据表：`show tables; ` 查看状态：`show status like &apos;%下面变量%&apos;; ` Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。 Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 Connections 试图连接MySQL服务器的次数。 Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。 Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。 Delayed_writes 用INSERT DELAYED写入的行数。 Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。 Flush_commands 执行FLUSH命令的次数。 Handler_delete 请求从一张表中删除行的次数。 Handler_read_first 请求读入表中第一行的次数。 Handler_read_key 请求数字基于键读行。 Handler_read_next 请求读入基于一个键的一行的次数。 Handler_read_rnd 请求读入基于一个固定位置的一行的次数。 Handler_update 请求更新表中一行的次数。 Handler_write 请求向表中插入一行的次数。 Key_blocks_used 用于关键字缓存的块的数量。 Key_read_requests 请求从缓存读入一个键值的次数。 Key_reads 从磁盘物理读入一个键值的次数。 Key_write_requests 请求将一个关键字块写入缓存次数。 Key_writes 将一个键值块物理写入磁盘的次数。 Max_used_connections 同时使用的连接的最大数目。 Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。 Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。 Open_tables 打开表的数量。 Open_files 打开文件的数量。 Open_streams 打开流的数量(主要用于日志记载） Opened_tables 已经打开的表的数量。 Questions 发往服务器的查询的数量。 Slow_queries 要花超过long_query_time时间的查询数量。 Threads_connected 当前打开的连接的数量。 Threads_running 不在睡眠的线程数量。 Uptime 服务器工作了多少秒。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java的文件和时间操作]]></title>
    <url>%2F2017%2F09%2F25%2Fjava%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[File 类构造函数有：传入相对路径（一个参数） 传入绝对路径（一个参数） File类指定为当前文件的父级，当前文件的名称（两个参数） 文件删除读写改名File file = new File(&quot;hello.txt&quot;);//对于工程而言用相对路径，创建在根目录下。也可以用绝对路径指定文件夹 //File file = new File(&quot;bin/hello.txt&quot;);工程文件夹下的bin文件夹的hello.txt文件 //File file = new File(&quot;../hello.txt&quot;);工程文件夹的上一级文件中新建hello.txt文件 if(file.exists()){ System.out.printlen(file.isFile());//判断文件是文件 System.out.println(file.isDirectory());//判断文件是文件夹 File nameto = new File(&quot;new name .txt&quot;); file.renameTo(nameto);//将file的名字改为nameti的名字 File nameto1 = new File(&quot;src/new name.txt&quot;); file.renameTo(nameto1);//将文件移动到src目录下 file.delete();//删除文件 }else{ System.out.println(&quot;文件不存在&quot;); try{ file.createNewFile(); System }catch(IOException e){//抛出异常 e.printStackTrace(); System.out.println(&quot;文件无法创建&quot;); } } 测试样例，用于文件的读取新建一个test.txt文件，内容随意。 File file = new File(&quot;text.txt&quot;); if(file.exitst()){ try{ FileInputStream fis = new FileInputStream(file);//属于字节流 InputStreamReader isr = new InputStreamReader(fis. &quot;UTF-8&quot;);//属于字符流，在字节转换为字符的时候，需要指定编码，否则可能会出现乱码。 BufferedReader br = new BufferedReader(isr);//带有缓冲区的reader String line;//用于存放临时数据 while ((line = br.readLine()) != null){ System.out.println(line);//输出读取的一行 } 关闭输入流，先打开的后关闭，后打开的先关闭。 br.close(); isr.close(); fis.close(); }catch (FileNotFoundException e){ 该异常对应于 FileInputStream }catch (UnsupportedEncodingException e){ 该异常对应于 InputStreamReader }catch (IOException e){ 该异常对应于 ***.close() } } 测试样例，用于写入文件File newfile = new File(&quot;newtest.txt&quot;); try{ FileOutPutStream fos = new FileOutputStream(newfile); OutPutStreamWriter osw = new OutPutStream(fos, &quot;UTF-8&quot;); BufferedWriter bw = new BufferedWriter(osw); bw.write(&quot;你要写入的内容&quot;); 。。。。。。。 bw.close(); osw.close(); fos.close(); //同样，先打开的后关闭，后打开的先关闭。 } 文件夹操作File类可以表示文件或者文件夹，但是两者之间的是有区别的 File folder = new File(&quot;my new folder&quot;); // folder.createNewFile() 使用该方法创建的是一个文件，只是文件没有后缀罢了 folder.mkdir();//创建一个文件夹，返回值是一个bool类型，true为创建成功，false为失败 //如果 已经存在 名为 “my new folder”的文件夹，则创建失败。也就是说不能出现同名的文件或者文件夹 如果使用mkdir()，那么创建的文件夹必须是物理上存在的文件夹，也就是说，如果创建“one/two/test”这样的文件夹，但是 不存在one文件夹，那么是不会自动补全路径的。这时候我们就需要用 mkdirs()，也就是 file.mkdirs()这个语句。 //文件夹给名字的方法跟文件改名字的方法类似 File folder = new File(&quot;my new folder&quot;); File newfolder = new File(&quot;new folder&quot;); folder.renameTo(newfolder);//返回的是一个bool类型的值，可以通过if判断是否修改成功 //用这种方式修改文件夹的名字 forlder.delete();//删除文件夹，但是只能删除空文件夹 在windows中，千万注意移动文件夹不要跨盘移动，否则失败。因为Windows的文件系统是森林格式，而Linux和Mac系统是数状的 一些判断获取语句File file = new File(&quot;test.txt&quot;); //判断文件是否存在 file.exists(); //读取文件名称 file.getName(); //读取文件相对路径 file.getPath(); //读取文件的绝对路径 file.getAbsolutePath(); //读取文件父级路径 file.getParent(); //读取文件大小（字节） file.length(); //判断文件是否被隐藏（Linux和unix中，文件以 &quot; . &quot;开头代表隐藏） file.isHidden(); //判断文件是否可读 file.canRead(); //判断文件是否可写 file.canWrite(); //判断文件是否为文件夹 file.isDirectory(); //当程序退出时将文件删除 file.deleteOnExit(); 设置文件属性：File file = new File(&quot;test.file&quot;); //设置为可写 file.setWritable(true);//传入 true 则设置文件可写，否则设置为不可写 //设置为可读 file.setReadable(true);//与上述相同。 //设置为只读 file.setReadOnly(); 遍历文件夹public static void printfFiles(File dir){ { if( dir.isDirectory() ){ File next[] = dir.listFiles(); for( int i = 0; i&lt;next.length; i++){ if( next[i].ifFile() ){//输出文件的名字 System.out.println(next[i].name); }else{//递归的输出文件的名字 printfFiles(next[i]); } } } } 时间操作Date表示时间，日期。但是更新jdk之后就不推荐使用了。官方解释是 使用Date类不利于国际化。所以jdk1.1版本后推荐使用Calendar类。使用DateFormat类进行时间日期的格式化。Long类型表示时间类型。String类型表示时间日期类的显示。 Date.getTime();//获取Date对象的时间 Date.setTime(long time);//设置Date的时间 Calendar rightnow = Calendar.getInstance();//获取当前时间 long now = System.currentTimeMillis();//获得系统的当前时间，但是这个时间只有机器能读懂 Date d1 = new Date(now);// 获取人能够读懂的时间 Calendar c1 = Calendar .getInstance(); System.out.print(c1.getTime().toString());//获得人能够读懂的时间 String -&gt; 时间 &amp;&amp; 时间 -&gt; String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//指定日期的格式 sdf.format(date);//将Date类型转换为指定格式的String类型，返回的是一个String类型 sdf.parse(&quot;2015-06-01&quot;);//将String转换为Date类型，返回的是一个Date类型 //SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); 时间格式为 年月日 时分秒]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring学习]]></title>
    <url>%2F2017%2F01%2F20%2FSpring%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Spring简介Spring的存在是因为它自身有着得天独厚的优势： 它定位的领域是许多其他流行的framework没有的 Spring是全面的和模块化的 它的设计是从底部榜之你编写易于测试的代码 Spring是潜在的一站式解决方案 Spring天生就存在如下优点： 低侵入式设计，代码污染极低 Write Once, Run Anywhere DI有效的降低了耦合度 AOP提供了通用任务的集中管理 ORM和DAO简化了对数据库访问 高度开放性，并不强制 Spring的优点给开发带来的好处： 可以有效组织中间层对象 使用统一的配置我呢见 促进良好编程习惯，减少编程代价 易于单元测试 使用EJB成为一种备选 为数据存取提供了一致的框架 Spring的特点： 方便解耦，简化开发 AOP编程的支持 声明式事务的至支持 方便程序的测试 方便集成各种优秀框架 降低JAVAEE API的使用难度 Spring的源码是经典学习范例 Spring的核心模块 Spring总结 spring带来的复杂的J2EE开发的春天 他的核心是轻量级的IoC容器，他的目标是为J2EE应用提供了全方位ie的整合框架，在Spring框架下实现多个子框架的组合，这些子框架之间可以彼此独立，也可以使用其他的框架方案加以替代 Spring系统为企业应用提供一站式的解决方案 Spring之AOP什么是AOP面向切面的编程 AOP将应用系统分为两个：核心业务逻辑 和 横向的通用逻辑 AOP是对OOP的一种完善 AOP的主要功能： 主要用于系统级别的功能 日志记录 性能统计 安全控制 事务处理 异常处理 等等 AOP将常用服务模块化，并且用声明的方式将这些组件使用到其他的业务组建当中去，这样做的结果是每个业务只需要关心自己的业务组件逻辑，而不需要关心常用的服务组件，这样就保证了内聚性 AOP专门用于处理系统中分布于各个模块中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统服务，如事务管理，安全检查，缓存，对象管理等，AOP已经成为一种非常常用的解决方案： 例如： 如果是这个样子，三个模块的相同代码段都是通过复制，粘贴其他的代码，如果有一天，复制的代码需要修改，那么就要修改三个部分 如果是这个样子，来调用深色区域的代码块，那么可以完成同时修改，降低后续维护的复杂度，可以解决大部分的场景 如果应用需要三个方法彻底与深色方法分离，那么上述两个方法就不合适了 运用AOP AOP专门用于处理系统模块中，分布于各个模块中的交叉关注点问题，通常使用AOP处理系统中具有横切性质的问题 AOP代理其实是AOP框架动态生成的一个对象，该对象可作为目标对象使用 使用AOP方法中，需要程序员参与的就是： 定义不同业务组件 定义切入点 定义增强处理 在AOP框架为普通组件植入的处理动作 代理对象的方法 = 增强处理+被对代理的方法 AOP的关键概念的解释： 切面 - Aspect 一个关注点的模块化，这个关注点可能会横切多个对象 事务处理是一个J2EE应用中关于横切接入点的很好的例子 连接点 - Join Point 程序执行的当中的某个特定的点，例如：某方法调用的时候，处理异常的时候 通知 - Advice 切面某个特定的连接点上执行的动作 around, before, after 等通知 许多AOP框架中以拦截器为同志模型 切入点 - Point Cut 匹配连接点的断言 通知和一个切入点表达式的并联，并在满足这个切入点的连接点上运行 引入 - Introduction 用来个一个类型声明额外的方法和属性 目标对象 - Target Object 被一个或多个切面所通知的对象，也被称作被通知对象 Spring AOP 是通过运行是代理实现的，那么这个对象永远是一个被代理的对象 AOP代理 - AOP Proxy AOP框架所创建的对象 织入 - Weaving 把切面连接到其他的应用程序类型或者对象之上，并创建一个被通知的对象 AOP通俗的理解一个组件A，不关心其他常用的服务组件B，但是这个组件A使用组件B的时候，不是组件A自身去调用，而是通过配置的呢个其他方式，不如Spring中可以通过xml配置文件。 这样就是的A压根就不需要知道组件B是怎样的。A只需要关心自己的业务逻辑，具体A使用B的时候，配置文集去做，与具体的A组件无关 Spring 之 IOC浅谈IOCIOC（Inversion of Control，控制反转）是Spring的核心，贯穿始终。 所谓IOC，对于Spring框架来说，就是有Spring来负责控制对象的生命周期和对象间的关系 传统开发模式：对象之间互相依赖 在一个对象中使用另一个对象，就必须要自己new一个对象，或者查询一个 使用完之后要将对象销毁 就像自己找女朋友，要自己找到一个女孩子，知道她的qq，mail，等等 IOC开发模式：IOC容器安排对象之间的依赖 就像去婚介找女朋友，提出要求，婚介会按要求匹配女朋友介绍给你 对象之间的依赖关系由IOC来控制 所有的类都会在Spring容器中登记，告诉它你是个什么东西，你需要什么东西 Spring会在系统运行的时候，在适当的时间把你需要的东西传递给你 同时也会把你交给需要你的对象 IOC理论的背景传统一个齿轮出现问题，那么整个系统就可能出现问题 IOC把复杂系统，分解成相互协作的对象，这些对象通过内部实现，对于外部是透明的，从而降低解决问题的复杂度 终极目标A，B，C，D四个模块之间并没有关联。这也是Spring的终极目标 控制反转 上面三张图就能很明显的观察到控制反转： 初始的时候，每个对象的控制权都在自己手上，不管是创建对象或者是删除对象 在引入IOC后，每个对象的控制权都在IOC容器中，当A运行的到需要B的时候，IOC容器会主动创建B对象，注入到A中 控制权颠倒了过来，这就是控制反转的由来 依赖注入（DI）IOC的另外的名字叫做依赖注入（Dependency Injection），所谓的依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象中。 所以，依赖注入（DI）金额控制反转（IOC）是从不同的角度的描述同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦 IOC的好处 IOC在编程过程中不会对业务对象构成很强的侵入性，使用IOC之后，对象具有更好的可实用性，可重用性和可扩展性 降低组件之间的耦合度 提高开发效率和产品质量（只需要要求接口规格，每个人只需要关心自己的工作） 统一的标准，提高模块的复用性 模块具有热插拔特性（IOC生成方式转为外置方式，把对象的生成放在了配置文件里进行定义，这样的实现子类变得更加简单，只需要更改配置文件） IOC的通俗的了解 IOC控制反转 创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重于原理 DI依赖注入 创建对象实例的时候，为这个对象注入属性值或其他对象实例，侧重于实现 Spring的配置文件浅析Spring的配置文件概述Spring的配置文件是用于指导Spring工厂进行Bean的生产，依赖关系注入及Bean实例分发的“图纸”，它是一个或多个标准的XML文档，J2EE程序员必须学会灵活应用这份“图纸”，准确地表达自己的“生产意图“ Spring配置文件示例 Spring配置文件的结构一般结构如下 &lt;beans&gt; 用于表示bean表示的开始或结束 &lt;import resource = “resource1.xml” &gt; 用于导入其他配置文件bean的定义，可以放在beans标签下的任何位置 &lt;import resource = “resource2.xml”&gt; &lt;bean id = “bean1” class=”***”&gt; 使用id calss 定义了一个bean &lt;bean name=”bean2” class=”***”&gt; 使用name class定义了一个bean &lt;alias alias=”bean3” name=”bean2” /&gt; 定义别名，这句话的意思是 bean3 和 bean2 是同一个bean &lt;/beans&gt; Spring容器高层视图 Spring容器启动基本条件 Spring框架的类包 Bean的配置信息 Bean的实现类 Spring启动时读取程序提供的bean的配置信息，并在Spring中生成一份相应的bean的配置注册表，然后根据注册表实例化bean，装配好bean之间的依赖关系，为上层应用提供好准备就绪的应用环境 Bean的与元数据信息： Bean的实现类 Bean的属性信息 Bean的依赖关系 Bean的行为配置 Bean的创建方式 基于XML的配置Spring的配置文件是居于XML格式的，Spring1.0的配置文件采用DTD格式，Spring2.0以后使用Schema的格式，后者让不同类型的配置拥有了自己的命名空间，使配置文件更具有扩展性 采用Schema的配置格式，文件头的声明会复杂一些 例如： xmlns 默认命名空间，用于Spring Bean的定义 xmlns:xsi 定义了一个名为xsi的命名空间，为每个文档中命名空间指定相对应的Schema的样式文件，是标准组织定义的标准命名空间 xmlns:aop 定义了，是Spring 配置aop的命名空间，是用户自定义的命名空间 命名空间步骤： 指定命名空间的名称 指定Schema文档样式名称的位置 Spring3.0的配置Schema文件分布在各模块类包中，如果模块拥有对应的Schema文件，则可以在模块类包中找到一个config目录，Schema文件就位于该目录中。 Spring Bean的命名 每个Bean可以有一个或多个id，我们把第一个id成为”标识符“，其余id叫做”别名“，这些id在IOC容器中必须唯一。 Bean id 的命名方式和命名约定 配置全限定类名，唯一的 &lt;bean class=”com.ctgu.spring.mode.definition.HelloworldImpl”&gt; .getBean(HelloworldImpl.class); 指定id，唯一的 &lt;bean id = “helloworld” class=”com.ctgu.spring.mode.definition.HelloworldImpl”&gt; .getBean(“helloworld”, HelloworldImpl.class); 指定name，唯一的 &lt;bean name=”helloworldName” class=”com.ctgu.spring.mode.definition.HelloworldImpl”&gt; .getBean(“helloworldName”, HelloworldImpl.class); 同时指定name和id，唯一的 &lt;bean id=”helloworldid” name=”helloworldname” class=”com.ctgu.spring.mode.definition.HelloworldImpl” &gt; 同上，二选其一 多个name，唯一的 Spring Bean的实例化Spring IOC容器如何实例化Bean呢？传统应用程序可以通过new和反射方式进行实例化Bean。而Spring IOC 容器则需要根据Bean定义里的配置元数据使用反射机制来创建Bean。 在Spring IOC容器中主要有以下几种创建Bean实例的方式： 使用构造器实例化Bean 无参构造器 有参构造器 使用静态工厂方式实例化Bean 除了指定必须的class属性，还要指定factory-method的属性 允许指定方法参数 使用实例工厂方法实例化Bean 不能指定方法参数 HelloWorldImpl类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ctgu.***.HelloWorldImplpublic class HelloWorldImpl&#123; private int id; private String name; private Set&lt;String&gt; sets; private List&lt;String&gt; list; private String[] strings; private Map&lt;String, String&gt; map; public void setId(int id)&#123; this.id = id; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getId()&#123; return this.id; &#125; public String getName()&#123; return this.name; &#125; public HelloWorldImpl()&#123; System.out.println("无参构造函数"); &#125; public HelloWorldImpl(int id, String name)&#123; System.out.println("有参构造函数"); &#125; public void setSets(Set&lt;String&gt; sets)&#123; &#125; public Set&lt;String&gt; getSets()&#123; return this.sets; &#125; public void setList(List&lt;String&gt; list)&#123; this.list = list; &#125; public List&lt;String&gt; getList()&#123; return this.list; &#125; public String[] getStrings()&#123; return this.strings; &#125; public void setStrings(String[] strings)&#123; this.strings = strings; &#125; public void setMap(Map&lt;String, String&gt; map)&#123; this.map = map; &#125; public Map&lt;String, String&gt; getMap()&#123; return this.map; &#125;&#125; 构造器实例化构造器实例化Bean是最简单的方式，Spring IoC容器既能使用默认空间构造器，也能使用有参数构造器两种方式创建Bean。 空构造器实例化 1&lt;bean id="helloServerNoWithArgs" class="com.ctgu.***.HelloWorldImpl" /&gt; 有参数构造器实例化 12345&lt;bean id="helloServerNoWithArgs" class="com.ctgu.***.HelloWorldImpl" /&gt; &lt;!-- 是定构造器参数 index表示位置 value 表示值 --&gt; &lt;constructor-arg index="0" value="10" /&gt; &lt;constructor-arg index="1" value="Hello Spring" /&gt;&lt;/bean&gt; 在main 函数中 1234public static void main(String[] args)&#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); HelloWorldImpl hello = ac.getBean("helloServerNoWithArgs", HelloWorldImpl.class);&#125; 静态工厂实例化使用静态工厂的方式除了指定必须的class属性，还要指定factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也允许指定方法参数，Spring IoC容器将调用此属性指定的方法来获取Bean 123456// helloWorldStaticFacorty静态工厂类// 有一个函数名叫 newInstancestatic HelloWorldImpl newInstance(int id, String name)&#123; return new HelloWorldImpl(id, name);&#125; 1234567&lt;!-- 使用有参数构造参数--&gt;&lt;bean id="helloServiceStaticFacory" class="com.ctgu.***.helloWorldStaticFacorty" factory-method="newInstance"&gt; &lt;!-- 上述的 newInstance 就是静态工厂类的函数名 --&gt; &lt;!-- 指定构造器参数 --&gt; &lt;constructor-arg index="0" value="10"/&gt; &lt;constructor-arg index="1" value="hell static factory"/&gt;&lt;/bean&gt; 实例工厂实例化使用实例工厂的方式不能指定class属性，此时必须facroty-bean属性来指定工厂Bean，factory-method属性指定实例化Bean的方法，而且使用实例化工厂方法允许指定方法参数，方法和使用构造器一样 123456&lt;bean id="beanInstanceFacory" class="com.ctgu.***.HelloWorldInstanceFactory" /&gt;&lt;!-- 使用实例工厂Bean创建Bean --&gt;&lt;bean id="helloworldinstance" factory-bean="beanInstanceFacory" factory-mathod="newInstance"&gt; &lt;constructor-arg index="0" value="10"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="hello instnace facory!"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 设置实例化对象的参数 通过构造方法来设置值 12345&lt;bean id="helloServerNoWithArgs" class="com.ctgu.***.HelloWorldImpl" /&gt; &lt;!-- 是定构造器参数 index表示位置 value 表示值 --&gt; &lt;constructor-arg index="0" value="10" /&gt; &lt;constructor-arg index="1" value="Hello Spring" /&gt;&lt;/bean&gt; 设置注入（通过set方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;bean id="helloServerNoWithArgs" class="com.ctgu.***.HelloWorldImpl" /&gt; &lt;property name="id" value="10"&gt;&lt;/property&gt; &lt;property name="name"&gt; &lt;value&gt;test&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 上述两种赋值方法等效 --&gt;&lt;!-- 通过对象的set方法设置值，name为参数名，value为设置的值 --&gt; &lt;property name = "sets"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- 通过上述方法对Set对象赋值 --&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!-- 通过上述方法对List对象赋值 --&gt; &lt;property name="strings"&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- 通过上述方法对数组赋值 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="a" value="b"&gt; &lt;/entry&gt; &lt;entry key="b" value="b"&gt; &lt;/entry&gt; &lt;entry key="c" value="b"&gt; &lt;/entry&gt; &lt;entry key="d" value="b"&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;!-- 通过上述方法对Map对象赋值 --&gt; Spring Bean的作用域Spring Bean中所说的作用域，在配置文件中即是“scope”这个属性。 在面向对象程序设计中一般指对象或变量之间的可见范围。而在spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围 singleton： &lt;bean id=&quot;userInfo&quot; class=&quot;com.ctgu.userinfo&quot; scope=&quot;sigleton&quot;&gt;&lt;/bean&gt; Spring IoC 只会创建该bean创建的唯一的实例，即Instance，单例Bean prototype: &lt;bean id=&quot;userInfo&quot; class=&quot;com.ctgu.userinfo&quot; scope=&quot;prototye&quot;&gt;&lt;bean&gt; 每次请求的时候，Spring IOC容器都会创建一个实例 对于 对于有状态的Bean应该使用prototye，对于无状态的Bean应该使用singleton request： &lt;bean id=&quot;userinfo&quot; class=&quot;com.ctgu.userInfo&quot; scope=&quot;request&quot;&gt;&lt;/bean&gt; 针对每次http请求，Spring容器会根据相关的Bean的定义来创建一个全新的Bean实例 创建的Bean实例仅在当前的HttpRequest中有效 session：&lt;bean id=&quot;userinfo&quot; class=&quot;com.ctgu.userInfo&quot; scppe=&quot;session&quot;&gt;&lt;/bean&gt; session针对某个HttpSession来起作用的 Spring容器会根据该Bean的定义创建一个全新的Bean的实例 global-session：&lt;bean id=&quot;userinfo&quot; class=&quot;com.ctgu.userInfo&quot; scppe=&quot;globalSession&quot;&gt;&lt;/bean&gt; singleton作用域是指在Spring IOC容器中仅存在一个Bean的实例，Bean以单例的方式存在，单实例模式是重要的设计模式之一，在Spring中对此实现了超越，可以对那些非线程安全的对象采用单实例模式 prototype作用域是指每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new Bean()的操作。在默认情况下，Spring容器在启东市实例化prototype的Bean 当用户使用Spring的WebbApplicationContext时，还可以使用另外3中Bean的作用域，即request，session和globalSession。在使用Web应用环境想关的Bean作用域时，必须在Web容器中进行一些额外配置 低版本Web容器配置 运用过滤器filter来进行相关配置 12345678&lt;filter&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; &lt;servlet-name&gt;/*&amp;lt;/srevlet-name&gt; &lt;/filter-mapping&gt; 高版本Web容器配置 运用Http 请求监听器进行相关配置 123&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.request.RequestContext.listener&lt;/listener-class&gt;&lt;/listener&gt; Web应用环境的作用域 request作用域 一个http请求和生命周期 请求处理完毕后消除生成的Bean session作用域 横跨整个httpsession session结束后清除所有实例化的Bean globalSession作用域自定义作用域 在Spring2.0中，Spring的Bean作用域机制是可以扩展的，这意味着你不仅可以使用Spring提供的预定义Bean作用域，还可以自定义作用域，甚至重定义现有的作用域（不提倡这么做，而且不能覆盖内置的singleton和prototype） 实现自定义Scope类 org.speingframework.beans.factory.config.Scope 注册自定义的Scope类 ConfigurableBenFactory.registerScope(String scopeName, Scope scope) 配置文件的整合这里有多个配置文件： Spring-Common.xml 位于 common文件夹下 Spring-Connection.xml 位于 connection 文件夹下 Spring-Module.xml 位于 module 文件夹下 传统加载方式ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{“Spring.-Common.xml”,”Spring-Connection.xml”,”Spring-ModuleA.xml”}); 整合配置文件:Spring-All_Module.xml &lt;beans … …&gt; &lt;import resource=”connection/Spring-Connection.xml” /&gt; &lt;import resource=”common/Spring-Common.xml” /&gt; &lt;import resource=”module/Spring-Resouce.xml” /&gt; &lt;/beans&gt; 整合后的加载方式- ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Spring-All-Module.xml&quot;); Java注解技术 注解 顾名思义就是对某个事物添加 注释 说明 存放一些信息，对未来某个时刻可能有用 Java注解又叫做Java标注Java提供了一套机制，使得我们可以对类，包，方法，参数，域以及变量等添加标注，添加某些信息并且在以后的某个时段通过反射将标注的信息提取出来，以供使用 Java注解技术基本概念概念 Annotation是Java5开始引入的新特征 中文名称一般叫注解 它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类，方法，成员变量等）进行关联 注解 对某一事物添加注释说明，存放以后可能会用到的信息 对类，包，方法，参数，域以及变量等添加标注，即附加上某些信息 Annotation就是Java提供一种源程序中，元素关联关联任何信息和任何元数据的途径和方法 可以用于创建文档，跟踪代码中的依赖性，执行基本编译检查原理注解是一种接口，通过Java 反射机制相关的API来访问注解信息相关类，即： 框架 工具当中的类Java语言解释器在工作的时候会忽略这些注解，因此在Java虚拟机当中这些注解是不起作用的 注解不同于接口 注解是使用关键字， @interface，而不是interface 注解类型方法定义是独特的，受限制的。注解类型的方法必须声明为无参数，无异常抛出的，这些方法定义了注解的成员，方法名成为了成员名，而方法返回值成为了成员你的类型 注解类型又与接口又相似之处，可以定义常亮，静态成员类型应用场合注解一般被作为一种辅助途径，应用在软件框架或者工具当中在这些工具类中，根据不同的注解信息采取不同的处理过程，或者改变相应的程序元素Java标准注解Java内置了三种标准注解Override注解用作标注方法，说明了被标注的方法，重载的父类的方法，起到了断言的作用如果我们使用这种注解，在一个没有覆盖父类方法的方法时，Java编译器讲以一个编译错误来进行解释这个注解常用在我们试图覆盖父类方法，而又写错了方法名称 时，加上一个Override这样一个保证性校验过程 Deprecated当一个类型或者类型成员使用@Deprecated修饰的时候，编译器将不鼓励使用这种被标注的程序元素。所以使用这种注解修饰具有一定的延续性，即如果我们在代码中通过继承或者覆盖的方法使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型成员并不是被声明为@Deprecated，但编译器仍然要报警 SuppressWarinings这个注解能够告诉Java编译器关闭对类，方法以及成员变量的警告有时候编译会出现一些警告，对于这些警告有的隐藏着bug，有的则是无法避免的。对于某些不想看到的警告信息，可以通过@SuppressWarinings来屏蔽那些警告信息 Java元注解元注解就是注解其他注解的注解Java5.0定义了4个标准的metea-annotaion类型，他们被涌来提供对其他annotaion类型做说明，Java5.0定义的元注解有四种 @Target @Retention @Documented @Inherited @Target元注解@Target 主要作用是用于描述注解的使用范围，即被描述的注解可以用在什么地方 CONSTRUCTOR 主要用于描述构造器 FIELD 用来描述域 LOCAL_VARIABLE 用来描述局部变量 METHOD 用来描述方法 PACKAGE 用来描述包 PARAMETER 用来描述参数 TYPE 用于描述类，接口，枚举，声明等 @Retention元注解@REtention主要表示需要在什么级别保存该注释信息，用于描述注解的生命周期注解的生命周期由Retention的取值决定的@Retention取值： SOURCE 在源文件有效 CLASS 在CLASS中有效 RUNTIME 在运行时有效 @Documented元注解@Documented用于描述其他类型的 注解 应该被作为被标注的程序成员的公共API，因此可以被例如Javadoc此类工具文档化这是个标记注解，没有任何成员 @Inherited元注解@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果使用了@Inherited修饰的 注解 类型被用于一个class，则这个 注解 将被用于这个 class 的子类 Java自定义注解 我们可以使用@Interface来定义自定义注解 在使用@Interface来定义自定义注解的时候，自动继承了Java.lang.annotation.**（我不知道是哪个），由编译程序自动完成其他的细节 那么，在定义注解的时候，不能继承其他的注解或者接口 @interface来声明一个注解，其中每个方法实际上是声明了一个配置参数，方法的名称就是参数的名称，返回值类型就是参数的类型，即返回值类型只能是基本类型 自定义注解主要一下两步： 通过 @interface关键字声明注解名称，注解成员属性等 使用Java内置的四个元注解对自定义标注的功能和范围进行约束 自定义注解的格式123public @interface 注解名 &#123; 定义体&#125; 注解参数支持的数据类型 所有的基本数据类型 String类型 Class类型 enum类型 Annotation类型 只能用public，default这两个访问权来进行修饰 以上所有类型的数组 自定义注解及使用12345678910111213定义：@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitName&#123; String value() default &quot;&quot;;&#125;使用public class Apple&#123; @FruitName(&quot;Apple&quot;) private String appleName;&#125; Java注解元素默认值注解元素的默认值：注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可以为null，因此使用空字符串或0是一种比较常用的做法 ### 例子 1234567891011@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider&#123; //供应商编号 public int id() default -1; //供应商名称 public String name() default &quot;&quot;; //供应商地址 public String address() default &quot;&quot;;&#125;]]></content>
  </entry>
</search>
