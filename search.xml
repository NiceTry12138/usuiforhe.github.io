<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java的文件和时间操作]]></title>
    <url>%2F2018%2F09%2F25%2Fjava%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[File 类构造函数有：传入相对路径（一个参数） 传入绝对路径（一个参数） File类指定为当前文件的父级，当前文件的名称（两个参数） 文件删除读写改名File file = new File(&quot;hello.txt&quot;);//对于工程而言用相对路径，创建在根目录下。也可以用绝对路径指定文件夹 //File file = new File(&quot;bin/hello.txt&quot;);工程文件夹下的bin文件夹的hello.txt文件 //File file = new File(&quot;../hello.txt&quot;);工程文件夹的上一级文件中新建hello.txt文件 if(file.exists()){ System.out.printlen(file.isFile());//判断文件是文件 System.out.println(file.isDirectory());//判断文件是文件夹 File nameto = new File(&quot;new name .txt&quot;); file.renameTo(nameto);//将file的名字改为nameti的名字 File nameto1 = new File(&quot;src/new name.txt&quot;); file.renameTo(nameto1);//将文件移动到src目录下 file.delete();//删除文件 }else{ System.out.println(&quot;文件不存在&quot;); try{ file.createNewFile(); System }catch(IOException e){//抛出异常 e.printStackTrace(); System.out.println(&quot;文件无法创建&quot;); } } 测试样例，用于文件的读取新建一个test.txt文件，内容随意。 File file = new File(&quot;text.txt&quot;); if(file.exitst()){ try{ FileInputStream fis = new FileInputStream(file);//属于字节流 InputStreamReader isr = new InputStreamReader(fis. &quot;UTF-8&quot;);//属于字符流，在字节转换为字符的时候，需要指定编码，否则可能会出现乱码。 BufferedReader br = new BufferedReader(isr);//带有缓冲区的reader String line;//用于存放临时数据 while ((line = br.readLine()) != null){ System.out.println(line);//输出读取的一行 } 关闭输入流，先打开的后关闭，后打开的先关闭。 br.close(); isr.close(); fis.close(); }catch (FileNotFoundException e){ 该异常对应于 FileInputStream }catch (UnsupportedEncodingException e){ 该异常对应于 InputStreamReader }catch (IOException e){ 该异常对应于 ***.close() } } 测试样例，用于写入文件File newfile = new File(&quot;newtest.txt&quot;); try{ FileOutPutStream fos = new FileOutputStream(newfile); OutPutStreamWriter osw = new OutPutStream(fos, &quot;UTF-8&quot;); BufferedWriter bw = new BufferedWriter(osw); bw.write(&quot;你要写入的内容&quot;); 。。。。。。。 bw.close(); osw.close(); fos.close(); //同样，先打开的后关闭，后打开的先关闭。 } 文件夹操作File类可以表示文件或者文件夹，但是两者之间的是有区别的 File folder = new File(&quot;my new folder&quot;); // folder.createNewFile() 使用该方法创建的是一个文件，只是文件没有后缀罢了 folder.mkdir();//创建一个文件夹，返回值是一个bool类型，true为创建成功，false为失败 //如果 已经存在 名为 “my new folder”的文件夹，则创建失败。也就是说不能出现同名的文件或者文件夹 如果使用mkdir()，那么创建的文件夹必须是物理上存在的文件夹，也就是说，如果创建“one/two/test”这样的文件夹，但是 不存在one文件夹，那么是不会自动补全路径的。这时候我们就需要用 mkdirs()，也就是 file.mkdirs()这个语句。 //文件夹给名字的方法跟文件改名字的方法类似 File folder = new File(&quot;my new folder&quot;); File newfolder = new File(&quot;new folder&quot;); folder.renameTo(newfolder);//返回的是一个bool类型的值，可以通过if判断是否修改成功 //用这种方式修改文件夹的名字 forlder.delete();//删除文件夹，但是只能删除空文件夹 在windows中，千万注意移动文件夹不要跨盘移动，否则失败。因为Windows的文件系统是森林格式，而Linux和Mac系统是数状的 一些判断获取语句File file = new File(&quot;test.txt&quot;); //判断文件是否存在 file.exists(); //读取文件名称 file.getName(); //读取文件相对路径 file.getPath(); //读取文件的绝对路径 file.getAbsolutePath(); //读取文件父级路径 file.getParent(); //读取文件大小（字节） file.length(); //判断文件是否被隐藏（Linux和unix中，文件以 &quot; . &quot;开头代表隐藏） file.isHidden(); //判断文件是否可读 file.canRead(); //判断文件是否可写 file.canWrite(); //判断文件是否为文件夹 file.isDirectory(); //当程序退出时将文件删除 file.deleteOnExit(); 设置文件属性：File file = new File(&quot;test.file&quot;); //设置为可写 file.setWritable(true);//传入 true 则设置文件可写，否则设置为不可写 //设置为可读 file.setReadable(true);//与上述相同。 //设置为只读 file.setReadOnly(); 遍历文件夹public static void printfFiles(File dir){ { if( dir.isDirectory() ){ File next[] = dir.listFiles(); for( int i = 0; i&lt;next.length; i++){ if( next[i].ifFile() ){//输出文件的名字 System.out.println(next[i].name); }else{//递归的输出文件的名字 printfFiles(next[i]); } } } } 时间操作Date表示时间，日期。但是更新jdk之后就不推荐使用了。官方解释是 使用Date类不利于国际化。所以jdk1.1版本后推荐使用Calendar类。使用DateFormat类进行时间日期的格式化。Long类型表示时间类型。String类型表示时间日期类的显示。 Date.getTime();//获取Date对象的时间 Date.setTime(long time);//设置Date的时间 Calendar rightnow = Calendar.getInstance();//获取当前时间 long now = System.currentTimeMillis();//获得系统的当前时间，但是这个时间只有机器能读懂 Date d1 = new Date(now);// 获取人能够读懂的时间 Calendar c1 = Calendar .getInstance(); System.out.print(c1.getTime().toString());//获得人能够读懂的时间 String -&gt; 时间 &amp;&amp; 时间 -&gt; String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//指定日期的格式 sdf.format(date);//将Date类型转换为指定格式的String类型，返回的是一个String类型 sdf.parse(&quot;2015-06-01&quot;);//将String转换为Date类型，返回的是一个Date类型 //SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); 时间格式为 年月日 时分秒]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F09%2F25%2FGit%2F</url>
    <content type="text"><![CDATA[Git的起源linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bitkeep说开源社区中的一个成员对bitkeep的协议进行逆向工程。因此，自己写了git。 SVN-&gt;集中式版本控制系统：只有中央服务器有版本的数据库，其他电脑没有，所有版本控制都要通过中央服务器进行交互。（要是中央服务器当机离线，则就出大问题了）git-&gt;分布式版本控制：每一个台电脑上面都有一个版本的database。由于每台电脑都有数据库，所以大多数操作可以离线进行。支持比较多的控制模式-也可以安装一个中央服务器。 git每个版本存储的都是当前版本的所有内容，不需要与其他版本进行差异比较之后再进行文件的合成。 git可以离线完成大部分操作。 git有更优雅的分支和合并实现。 git有更强大撤销修改和修改版本历史的能力。 git速度更快，效率更高。 为什么学习git：研究GitHub越来越多的公司通过git调整 git如何存储文件，历史记录：git通过40个16进制字符的SHA-1 Hash 来唯一标识对象 例如： e98757d0598ab6eeaf1df0d87dd00826048bd80bgit有四种对象： 1. blob：文本文件或者二进制文件或者链接文件 2. tree：目录 3. commit：历史提交 4. tag：指向固定的历史提交 (-&gt;）指向的意思 tag -&gt; commit -&gt; tree -&gt; 多个tree对象或者多个blob对象对工作区的这些内容进行SHA-1 Hash 之后，就可以得到唯一标识。如果两个文件内容是相同的，则他们指向同一个blob对象。而文件名这种信息会存在tree对象中。 有了git对象之后，需要git仓库去存储对象，和操作对象。git init git clone 两种方法获取仓库。cd 到.git 文件夹中 （GIT_DIR!）-&gt; git工作区间 用 ls 查看git需要的文件再退出来用init方法创建一个裸仓库。然后查看仓库中有什么。git init –bare git_bare_repo通过–bare 方法创建一个 git_bare_repo 文件夹。这个文件夹只有git工作需要的文件。git clone 克隆出一个仓库 一般来说需要远程裸仓库的地址git clone git_bare_repo/ git_clone_repo （复制之前创建的本地仓库，并创建在文件夹 git_clone_repo中） git分为三个区域： working directory（工作区，日常编辑代码的地方） staging area（暂存区，工作区与历史提交的缓存，维护的是虚拟的树形结构） history repository（历史仓库） （1）工作区 添加文件到 暂存区 提交整个暂存区的状态 历史纪录区（2）历史记录区 检出文件到 暂存区和工作区大部分时间我们都在做第一个工作对应的就是 git add（到暂存区） 和 git commit（到历史记录区） git status（查看工作区和暂存区的区别，确保提交是我们所需要的） git rm（从暂存区删掉我们不需要的东西） git mv（移动文件） gitignore（确保不想添加到暂存区和历史纪录区的文件不被添加） 先 创建 a b 两个文件 touch a touch b然后添加到暂存区 git add a b查看一下 git status提交到历史纪录 git commit -m “initial commit” （加入一个提交的历史信息）修改一下a vim a（加入一些文字信息）再看一下 git status 提示 a 修改了 但是没有提交到暂存区提交a到暂存区中 git add a再status 看一下 git status再提交 a 就行 git commit -m “modify a”删除a，会删除 工作区 ，暂存区中的a git rm a还原一下a git checkout a如何只删除暂存区的文件，不删除工作目录的文件 git rm –cached a git status 看看就会提示有一个没有跟踪的文件git mv a c （将a名字命名为c）（这个命令是一系列操作的总和） 如果直接再工作区修改文件名 mv a c （工作目录直接 修改名字） 再 git status 提示 a 被删除了 ， 有个c 的文件没有被跟踪 再 git add a c（添加a c 到文件中） 提示文件 a 被更改为 cgit add -A 添加整个工作区都暂存区git .gitignore 在顶层目录下创建一个.gitignore文件.[oa]通过通配符提示git，以 o 和 a 结尾的文件不要添加到git仓库中例如：加入了 .~, *.pyc ， 但是如果以.pyc为后缀的文件，有一个要加到仓库，这个时候就要在文件名上加 !test.pyc，告诉 test.pyc 不要被忽略。如果需要ingore文件名第一个字符就是“！”，就要加上”\”转义字符。**/res 匹配 res，所有路径下的res，任何文件夹下的res。git add .gitignoregit commit -m “add ingore”//添加到仓库中，用于整个仓库的共享 git暂存区 .git/objects 对象库当执行 git add 命令时，.git 目录下多了一个index文件，整个index文件就是暂存区，每条索引有个的四十位的十六进制的SHA-1 Hash，文件模式，权限，时间戳等。每个索引都对应对象库中的某个对象对应。除了索引之外，还维护了提前计算好的tree对象的内容。当我们提交的时候，可以直接通过提前计算好的，直接生成索引等内容。当文件名更改时，根据文件内容所计算出来的SHA-1 也不会变。暂存区索引每次更新的时候，都会重新计算index 和暂存区的内容。 git本地分支与合并git branch（创建分支) git tag（给commit做标记） git checkout（分支之间的切换） git stash（切换分支之前保存本地修改） git merge（合并分支） 例如：git branch test 新建分支 test。但是只是新建，要切换过去才能使用git checkout test 切换到test分支。test分支做的修改，不会影响到master分区的工作。也就是说分支互不影响。 tag 分 轻量级 本地引用 和 annotady 带注解的tag 通过 git log --online --decorate --graph -all 查看hash值，以及提交，查看历史示意图 git tag &quot;v0&quot; a1abda30 （a1abda30 就是上述命令查出的hash值） git tag -a &quot;INITAL_COMMIT&quot; a1abda30 标注tag，提示输出tag信息。 git tag 查看以有的设置过的tag git config --global alias.lol &quot;log --oneline --decorate --graph --all&quot; 用 git lol 代替 log --oneline --decorate --graph --all git show v0 （v0是一个tag的名字） GitHub提供个人或者企业的代码托管。可以查看其他的开源项目托管。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2018 徐州赛区网络预赛]]></title>
    <url>%2F2018%2F09%2F25%2FACM-Icpc-%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[1Time Limit: 1000ms Memory Limit: 262144KB Description Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256, which can transit a string into just 256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string s, s[i] represents the i th character in the string)we calculates the value(|(int) L – s[i]|), and write down the number(keeping leading zero. The length of each answer equals to 2 because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(s)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “11 45 14”. It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. Input First line a integer T, the number of test cases(T &lt;= 10) For each test case: First line contains a integer N and a character z, (N &lt;= 1000000) Second line contains a string with length N. Problem makes sure that all characters referred in the problem are only letters. Output A single number which gives the answer. Sample input23 zoMl6 YYJSNPI Sample output610 翻译12345678910Mur喜欢哈希算法，他有时加密另一个人的名字，然后用加密值给他打电话。例如，他打电话给Kimura KMR，并打电话给Suzuki YJSNPI。有一天，他读了一本关于SHA-256的书，它可以将字符串转换成256位。 Mur认为这很酷，他想出了一个新的算法来完成类似的工作。算法以这种方式工作：首先我们选择单个字母L作为种子，对于输入（您可以将输入视为字符串s，s [i]表示字符串中的第i个字符）我们计算值（ |（int）L - s [i] |），并记下数字（保持前导零。每个答案的长度等于2，因为字符串只包含字母和数字）。数字从左到右写入，最后将所有数字转换为单个整数（不带前导零）。例如，如果我们选择&apos;z&apos;作为种子，则字符串“oMl”变为“11 45 14”。很容易发现该算法无法将任何输入字符串转换为相同的长度。虽然在绝望中，Mur仍然想知道算法产生的答案的长度。由于穆尔的愚蠢，他甚至无法弄清楚这一点，所以你被分配了计算答案的工作。 输入 第一行是整数T，测试用例数（T &lt;= 10）对于每个测试用例：第一行包含整数N和字符z，（N &lt;= 1000000）第二行包含长度为N的字符串。确保问题中提到的所有字符都只是字母。 输出 一个数字给出了答案。 样本输入23 zoMl6 YYJSNPI 样本输出610 水题，但是特别坑。这里先讲第二个样例： 减出来的结果是 00 15 06 11 09 16这样去除前面的0，得出来的结果就是1506110916，这10位如果全部都是0呢 比如 4 zzzzz 这个时候就要输出 1 而不是 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;functional&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; int sum = 0; int len; char Seed, s; cin &gt;&gt; len &gt;&gt; Seed; bool flag = false, fir = true; for(int i=0; i&lt;len; i++)&#123; cin &gt;&gt; s; int t = Seed - s; t = abs(t); if(t != 0) flag = true; if(flag)&#123; if(fir)&#123; if(t &gt;= 1 &amp;&amp; t &lt;= 9) sum += 1; else sum += 2; fir = false; &#125; else sum += 2; &#125; &#125; if(flag == false) sum = 1; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; Description Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge a[i]. Unfortunately, the longer he learns, the fewer he gets. That means, if he reads books from l to r, he will get a[l]L+a[l+1](L-1)+…+a[r1]*2+a[r] (L is the length of [l, r] that equals to r-l+1). Now Ryuji has q questions, you should answer him: 1. If the question type is 1, you should answer how much knowledge he will get after he reads books [l, r] 2. If the question type is 2, Ryuji will change the ith book’s knowledge to a new value. Input First line contains two integers n and q (n, q &lt;= 100000). The next line contains n integers represent ai Then in next q line each line contains three integers a, b, c, if a = 1, it means question type is 1, and b, c represents [l, r]. if a = 2, it means question type is 2, and b, c means Ryuji changes the bth book’ knowledge to c. Output For each question, output one line with one integer represent the answer.Sample Input5 31 2 3 4 51 1 32 5 01 4 5 Sample Output108 翻译123456789101112 Ryuji不是一个好学生，他不想学习。 但他应该学习n本书，每本书都有自己的知识[i]。 不幸的是，他学的越久，得到的就越少。 这意味着，如果他从l到r读书，他将获得a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]（L 是[l，r]的长度，等于r-l + 1）。 现在Ryuji有q问题. 你应该回答他： 1。如果问题类型是1，你应该回答他读书后会得到多少知识[l，r] 2.如果问题类型是2，Ryuji会改变 ith书对新价值的认识。 输入 第一行包含两个整数n和q（n，q &lt;= 100000）。 下一行包含n个整数表示a [i]（a [i] &lt;= 1e9） 然后在下一个q行中每行包含三个整数a，b，c， 如果a = 1，则表示问题类型为1，b ，c代表[l，r]。 如果a = 2，则表示问题类型为2，b，c表示Ryuji将bth book的知识更改为c。 这里我维护的两个数组。一个是输入的数组x，另一个是数组z。定义数组z[i] = x[i] * (n-i+1)（i从1开始）然后定义两个数组 y 和 shu。其中 y数组用于维护x，shu数组用于维护z。这个解释一下z数组的用途，以及如何维护z数组。题目求的是a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]，如果暴力求解绝对超时。所以有个z数组。用样例来说：输入的 1 2 3 4 5那么 x 数组中就是 1 2 3 4 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z 数组中就是 5 8 9 8 5求 1~3 的和。那么如果直接加上 z[1~3] ，那么就是a[1]5 + a[2]4 + a[3]3。但是题目要求的是 a[1]3+a[2]2+a[3]1，也就是减去2倍的(a[1]+a[2]+a[3])。而这个2倍其实就是 区间 （l，r）中r距离尾部的单位值。这里是5 - 3 = 2。上面的例子很容易发现 z 数组的用途，提前预处理了题目要求的a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]。如此一来就可以用0（1）的时间求出要求的值，而不需要遍历。再来看，题目有两种状态一个是区间求和，另一个是修改值。碰到这种题目很容易想到的就是树状数组或者线段树，我这里用的是树状数组。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int sm = 400000+10;long long int x[sm];long long int n, q;long long int z[sm];// x存n个数，z ai*(n-i) i 从0 开始 long long int y[sm], shu[sm];// y 求区间和， 树状数组long long int lowbit(int x)&#123; return x&amp;(-x);&#125;long long find_sum(long long int i, long long zu[])&#123;//区间求和 long long int ret =0 ; for(; i&gt;0 ; ret += zu[i], i -= lowbit(i)); return ret;&#125;void update(long long int i, long long int val, long long zu[])&#123;//建树, 更新值 for(;i &lt;= n; zu[i] += val, i += lowbit(i));&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; q; for(int i =1 ; i&lt;=n; i++) cin &gt;&gt; x[i]; for(int i=1; i&lt;=n; i++) update(i, x[i], y);//建立y，维护x数组 for(int i=1; i&lt;=n; i++) z[i] = x[i] * (n-i+1); for(int i=1; i&lt;=n; i++) update(i, z[i], shu);//建立shu，维护z数组 for(int i=1; i&lt;=q; i++) &#123; long long int t; cin &gt;&gt; t; if(t == 1)&#123; long long int l, r, suml, sumr; cin &gt;&gt; l &gt;&gt; r; long long int s1 = find_sum(r, shu) - find_sum(l-1, shu);//获得z数组的区间和 long long int s2 = find_sum(r, y) - find_sum(l-1, y);//获取x数组的区间和 cout &lt;&lt; s1 - s2*(n-r) &lt;&lt; endl; &#125; if(t == 2)&#123; long long int new_num, where; cin &gt;&gt; where &gt;&gt; new_num;//where代表位置，new_num代表值 long long int mid = new_num - x[where]; update(where, mid, y);//更新y数组 update(where, mid*(n - where + 1), shu);//更新shu数组 x[where] = new_num;//更新x数组中的值 &#125; &#125; return 0;&#125; ！！！！着重强调，如果用我这种方法做的人，一定要用`long long ！！！！`本来觉得部分数据不大可以部分不用long long，结果不知道那块就是卡住了死交不过去，wa了四五发都是因为这个。 ACM本就是逆天而行，死在路上很正常。真的，看到别人大佬一队AK了，我才做了两题，就感觉对不起队友，对不起老师。天赋上的差距没办法，自己还是很菜，再加上最近在搭建服务器，导致算法上面没用心，最后一年了，好好搞。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cocos 2dx]]></title>
    <url>%2F2018%2F09%2F25%2Fcocos2dx%2F</url>
    <content type="text"><![CDATA[基于cocos-2dx的游戏制作——I wanna save the princess 在进行了两周的cocos学习之后，可以开始进行游戏的创作了。I wanna主要复杂的地方在于地图的设计以及逻辑实现。下面依次进行介绍。（使用c++） 一． 瓦片地图——tile map 1. 地图整体的大小。 配合电脑可以全屏显示，设置为1080X1920的大小。 2. 图块的大小。使用Tile map制作地图，因为它非常方便，可以将图片素材直接放到图块中，并且大小可以随意调节。比如：所有的地图图块设置为30X30像素，因此普通的土块和草地都是30X30的大小。但是在下面的场景中，因为水是直接在tile map中显示的，所以设置为了1920X900的大小。3. 图层的设置。 在这个界面中，可以新建多个图层，将不同属性的图块放入。 比如：土块和刺是分开的两个图层。 每一个形状的刺分别的一个图层。向上的刺。 向左的刺。 隐藏的刺与可以触发的刺也是不同的图层。地图上直接可见的，向上的刺。并非直接可见，需要触发条件的，向上的刺。 在图层的设置中，可以将同一属性的图层用一个新的图层覆盖，并且设置不可穿透的属性，这样在导入图层的时候会比较方便。在所有不可穿透的图层中，覆盖了一层红色图层，在vs中导入的同时，设置为不可穿透。（不可穿透是利用下文中掩码的作用。） 4. 人物图层。 在建立图层的时候，选择添加对象层，然后选择建立矩形，在地图上的任一个地方画出任意大小的矩形，代表人物。（相应操作在图上用红色方框表示。） 5. 特殊图层。 因为I wanna游戏的特殊，经常有不同的隐藏刺。这个部分首先需要在不同的图层中实现，然后需要一个对应的触发图层。 观察红色方框中图层的顺序，现在的位置是游戏地图中正常图层的位置，即土块将隐藏刺遮住了。 调整顺序后可以看到隐藏刺。 地图中红色图层的作用是，判断人物当前的位置x坐标是否与此图层中的某一个相同，相同则触发刺向上飞的事件。 这个触发图层的作用是，在地图中，人物在触碰到这个图层的同时，触发对应tag中的事件，比如让刺飞出，或是在踩到触发图层时冒出。 导入的图层为上一张图片中的yincang图层，设置tag为4。 人物的tag为1，当两个物体的tag分别为1和4的时候，触发事件。 在导入隐藏刺的同时设置冒出的移动，当人物与刺所在的图块接触，刺冒出。 触发刺飞出的事件。 二． 物理引擎 1． 建立物理世界。2． 重力的添加以及改变。 添加在创建物理世界时写入。在第三个场景的水中，需要更改重力的大小。 3． 添加不同的刚体。 普通的刚体，是矩形的。 因为刺是三角形的，所以需要建立一个数组存储三角形的三个顶点坐标，然后再附给物体，这样就是一个三角形的刚体。 4． 介绍三种掩码。 类别掩码setCategoryBitMask，接触检测掩码setContactTestBitmask，碰撞掩码setCollisionBitmask。分别将两个物体的类别掩码与接触检测掩码进行逻辑与运算，可以判断是否触发接触事件，类似的，可以判断是否穿透或者碰撞。 人物的三种掩码。 5． 重新开始。 将当前场景舍弃，重新生成一个新的场景，进行替换。 6． 键盘事件。 人物可以进行向左前进，向右前进，跳跃这三种动作，在此函数中，按下不同的键实现不同的事件。 7． 标签的添加。 在导入图层的时候就分别设置不同的tag，以便于在函数中进行相应的判断。 人物与刺碰撞，触发游戏结束的事件，在界面中添加游戏结束的图片，并且取消键盘事件，但可以按R键重新开始。（所有的刺tag都为3） 在最后切换场景时，有一个被隐藏了的触发图层，在人物接触到的同时进行tag的比较，从而可以切换场景。 8． 计时器函数 进行场景中物理引擎的手动更新。 9． 碰撞检测。 利用三种掩码进行判断。人物与土块。（人物的掩码在上方，三个都是7）（这个图层就是上方介绍过的覆盖图层）进行判断后为不可穿透。 人物与水。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
