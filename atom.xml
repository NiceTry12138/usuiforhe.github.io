<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lc_love_myh</title>
  
  <subtitle>&lt;b style=&quot;background-color:white;&quot; &gt;往后余生 心底温柔是你，目光所至也是你。&lt;/b&gt;</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-30T13:11:37.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lc_love_myh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始的JavaWeb</title>
    <link href="http://yoursite.com/2018/09/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb/"/>
    <id>http://yoursite.com/2018/09/29/从0开始的JavaWeb/</id>
    <published>2018-09-29T12:37:38.000Z</published>
    <updated>2018-09-30T13:11:37.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><h3 id="什么是Html？"><a href="#什么是Html？" class="headerlink" title="什么是Html？"></a>什么是Html？</h3><pre><code>HyperText Markup Language：超文本标记语言** 超文本：超出文本的范畴，使用html可以轻松实现** 标记：html所有的操作都是通过标记实现的。标记，就是标签  ** 网页语言：超文本标记语言</code></pre><h3 id="第一个html程序："><a href="#第一个html程序：" class="headerlink" title="第一个html程序："></a>第一个html程序：</h3><pre><code>例如：创建Java文件 后缀名为.java**先编译，后运行（jvm）同理：html文件后缀是.html**直接通过浏览器就可以运行</code></pre><h3 id="html规范："><a href="#html规范：" class="headerlink" title="html规范："></a>html规范：</h3><pre><code>1. 一个html文件开始标签和结束的标签&lt;html&gt;&lt;/html&gt;2. html包含两个部分内容：    &lt;head&gt;&lt;/head&gt;     &lt;body&gt;&lt;/body&gt; 3. html的标签有开始标签，也要有结束标签 4. html的代码不区分大小写&lt;font&gt; == &lt;FONT&gt; 5. 部分标签没有结束标签：    例如：&lt;br /&gt;//内部加个&quot;/&quot;，标签内结束</code></pre><h3 id="html的操作思想："><a href="#html的操作思想：" class="headerlink" title="*html的操作思想："></a>*html的操作思想：</h3><pre><code>网页中有很多的数据，不同的数据可能需要不同的显示效果，这个时候需要使用标签把要操作的数据封装起来，通过修改标签的属性值实现标签内数据样式的变化。一个标签就像等于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内的数据样式的变化。</code></pre><h3 id="html中常用的标签"><a href="#html中常用的标签" class="headerlink" title="html中常用的标签"></a>html中常用的标签</h3><h4 id="文字标签和注释标签"><a href="#文字标签和注释标签" class="headerlink" title="文字标签和注释标签"></a>文字标签和注释标签</h4><h5 id="文字标签：修改文字的样式"><a href="#文字标签：修改文字的样式" class="headerlink" title="*文字标签：修改文字的样式"></a>*文字标签：修改文字的样式</h5><pre><code>例如：&lt;font&gt; &lt;/font&gt;属性：color : 文字颜色(颜色的英文单词，或者十六进制rgb)     size : 文字大小（1~7）</code></pre><h5 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h5><pre><code>Java的注释有三种：&quot;//&quot; , &quot;/* */&quot; &quot;/*****/&quot;html的注释: &lt;!--  注释内容 --&gt;(源文件可以查看的注释)</code></pre><h4 id="标题标签，水平线标签和特殊字符"><a href="#标题标签，水平线标签和特殊字符" class="headerlink" title="标题标签，水平线标签和特殊字符"></a>标题标签，水平线标签和特殊字符</h4><h5 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h5><pre><code>&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt; ~~~~  &lt;h6&gt;&lt;/h6&gt;文字大小 从h1 到 h6 以此变小，并且每个标签都会自动换行</code></pre><h5 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h5><pre><code>&lt;hr /&gt; 标签内结束属性：    **size：水平线的粗细    **color：水平线的颜色</code></pre><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><pre><code>想在网页中显示 &quot;&lt;html&gt;是一个特殊标签&quot;如果直接写 &quot;&lt;html&gt;是一个特殊标签&quot;，则只会显示 &quot;是一个特殊标签&quot;需要转义&quot;&lt;html&gt;&quot;：    &amp;lt;       ---&gt;     &quot;&lt;&quot;   小于符号    &amp;gt;      ---&gt;     &quot;&gt;&quot;   大于符号    &amp;amp;      ---&gt;     &quot;&amp;&quot;   and符号 &amp;    &amp;apos;    ---&gt;     &quot;&apos;&quot;   英文单引号    &amp;quot;    ---&gt;     &quot;&quot;&quot;   英文双引号    &amp;nbsp;  ---&gt;     &quot; &quot;   空格转义</code></pre><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><pre><code>如果想在网页显示 列表的效果。</code></pre><h5 id="lt-dl-gt-lt-dl-gt-：表示列表的范围"><a href="#lt-dl-gt-lt-dl-gt-：表示列表的范围" class="headerlink" title="&lt;dl&gt;&lt;/dl&gt;：表示列表的范围"></a>&lt;dl&gt;&lt;/dl&gt;：表示列表的范围</h5><pre><code>    在&lt;dl&gt;里面  &lt;dt&gt;&lt;/dt&gt;：上层内容    在&lt;dl&gt;里面  &lt;dd&gt;&lt;/dd&gt;：下层内容例如：    &lt;dl&gt;        &lt;dt&gt;学习内容&lt;/dt&gt;            &lt;dd&gt;java&lt;/dd&gt;            &lt;dd&gt;C++&lt;/dd&gt;            &lt;dd&gt;Python&lt;/dd&gt;        &lt;dt&gt;学习进度&lt;/dt&gt;            &lt;dd&gt;没学&lt;/dd&gt;            &lt;dd&gt;没学&lt;/dd&gt;            &lt;dd&gt;没学&lt;/dd&gt;    &lt;/dl&gt;</code></pre><dl><br><dt>学习内容</dt><br><dd>java</dd><br><dd>C++</dd><br><dd>Python</dd><br><dt>学习进度</dt><br><dd>没学</dd><br><dd>没学</dd><br><dd>没学</dd><br></dl><h5 id="lt-ol-gt-lt-ol-gt-：有序列表的范围"><a href="#lt-ol-gt-lt-ol-gt-：有序列表的范围" class="headerlink" title="&lt;ol&gt;&lt;ol&gt;：有序列表的范围"></a>&lt;ol&gt;&lt;ol&gt;：有序列表的范围</h5><pre><code>    在&lt;ol&gt;&lt;/ol&gt;标签内部：&lt;li&gt;    属性：        type：这是排序方式 默认（缺省）为 1. 2. 3....            type = &quot;a&quot;            type = &quot;i&quot;例如：    &lt;ol type=&quot;a&quot;&gt;    &lt;li&gt;java&lt;/li&gt;    &lt;li&gt;C++&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;/ol&gt;</code></pre><ol type="a"><br><li>java</li><br><li>C++</li><br><li>Python</li><br></ol><h5 id="lt-ul-gt-lt-ul-gt-：无序列表的范围"><a href="#lt-ul-gt-lt-ul-gt-：无序列表的范围" class="headerlink" title="&lt;ul&gt;&lt;/ul&gt;：无序列表的范围"></a>&lt;ul&gt;&lt;/ul&gt;：无序列表的范围</h5><pre><code>属性：    type：        circle    空心圆            disc    实心圆（默认）        square    实心方块&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;java&lt;/li&gt;&lt;li&gt;C++&lt;/li&gt;&lt;li&gt;Python&lt;/li&gt;&lt;/ol&gt;</code></pre><p><ul type="circle"></ul></p><p><li>java</li></p><p><li>C++</li></p><p><li>Python</li><br></p><h4 id="lt-img-gt-图像标签（重点）"><a href="#lt-img-gt-图像标签（重点）" class="headerlink" title="&lt;img&gt;图像标签（重点）"></a>&lt;img&gt;图像标签（重点）</h4><pre><code>&lt;img src=&quot;a.jpg&quot; width=&quot;宽像素&quot; height=&quot;高像素&quot; alt=&quot;显示的文字&quot;/&gt;--src：图片的路径--width：图片的宽度--height：图片的高度--alt：图片上显示的文字，把鼠标移动到图片上面，停留片刻显示内容</code></pre><h4 id="路径的介绍"><a href="#路径的介绍" class="headerlink" title="路径的介绍"></a>路径的介绍</h4><h5 id="第一类：绝对路径"><a href="#第一类：绝对路径" class="headerlink" title="第一类：绝对路径"></a>第一类：绝对路径</h5><pre><code>D:\blog\lc_love_hehe\source\_posts\p.jpghttp://www.baidu.com/b.jag</code></pre><h5 id="第二类：相对路径"><a href="#第二类：相对路径" class="headerlink" title="第二类：相对路径"></a>第二类：相对路径</h5><pre><code>一个文件相对于另外一个文件的位置三种写法：    当图片与html在同一个文件夹内，直接使用 b.jpg    当图片在html的同级文件夹img中，使用img/b.jpg    当图片在html的上级文件夹中，../b.jpg</code></pre><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><h5 id="连接资源"><a href="#连接资源" class="headerlink" title="连接资源"></a>连接资源</h5><pre><code>&lt;a href=&quot;连接到资源的路径&quot;&gt;显示在页面上的内容&lt;/a&gt;    href：连接的资源的地址    target：设置打开的方式，默认是当前页打开。        _blank：在新窗口打开        _self：当前页打开    当超链接不需要到任何地址的时候，href=&quot;#&quot;&lt;a href=&quot;https://usuiforhe.github.io/&quot; target=&quot;_blank&quot;&gt;test&lt;/a&gt;</code></pre><h5 id="定位资源"><a href="#定位资源" class="headerlink" title="定位资源"></a>定位资源</h5><pre><code>&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;//定义顶部的位置&lt;a name=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;//定位到网页中name为top的位置，记得加上#&lt;pre&gt;原样输出例如：public static void main(String[] args){    Syste.out.println(&quot;hello world&quot;);}&amp;lt;pre&amp;gt;public static void main(String[] args){    Syste.out.println(&quot;hello world&quot;);}&amp;lt;/pre&amp;gt;</code></pre><p>public static void main(String[] args){    Syste.out.println(“hello world”);}</p><p><pre><br>public static void main(String[] args){<br>    Syste.out.println(“hello world”);<br>}<br></pre><br><code>加上了 &lt;pre&gt; 标签后，原本一行的代码，变成了我们要的换行的效果</code></p><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><pre><code>可以对数据进行格式化，使数据显示更加清晰&lt;table&gt;&lt;/table&gt;:表示表格的范围在&lt;table&gt;里面： &lt;caption&gt;表格标题在&lt;table&gt;里面： &lt;tr&gt;在&lt;tr&gt;里面：&lt;td&gt;画图分析表格的写法：    首先定义一个表格的范围使用table        定义一行使用 tr        定义一个单元格使用 td    操作技巧：        首先数有多少行，数每行里有多少个单元格    例如：        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;学科&lt;/td&gt;                &lt;td&gt;学习进度&lt;/td&gt;                &lt;td&gt;梦想&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;python&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;                &lt;td rowspan=&quot;3&quot;&gt;想学&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;C++&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;Java&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    属性：    &lt;table&gt;中：        border：表格线的粗细        bordercolor：表格线的颜色        cellspacing：表格之间的距离        align：left center right  框中文字的位置    &lt;td&gt;中：        colspan：0~无穷大，跨列        rowspan：0~无穷大，跨行</code></pre><table><br>    <tr><br>        <td>学科</td><br>        <td>学习进度</td><br>        <td>梦想</td><br>    </tr><br>    <tr><br>        <td>python</td><br>        <td>没学</td><br>        <td rowspan="3">想学</td><br>    </tr><br>    <tr><br>        <td>C++</td><br>        <td>没学</td><br>    </tr><br>    <tr><br>        <td>Java</td><br>        <td>没学</td><br>    </tr><br></table><h4 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h4><p><code>可以提交数据到服务器的标签，这个过程可以使用表单标签实现</code>  </p><blockquote><p>&lt;form&gt;&lt;/form&gt;：定义表单范围<br>输入项：可以输入内容或者选择内容的部分<br>    大部分的输入项 使用 &lt;input type = “输入类型” /&gt;  </p></blockquote><pre><code>Input  类型：type = &quot;email/url/number/range/date picker/search/color/tel&quot;      &lt;input type=&quot;password&quot;&gt;密码框&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男  单选框&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;苹果&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;香蕉&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;栗子  多选框&lt;input type = &quot;url&quot; name = &quot;url&quot;&gt;    手机端弹出字母键盘，电脑端无差别  &lt;input type = &quot;email&quot; name = &quot;email&quot;&gt;    手机端弹出字母键盘，电脑端无差别  &lt;input type = &quot;tel&quot; name = &quot;tel&quot;&gt;    手机端弹出数字键盘，电脑端无差别  &lt;input type = &quot;number&quot; name = &quot;number&quot;&gt;    手机端弹出数字键盘，电脑端右边多处两个按钮控制加减，只能输入参与运算的内容“+ - . 1 2 3 4 5 6 7 9 e”  data picker input类型:      date —— 选取 日， 月， 年      month —— 选取月，年      week ——    选取 周和年      time ——     选取时间（小时和分钟）          datetime    —— 选取时间，日，月，年（utc时间）      datetime-local —— 选取时间，日，月， 年（本地时间）  使用方法一样 &lt;input type = &quot;date&quot; name = &quot;date&quot; &gt; 手机端显示的是 日期键盘  &lt;input type = &quot;range&quot; name = &quot;range&quot; min = &quot;最小值&quot; max = &quot;最大值&quot;&gt;  &lt;input type = &quot;image&quot; src=&quot;a.jpg&quot;/&gt;设置按钮为图片，作用是提交&lt;input type = &quot;search&quot; name = &quot;search&quot; &gt;  &lt;input type = &quot;color&quot; name = &quot;color&quot;&gt;弹出颜色选择  &lt;input type = &quot;hidden&quot;/&gt;     隐藏项，不会显示在页面中的&lt;input type = &quot;button&quot; /&gt;    普通按钮&lt;input type = &quot;submit&quot; /&gt;     提交按钮&lt;input type = &quot;reset&quot; value=&quot;你想显示的文字&quot;/&gt;    重置按钮&lt;selsect&gt;    &lt;option&gt;1&lt;/option&gt;    &lt;option&gt;2&lt;/option&gt;    &lt;option&gt;3&lt;/option&gt;&lt;/select&gt;下拉选项&lt;textarea cols=&quot;列数&quot; rows=&quot;行数&quot;&gt;&lt;/textarea&gt; 文本域</code></pre><p><code>最好每个输入项都有个name属性，方便后台提取数据。后台通过name属性获取对应输入的值</code></p><pre><code>表单属性：  autocomplete/autofocus/multiple/placeholder/required/action/method  action    是提交数据到的那个页面method    常用的就两种“get”“post”，默认getenctype    关于文件上传的属性&lt;form autocomplete = &quot;on&quot;（#自动完成功能，存下之前提交过的字段#）action = &quot;****&quot;    ausofocous = &quot;&quot;&gt;      &lt;input type = &quot;text&quot; name = &quot;text&quot;  autofocus = &quot;autofocus&quot;&gt;(#不写  autocomplete 默认开启存储  autofocus 光标自动确定该input#)      &lt;input type = &quot;email&quot; name = &quot;email&quot; autocomplete = &quot;off&quot;&gt;（#关闭自动存储#）      &lt;input type = &quot;file&quot; multiple = &quot;muliple&quot; / &gt;(#muliple 是乘法，代表多个的意思，同时上传多个文件#)      ps. multiple 在类型为type的时候，也可以用，多个邮箱之间用 分号 隔开。 如果没有multiple ，email类型也可以传多个email，但是用了multiple 的 input，会传出一个数组到后台，而没有用的则会传出一整个字符串，难以操作。      &lt;input type = &quot;text&quot; placeholder = &quot;用户名&quot; /&gt;(#提示输入用户名，开始输入时提示消失#)      ps. placeholder 适用于： text, search, url, tel, email, password。      &lt;input type = &quot;text&quot; required = &quot;required&quot; /&gt; （#required 规定必须在提交之前填写输入域（不能为空）#）      &lt;input type = &quot;submit&quot;&gt;  &lt;/form&gt;`</code></pre><h4 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h4><pre><code>&lt;b&gt;        加粗&lt;s&gt;        删除线&lt;u&gt;        下划线&lt;i&gt;        斜体&lt;pre&gt;    原样输出&lt;sub&gt;    下标&lt;sup&gt;    上标&lt;div&gt;    盒子，自带换行&lt;span&gt;    盒子，不带换行</code></pre><h4 id="html的头标签"><a href="#html的头标签" class="headerlink" title="html的头标签"></a>html的头标签</h4><pre><code>html由两部分组成 head 和 body在head里面的标签就是头标签    title：显示在标签上显示的内容    base：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标（target属性）    例如：        &lt;base target=&quot;_blank&quot;&gt;        //这是所有的超链接都是新窗口打开    meta：可以提供有关页面的基本信息    例如：        &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=01-hello.html&quot;&gt;        // refresh 模拟页面请求， 3 3秒后， url 跳转的目标页面    link：定义文档与外部资源的关系</code></pre><h4 id="框架标签（过时）"><a href="#框架标签（过时）" class="headerlink" title="框架标签（过时）"></a>框架标签（过时）</h4><pre><code>&lt;frameset&gt;    属性：        rows：按行进行划分        cols：按列进行划分    &lt;frameset rows=&quot;80,*&quot;&gt;划分为两行，第一行高80        &lt;frame&gt;    具体显示的页面    &lt;frame name = &quot;lower_left&quot; src=&quot;b.html&quot;&gt;使用框架标签时候，不能写在body里面，需要把body去掉。</code></pre><h2 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS-层叠样式表"></a>CSS-层叠样式表</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><pre><code>一层一层的，与优先级有关</code></pre><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><pre><code>有很多的属性和属性值，改变标签的属性值，是标签变换</code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><pre><code>CSS将网页内容和显示样式进行分离，提高了显示功能，解决了html代码对样式定义的重复，提高了后期样式代码的可维护性。</code></pre><h3 id="CSS和Html的结合方式"><a href="#CSS和Html的结合方式" class="headerlink" title="CSS和Html的结合方式"></a>CSS和Html的结合方式</h3><pre><code>1. 在每个html标签上都有一个style属性。通过style属性修改标签样式    &lt;span style=&quot;background-color:red; color=green;&quot;&gt;测试&lt;/span&gt;2. 使用html的一个标签实现 &lt;style&gt; 标签，写在head里面    &lt;style type=&quot;text/css&quot;&gt;        div{            background-color:red;            color = green        }//所有div的样式都这样    &lt;/style&gt;3. 在&lt;style&gt;标签中使用语句 @import url (css文件的路径)    &lt;style type=&quot;text/css&quot;&gt;        @import url(div.css)    &lt;/style&gt;4. 使用头标签&lt;link&gt;,引入外部css文件    &lt;link rel=&quot;srtlesheet&quot; type=&quot;text/css&quot; href=&quot;css_3.css&quot; /&gt;Ps.第三种结合方式，缺点：在某些浏览器下不支持。一般来说，是用第四种结合方式。</code></pre><h3 id="CSS的优先级"><a href="#CSS的优先级" class="headerlink" title="CSS的优先级"></a>CSS的优先级</h3><pre><code>从上到下，从外到内，CSS的优先级从低到高。后加载的优先级高。</code></pre><h3 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h3><pre><code>1. 选择器名称{    属性名：属性值；    属性名：属性值；}2. 属性与属性之间用分号隔开3. 属性与属性值之间用冒号链接4. 如果一个属性有多个属性值的话，那么多个值用空格隔开</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><pre><code>&lt;标签 id=&quot;test&quot;&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 #test{        background-color: red;    }来选择 id 为test的标签。也就是说 id 前面加上 &quot; # &quot;</code></pre><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><pre><code>&lt;标签 class=&quot;test&quot;&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 .test{        background-color:red;    }来选择 class 为test的标签。也就是说 class 前面加上 &quot; . &quot;</code></pre><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><pre><code>&lt;标签&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 标签{        background-color:red;    }来选择 标签</code></pre><p><code>class 选择器的优先级 &gt; 标签选择器的优先级</code><br><code>id选择器的优先级 &gt; class选择器的优先级</code><br><code>标签内部的style属性的优先级 &gt; id 选择器的优先级</code></p><h4 id="关联选择器"><a href="#关联选择器" class="headerlink" title="关联选择器"></a>关联选择器</h4><pre><code>&lt;div&gt;&lt;p&gt;test&lt;/p&gt;&lt;/div&gt;要选中 p 标签 那么CSS这样写    div p{        background-color:red;    }两个中间一个空格，这样就选中 div 子标签中的 p 标签</code></pre><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><pre><code>&lt;div&gt;test111&lt;/div&gt;&lt;p&gt;test222&lt;/p&gt;想把div和p设置成一样的样式，那么CSS中这么写    div,p{        background-color:red;    }中间用逗号连接，表示两个都选中</code></pre><h4 id="伪类元素选择器"><a href="#伪类元素选择器" class="headerlink" title="伪类元素选择器"></a>伪类元素选择器</h4><pre><code>CSS里面提供了一些定义好的样式，可以拿过来使用原始状态        鼠标放上去的状态        点击             点击之后：link        ：hover                ：active        visited例如CSS文件中：    a:link{        background-color: red;    }    a:hover{        background-color: blue;    }    a:active{        background-color: black;    }第一个字符        第一行            在文字标签前面加上:first-letter    :first-line        ：before例如CSS文件中：    p:before    {        content:&quot;台词：&quot;;    }那么 所有的 p 标签前面 都会加上 &quot;台词&quot; 这两个字</code></pre><table><br><tr> <td>选择符类型</td> <td>表达式</td> <td>描述</td></tr><br><tr><td>子串匹配的属性选择符</td><td> E[att^=”val”] </td><td>匹配具有att属性、且值以val开头的E元素 </td> </tr><br><tr> <td>子串匹配的属性选择符</td> <td>E[att$=”val”]</td> <td>匹配具有att属性、且值以val结尾的E元素 </td> </tr><br><tr> <td>子串匹配的属性选择符</td> <td>E[att*=”val”]</td> <td>匹配具有att属性、且值中含有val的E元素 </td> </tr><br><tr> <td>结构性伪类</td> <td> E:root</td> <td> 匹配文档的根元素。在HTML中，根元素永远是HTML </td> </tr><br><tr> <td>结构性伪类</td> <td> E:nth-child(n)</td> <td> 匹配父元素中的第n个子元素E </td> </tr><br><tr> <td>结构性伪类</td> <td> E:nth-last-child(n)</td> <td> 匹配父元素中的倒数第n个结构子元素E</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:nth-of-type(n)</td> <td> 匹配同类型中的第n个同级兄弟元素E<br></td></tr><tr> <td>结构性伪类</td> <td> E:nth-last-of-type(n)</td> <td> 匹配同类型中的倒数第n个同级兄弟元素E </td> </tr><br><tr> <td>结构性伪类</td> <td> E:last-child</td> <td> 匹配父元素中最后一个E元素</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:first-of-type </td> <td>匹配同级兄弟元素中的第一个E元素 </td> </tr><br><tr> <td>结构性伪类 </td> <td>E:only-child </td> <td>匹配属于父元素中唯一子元素的E</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:only-of-type </td> <td>匹配属于同类型中唯一兄弟元素的E</td> </tr><br><tr> <td>结构性伪类</td> <td> E:empty</td> <td> 匹配没有任何子元素（包括text节点）的元素E</td> </tr><br><tr> <td>目标伪类</td> <td> :target</td> <td> 匹配相关URL指向的E元素</td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E:enabled</td> <td> 匹配所有用户界面（form表单）中处于可用状态的E元素 </td> </tr><br><tr> <td>UI元素状态伪类 </td> <td>E:disabled </td> <td>匹配所有用户界面（form表单）中处于不可用状态的E元素 </td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E:checked</td> <td> 匹配所有用户界面（form表单）中处于选中状态的元素E </td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E::selection</td> <td> 匹配E元素中被用户选中或处于高亮状态的部分</td> </tr><br><tr> <td>否定伪类</td> <td> E:not(s)</td> <td> 匹配所有不匹配简单选择符s的元素E</td> </tr><br><tr><td>通用兄弟元素选择器</td> <td> E ~ F </td> <td>匹配E元素之后的F元素 </td> </tr><br></table><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><pre><code>div+CSS，给div一个样式，设置它的位置以及外观。又因为这div就像一个盒子一样，所以也叫做盒子模型。</code></pre><p><code>在进行布局前需要把数据封装到一块一块的区域内</code></p><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><pre><code>属性：    border：统一设置        none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset        无边框| 隐藏边框|点线或实线|虚线或实线| 实线 |双线边框  | 3D凹槽 | 3D凸槽 |3D凹边 |3D凸边    border-top：上边框    border-bottom：下边框    border-left：左边框    border-right：右边框    border: 粗细（px） 样式（上述）颜色；</code></pre><h4 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h4><pre><code>padding：length（px）//统一设置padding-bottom    :    文字内容距离下边框的距离padding-left    :    文字内容距离左边框的距离padding-right    :    文字内容距离有边框的距离padding-top        :    文字内容距离上边框的距离</code></pre><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><pre><code>margin：外边距，边框距离外边框的距离margin：length（px）//统一设置margin-top        :    边框距离上外边框的距离margin-bottom    :    边框距离下外边框的距离margin-right    :    边框距离右外边框的距离margin-left        :    边框距离左外边框的距离</code></pre><h3 id="CSS的布局的漂浮"><a href="#CSS的布局的漂浮" class="headerlink" title="CSS的布局的漂浮"></a>CSS的布局的漂浮</h3><pre><code>float：none | left | rightnone    ：默认值。对象不漂浮left    ：文本流向对象的右边right    ：文本流向对象的左边</code></pre><h3 id="CSS的布局的定位"><a href="#CSS的布局的定位" class="headerlink" title="CSS的布局的定位"></a>CSS的布局的定位</h3><pre><code>Position    属性：    static:默认值。无特殊定位，对象遵循HTML定位规则    absolute：将对象从文档流中脱出，使用left,right,top,bottom等属性相对于其进行绝对定位    ——————即，这个盒子独立出来，不由html自动按文档流分配位置，后面的盒子自动补齐该和自动空位    relative：对象不可层叠，但将依据left,right,top,bottom等属性在正常文档流中偏移位置。    ——————即，这个盒子没有从文档流中拖出，位置还在，但是可以移动而不影响其他的盒子的原有位置</code></pre><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><pre><code>JavaScript是基于对象和时间驱动的脚本语言，主要应用在客户端</code></pre><h4 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h4><pre><code>提供好了很多对象，可以直接拿过来使用</code></pre><h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><pre><code>html做网站是静态效果，加入了js后就可以完成动态的效果</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>1. 交互性（信息的动态交互）2. 安全性（不可以直接访问本地磁盘）3. 跨平台性（只要是可以解析js的浏览器都可以执行，与平台无关）</code></pre><h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><pre><code>三部分：1. ECMAScript    ECMA：欧洲计算机协会    由ECMA组织指定的js语法，语句......2. BOM    broswer object model：浏览器对象模型3. DOM    document object model：文档对象模型</code></pre><h3 id="JavaScript与HTML的结合"><a href="#JavaScript与HTML的结合" class="headerlink" title="JavaScript与HTML的结合"></a>JavaScript与HTML的结合</h3><pre><code>1. 使用一个标签    &lt;script type=&quot;text/javascript&quot;&gt;JavaScript代码&lt;/script&gt;2. 使用script引入外部标签文件    创建一个js文件，写js代码        &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt; 这样写的话 &lt;script&gt;&lt;/script&gt;中间的代码不会执行</code></pre><h3 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h3><h4 id="js的原始类型和声明变量"><a href="#js的原始类型和声明变量" class="headerlink" title="js的原始类型和声明变量"></a>js的原始类型和声明变量</h4><pre><code>1. string：字符串    var str=&quot;abc&quot;;2. number：数字类型    var m = 123;3. boolean：数字类型    var flag=true;4. null:对象引用为空5. undifined：定义了一个变量，但是这个变量没有赋值    var aa；用typeof（变量名）；查看当前变量的数据类型</code></pre><h4 id="js的语句"><a href="#js的语句" class="headerlink" title="js的语句"></a>js的语句</h4><pre><code>1.判断语句：     1. if语句    if(a == 5){        alert(&quot;5&quot;);    }else{        alert(&quot;不是5&quot;)        }    2. switch语句（支持所有的数据类型）    switch(变量){        case 5:操作;break;        case 6:操作;break;        case 7:操作;breal;        default:操作;break;    }2. 循环语句    1. for循环        for(var i=0; i&lt;10; i++){            alert(i);        }    2. whilt循环        var i=4;        whilt(i--){            alert(i);        }</code></pre><h4 id="js的运算符"><a href="#js的运算符" class="headerlink" title="js的运算符"></a>js的运算符</h4><pre><code>1. -2. +3. *4. /5. &amp;6. ++7. --8. +=9. -=</code></pre><h5 id="字符串加减"><a href="#字符串加减" class="headerlink" title="字符串加减"></a>字符串加减</h5><pre><code>j=123alert(j/1000*1000)java中输出的 0； 但是JavaScript中输出的 123；js中不区分整形浮型点var str = &quot;457&quot;alert(str+1);Java和JavaScript中输出的都是4571; 加法做的是字符串相见alert(str-1);JavaScript输出的是 456，即进行了减法运算alert(&quot;abc&quot;-1);JavaScript输出NAN，提示错误，不是一个数字。 </code></pre><h5 id="Boolean的操作"><a href="#Boolean的操作" class="headerlink" title="Boolean的操作"></a>Boolean的操作</h5><pre><code>var flag=true;alert(flag+1);JavaScript中输出的是 2。也就是说 true = 1；反之，flase = 0。</code></pre><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h5><pre><code>JavaScript中， == 用于判断两个参数的值是否相等 === 用于判断两个参数 类型和值是否都相等    例如：        var x = &quot;5&quot;, y = 5;        x == y 则为 true        x === y 则为false</code></pre><h4 id="引入知识"><a href="#引入知识" class="headerlink" title="引入知识"></a>引入知识</h4><pre><code>直接向页面输出的语句（可以直接把内容显示在页面上）document.write(&quot;aaa&quot;);document.write(&quot;&lt;hr /&gt;&quot;);可以直接写入数据，也可以写入html代码，当然也可以混合都写</code></pre><h3 id="js的数组"><a href="#js的数组" class="headerlink" title="js的数组"></a>js的数组</h3><pre><code>js数组中，写什么都可以,可以是数据的混合，可以同时包括int，string或者其他类型</code></pre><h4 id="定义数组的三种方式"><a href="#定义数组的三种方式" class="headerlink" title="定义数组的三种方式"></a>定义数组的三种方式</h4><pre><code>1. var arr=[1,2,&quot;34&quot;];2. 使用内置的对象 Array对象    var arr = new Array(5);//定义一个数组，数组长度是53. 使用内置对象 Array对象    var arr2 = new Array(3,4,5);//定义一个数组，数组里面的元素为 3，4，5</code></pre><h4 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h4><pre><code>length：表示数组的长度    var len = arr.length;数组的长度是可以变的数组可以存放不同的数据类型的数据</code></pre><h3 id="js的函数"><a href="#js的函数" class="headerlink" title="js的函数"></a>js的函数</h3><h4 id="在js里面定义函数有三种定义方式"><a href="#在js里面定义函数有三种定义方式" class="headerlink" title="在js里面定义函数有三种定义方式"></a>在js里面定义函数有三种定义方式</h4><pre><code>1. 关键字：function    funciton 方法名（参数列表）{        方法体；        返回值；（返回值可有可无）    }2. 匿名函数：function    var func = funtion （参数列表）{        方法体和返回值；    }    调用直接  func();3. 内部对象：Function（用的少，了解就行）`动态函数`    var func = new Function(&quot;参数列表&quot;，“方法体和返回值”);    var test = new Function(&quot;x,y&quot;,&quot;var sum;sum=x+y;return sum;&quot;);</code></pre><h3 id="js的全局变量和局部变量"><a href="#js的全局变量和局部变量" class="headerlink" title="js的全局变量和局部变量"></a>js的全局变量和局部变量</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><pre><code>在script标签内部顶一个变量，这个变量在页面中js部分都可以使用</code></pre><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><pre><code>在方法内部定义一个变量，只能在方法内部使用</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>全局变量：    &lt;script&gt;        var a = 10;        function func(){            alert(a);        }        func();    &lt;/script&gt;    &lt;script&gt;        alert(a);    &lt;/script&gt;    可以跨script标签使用的变量。称之为全局变量局部变量：    &lt;script&gt;        function func(){            var a = 10;            alert(a);        }        func();        alert(a);//报错    &lt;/script&gt;    局部变量只能在方法内部使用</code></pre><h3 id="script应该放的位置"><a href="#script应该放的位置" class="headerlink" title="script应该放的位置"></a>script应该放的位置</h3><h4 id="位置差别"><a href="#位置差别" class="headerlink" title="位置差别"></a>位置差别</h4><pre><code>&lt;script&gt;原则上放任意位置都可以执行，但是还是要注意位置html文档是从上到下解析的，如果用js去获得html的标签，一定要在获取标签的后面，不然会得到一个 null 的变量，导致错误。</code></pre><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><pre><code>把script标签放到&lt;/body&gt;后面，&lt;/html&gt;前面</code></pre><h3 id="js的重载"><a href="#js的重载" class="headerlink" title="js的重载"></a>js的重载</h3><pre><code>function add1(a, b){ return a+b }function add1(a, b, c){ return a+b+c }function add1(a, b, c, d){ return a+b+c+d }add1(2,3)    add(2,2,3)    add(2,2,3,3)第一个得出结果NAN，第二个得出结果NAN，第三个得出正确结果</code></pre><h4 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h4><h2 id="JavaScript基础DOM"><a href="#JavaScript基础DOM" class="headerlink" title="JavaScript基础DOM"></a>JavaScript基础DOM</h2><h3 id="js的String对象"><a href="#js的String对象" class="headerlink" title="js的String对象"></a>js的String对象</h3><h4 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><pre><code>只有一个需要注意：length  字符串的长度</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="与html相关的方法"><a href="#与html相关的方法" class="headerlink" title="与html相关的方法"></a>与html相关的方法</h6><pre><code>设置数据样式的方法1. bold() 使用粗体显示字符串  document.write(str.bold());2. fontcolor() 使用指定的颜色来显示字符串  document.write(str.fontcolor(&quot;red&quot;));3. fontsize() 使用指定的尺寸来显示字符串  document.wirte(str.fontsize(1));//参数值为1~74. link() 将字符串显示为链接  document.write(str.link(www.baidu.com));//即字符串成为一个超链接5. big() 用大号字体显示字符串  document.write(str.big());6. blink() 显示闪动字符串  document.write(str.blink());7. sup() 把字符串显示为上标  8. sub() 把字符串显示为下标  9. small() 使用小字号来显示字符串 10. strike() 使用删除线来显示字符串  </code></pre><h6 id="与Java相似的方法"><a href="#与Java相似的方法" class="headerlink" title="与Java相似的方法"></a>与Java相似的方法</h6><pre><code>对数据进行操作的方法1. split() 把字符串分割为字符串数组  2. charAt() 返回在指定位置的字符  str.cjarAt(1);3. concat() 连接字符串  str.concat(str2);4. indexOf() 检索字符串  str.indexof(&quot;as&quot;);//不存在返回-15. charCodeAt() 返回在指定的位置的字符的 Unicode 编码   6. fixed() 以打字机文本显示字符串  7. fromCharCode() 从字符编码创建一个字符串  8. italics() 使用斜体显示字符串  9. lastIndexOf() 从后向前搜索字符串  10. localeCompare() 用本地特定的顺序来比较两个字符串  11. match() 找到一个或多个正则表达式的匹配  12. replace() 替换与正则表达式匹配的子串  str.replace(&quot;a&quot;, &quot;c&quot;);//把a替换成c13. search() 检索与正则表达式相匹配的值  14. slice() 提取字符串的片断，并在新的字符串中返回被提取的部分   15. substr() 从起始索引号提取字符串中指定数目的字符  str.substr(start, length);截取从start开始长度为length的字符串16. substring() 提取字符串中两个指定的索引号之间的字符  str.substring(start, end);截取从start开始 end 截至的字符串17. toLocaleLowerCase() 把字符串转换为小写  18. toLocaleUpperCase() 把字符串转换为大写  19. toLowerCase() 把字符串转换为小写  20. toUpperCase() 把字符串转换为大写  21.    toSource() 代表对象的源代码  22. toString() 返回字符串   23. valueOf() 返回某个字符串对象的原始值  </code></pre><h3 id="js的Date对象"><a href="#js的Date对象" class="headerlink" title="js的Date对象"></a>js的Date对象</h3><pre><code>js获取当前事件    var date = new Date();</code></pre><h4 id="Date对象的方法"><a href="#Date对象的方法" class="headerlink" title="Date对象的方法"></a>Date对象的方法</h4><pre><code>1. toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串 date.toLocaleString();2. toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串3. toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串4. setFullYear() 设置 Date 对象中的年份（四位数字）5. setMonth() 设置 Date 对象中月份 (0 ~ 11) 注意是 0~11，而不是1~12 ！！！！6. setHours() 设置 Date 对象中的小时 (0 ~ 23)7. setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)8. setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)9. setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)10. getFullYear() 从 Date 对象以四位数字返回年份11. getMonth() 返回 Date 对象的月份 (0~11)  setMonth() 设置 Date 对象中月份 (0 ~ 11)。 12. getHours() 返回 Date 对象的小时 (0 ~ 23)13. getMinutes() 返回 Date 对象的分钟 (0 ~ 59) 14. getSeconds() 返回 Date 对象的秒数 (0 ~ 59)15. getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)16. getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 </code></pre><h3 id="js的Math对象"><a href="#js的Math对象" class="headerlink" title="js的Math对象"></a>js的Math对象</h3><pre><code>全都是静态方法，调用函数时直接    Math.方法名（参数）</code></pre><h4 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h4><pre><code>1. abs(x) 返回数的绝对值2. acos(x) 返回数的反余弦值3. asin(x) 返回数的反正弦值4. atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值5. atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）6. ceil(x) 对数进行上舍入7. cos(x) 返回数的余弦8. exp(x) 返回 e 的指数9. floor(x) 对数进行下舍入10. log(x) 返回数的自然对数（底为e）11. max(x,y) 返回 x 和 y 中的最高值12. min(x,y) 返回 x 和 y 中的最低值13. pow(x,y) 返回 x 的 y 次幂14. random() 返回 0 ~ 1 之间的随机数15. round(x) 把数四舍五入为最接近的整数 16. sin(x) 返回数的正弦17. sqrt(x) 返回数的平方根18. tan(x) 返回角的正切19. toSource() 返回该对象的源代码20. valueOf() 返回 Math 对象的原始值 </code></pre><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4><pre><code>1. E 返回算术常量 e，即自然对数的底数（约等于2.718）2. LN2 返回 2 的自然对数（约等于0.693）3. LN10 返回 10 的自然对数（约等于2.302）4. LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）5. LOG10E 返回以 10 为底的 e 的对数（约等于0.434）6. PI 返回圆周率（约等于3.14159）7. SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）8. SQRT2 返回 2 的平方根（约等于 1.414）</code></pre><h3 id="js的全局函数"><a href="#js的全局函数" class="headerlink" title="js的全局函数"></a>js的全局函数</h3><pre><code>由于不属于任何一个对象，直接名称使用1. decodeURI()    解码某个编码的URI2. decodeURIComponent()        解码一个编码的URI组件3. encodeURI()    把字符串编码为URI4. encodeURIComponent()        把字符串编码为URI组件5. escape()        对字符串进行编码6. eval()        计算JavaScript字符串，并把它作为脚本代码来执行7. getClass()    返回一个javaObject的JavaClass8. isFinite()    检查某个值是否为有穷大的数9. isNaN（）        检查某个值是否是数字10. parseFloat()    解析一个字符串并返回一个浮点数11. parseInt()        解析一个字符串并返回一个整数12. unescape()        对由escape()编码的字符串进行解码</code></pre><h2 id="js函数的重载"><a href="#js函数的重载" class="headerlink" title="js函数的重载"></a>js函数的重载</h2><h3 id="js的重载是否存在？"><a href="#js的重载是否存在？" class="headerlink" title="js的重载是否存在？"></a>js的重载是否存在？</h3><pre><code>不存在重载。函数名相同的以后定义的为准。也就是说方法名相同的情况下，后定义的会覆盖掉先定义的方法。</code></pre><h3 id="js可以通过其他的方式去模拟重载"><a href="#js可以通过其他的方式去模拟重载" class="headerlink" title="js可以通过其他的方式去模拟重载"></a>js可以通过其他的方式去模拟重载</h3><pre><code>在js的函数中，传入的参数列表，可以通过一个js自带的 aruguments[]数组去访问传入的参数。例如：    function add(a, b, c){        arguments[0] == a;        arguments[1] == b;        arguments[2] == c;    }js的函数你可以传入多个参数，例如 add(1,2,3,4,5,6)，虽然定义的 add函数只有三个参数，但是通过arguments可以获得 传入的所有参数 1,2,3,4,5,6 只是 a=1,b=2,c=3 罢了通过arguments.length 判断传入参数大小，以此来手动进行重载</code></pre><h2 id="js的bom对象"><a href="#js的bom对象" class="headerlink" title="js的bom对象"></a>js的bom对象</h2><pre><code>bom：broswer object model 浏览器对象模型通过bom对象，可以直接对浏览器进行操作。</code></pre><h3 id="有哪些对象"><a href="#有哪些对象" class="headerlink" title="有哪些对象"></a>有哪些对象</h3><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>Navigator 对象包含有关浏览器的信息。</code></pre><h5 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. appCodeName 返回浏览器的代码名 2. appMinorVersion 返回浏览器的次级版本3. appName 返回浏览器的名称    alert(navigator.appName);4. appVersion 返回浏览器的平台和版本信息5. browserLanguage 返回当前浏览器的语言6. cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值7. cpuClass 返回浏览器系统的 CPU 等级8. onLine 返回指明系统是否处于脱机模式的布尔值9. platform 返回运行浏览器的操作系统平台10. systemLanguage 返回 OS 使用的默认语言11. userAgent 返回由客户机发送服务器的 user-agent 头部的值12. userLanguage 返回 OS 的自然语言设置 </code></pre><h5 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. javaEnabled() 规定浏览器是否启用 Java2. taintEnabled() 规定浏览器是否启用数据污点 (data tainting)</code></pre><h4 id="screen（屏幕对象）"><a href="#screen（屏幕对象）" class="headerlink" title="screen（屏幕对象）"></a>screen（屏幕对象）</h4><pre><code>Screen 对象包含有关客户端显示屏幕的信息。</code></pre><h5 id="对象属性-1"><a href="#对象属性-1" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)2. availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)3. bufferDepth 设置或返回调色板的比特深度4. colorDepth 返回目标设备或缓冲器上的调色板的比特深度5. deviceXDPI 返回显示屏幕的每英寸水平点数6. deviceYDPI 返回显示屏幕的每英寸垂直点数7. fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑 8. height 返回显示屏幕的高度9. logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数10. logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数11. pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）9 12. updateInterval 设置或返回屏幕的刷新率13. width 返回显示器屏幕的宽度。 </code></pre><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><pre><code>对象包含有关当前 URL 的信息。</code></pre><h5 id="对象属性-2"><a href="#对象属性-2" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. ash 设置或返回从井号 (#) 开始的 URL（锚）2. host 设置或返回主机名和当前 URL 的端口号3. hostname 设置或返回当前 URL 的主机名4. href 设置或返回完整的 URL`(重点)`     1. location.href;//得到当前请求的url地址。    2. location.href=&quot;你要跳转的地址,例如：www.baidu.com&quot;这样就会跳转页面5. pathname 设置或返回当前 URL 的路径部分6. port 设置或返回当前 URL 的端口号7. protocol 设置或返回当前 URL 的协议8. search 设置或返回从问号 (?) 开始的 URL（查询部分）</code></pre><h5 id="对象方法-1"><a href="#对象方法-1" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. assign() 加载新的文档2. reload() 重新加载当前文档3. replace() 用新的文档替换当前文档。 </code></pre><h4 id="history（历史）"><a href="#history（历史）" class="headerlink" title="history（历史）"></a>history（历史）</h4><pre><code>请求的url的历史记录</code></pre><h5 id="对象属性-3"><a href="#对象属性-3" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. length 返回浏览器历史列表中的 URL 数量</code></pre><h5 id="对象方法-2"><a href="#对象方法-2" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. back() 加载 history 列表中的前一个 URL  history.back()2. forward() 加载 history 列表中的下一个 URL    history.forward()3. go() 加载 history 列表中的某个具体页面</code></pre><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><pre><code>Window 对象表示浏览器中打开的窗口。包含location,navicator,history,screen对象它是一个顶层对象</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>opener 获得创建窗口的窗口 即用a.html打开b.html，在b.html中通过window.opener获得a.html的窗口对象</code></pre><h5 id="对象方法（都要记住）"><a href="#对象方法（都要记住）" class="headerlink" title="对象方法（都要记住）"></a>对象方法（都要记住）</h5><pre><code>1. alert() 显示带有一段消息和一个确认按钮的警告框2. blur() 把键盘焦点从顶层窗口移开3. clearInterval() 取消由 setInterval() 设置的 timeout     1. window.clearInterval(id);    2. id为 setInterval()返回的id值4. clearTimeout() 取消由 setTimeout() 方法设置的 timeout    1. window.clearTimeout(id);    2. id为 setTimeout()返回的id值5. close() 关闭浏览器窗口    1. windown.close();    2. 浏览器兼容性差6. confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框    1. window.confirm(&quot;传入的消息&quot;)    2. 返回一个Boolean类型值。确定为ture，取消为false7. createPopup() 创建一个 pop-up 窗口8. focus() 把键盘焦点给予一个窗口 9. moveBy() 可相对窗口的当前坐标把它移动指定的像素10. moveTo() 把窗口的左上角移动到一个指定的坐标11. open() 打开一个新的浏览器窗口或查找一个已命名的窗口     1. window.open(URL, name, features, replace);    2. url 要打开页面的url  name 自己定,可以不要 features 窗口特征 宽高    3. window.open(&quot;www.baodu.com&quot;,&quot;&quot;,&quot;width=200,height=200&quot;);12. print() 打印当前窗口的内容 13. prompt() 显示可提示用户输入的对话框    1. window.prompt(&quot;提示输入的值&quot;,&quot;默认的文本框的内容&quot;)；    2. 现在用的少，因为不好看，还不能改样式表14. resizeBy() 按照指定的像素调整窗口的大小15. resizeTo() 把窗口的大小调整到指定的宽度和高度 16. scrollBy() 按照指定的像素值来滚动内容17. scrollTo() 把内容滚动到指定的坐标 18. setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式     1. 一般用来做定时器,有一个返回值ID，代表这个定时器    2. window.setInterval(&quot;js代码&quot;,毫秒数);    3. 1s = 1000ms    4. 例如：window.setInterval(&quot;alert(&apos;123&apos;);&quot;, 3000);19. setTimeout() 在指定的毫秒数后调用函数或计算表达式    1. 一般用来做定时器，但是只会执行一次。返回一个ID值，代表这个定时器    2. 例如：window.setTimeout(&quot;alert(&apos;123&apos;);&quot;, 4000);</code></pre><h2 id="js的dom对象"><a href="#js的dom对象" class="headerlink" title="js的dom对象"></a>js的dom对象</h2><h3 id="什么是dom"><a href="#什么是dom" class="headerlink" title="什么是dom"></a>什么是dom</h3><pre><code>dom：document object model：文档对象模型文档：超文本标记文档：html，xml对象：提供了属性和方法模型：使用属性和方法操作超文本标记型文档可以使用js里面的dom里面提供的对象，使用这些对象的属性和方法，对标记型文档进行操作想要对标记型文档进行操作，首先需要 对标记型文档里面的所有内容封装成对象，需要把HTML里面的标签，属性，文本内容都封装成对象要想对标记型文档进行操作，解析标记型文档</code></pre><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><pre><code>根据html的层级结构，在内存中分配一个属性结构，需要把html中的每部分封装成对象</code></pre><p><img src="https://i.imgur.com/T6dN6Cg.png" alt=""></p><pre><code>1. 上图中，整个蓝色框住的可以当成一个document对象，表示整个HTML文档2. 同时一个标签/元素也是一个对象，我们成为标签对象 element3. 属性对象（id属性之类的）4. 文本对象（标签括起来的数据）5. Node（节点）对象是属性，文本，标签对象的父对象</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>nodeName    String        节点的名字：根据节点的类型定义nodeValue    String        节点的值：根据节点的类型而定义nodeType    Number        节点的类型常量值之一ownerDocument    Document    指向整个节点所属的文档firstChild    Node        指向在childNodes列表中的第一个节点lastChild    Node        指向在childNodes列表中的最后一个节点childNodes    NodeList    所有子节点的列表parentNode    Node        返回一个给定节点的父亲节点previousSibling    Node    指向前一个兄弟节点：如果这个节点就是第一个兄弟节点，那么值为nullnextSibling    Node        指向后一个兄弟节点hasChildNodes()    Boolean    当childNodes包含一个或多个节点时，返回真attributes    NameNodeMap    包含了代表一个元素的特性的Attr对象，仅用于Element节点appendChild(node)    Node    将node添加到childNodes的末尾removeChild(node)    Node    从childNodes中删除nodereplaceChild(newnode, node)    Node    替换insertBefore(newnode, refnode)    Node    在ChildNodes中的refnode之前插入newnode</code></pre><h3 id="DHTML"><a href="#DHTML" class="headerlink" title="DHTML"></a>DHTML</h3><pre><code>DHTML是很多技术的简称DHTML=html+css+dom+javascripthtml：封装数据css：使用属性和属性值设置样式dom：操作html文档JavaScript：专门指的是js的语法语句</code></pre><h3 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h3><pre><code>每个载入浏览器的HTML文档都会成为document对象</code></pre><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>1. cookie 设置或返回与当前文档有关的所有 cookie2. domain 返回当前文档的域名3. lastModified 返回文档被最后修改的日期和时间4. referrer 返回载入当前文档的文档的 URL5. title 返回当前文档的标题6. URL 返回当前文档的 URL</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>1. close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据2. getElementById() 返回对拥有指定 id 的第一个对象的引用3. getElementsByName() 返回带有指定名称的对象集合4. getElementsByTagName() 返回带有指定标签名的对象集合5. open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出6. write() 向文档写 HTML 表达式 或 JavaScript 代码7. writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符</code></pre><h3 id="案例：在末尾添加节点"><a href="#案例：在末尾添加节点" class="headerlink" title="案例：在末尾添加节点"></a>案例：在末尾添加节点</h3><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;&lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1();&quot; /&gt;&lt;script&gt;    //任务是，点击按钮，添加一行 555 在 444 后面    function add1(){        var ul = document.getElementById(&quot;ulid&quot;);        var text = document.createTextNode(&quot;555&quot;);        var li = document.createElement(&quot;li&quot;);        li.appendChild(text);        ul.appendChild(li);    }&lt;/script&gt;</code></pre><h3 id="元素对象-element对象"><a href="#元素对象-element对象" class="headerlink" title="元素对象-element对象"></a>元素对象-element对象</h3><pre><code>在 HTML DOM 中，Element 对象表示 HTML 元素。Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。要操作element对象，首先必须要获取到element，使用document里面对应的方法获取</code></pre><h4 id="操作element对象的属性"><a href="#操作element对象的属性" class="headerlink" title="操作element对象的属性"></a>操作element对象的属性</h4><pre><code>1. 获取属性：getAttribute(name)方法2. 设置属性：setAttribute(name, valure)方法    例如：input1.setAttribute(&quot;class&quot;,&quot;haha&quot;);    这是 input1元素的class为haha3. 删除属性：removeAttribute(name)方法    不能删除value属性</code></pre><h4 id="获得element中的element对象"><a href="#获得element中的element对象" class="headerlink" title="获得element中的element对象"></a>获得element中的element对象</h4><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var ull = document.getElementById(&quot;ulid&quot;);    var lis = ull.childNodes;    alert(lis.length);&lt;/script&gt;</code></pre><p><code>上面的代码在IE中输出4， 在火狐中输出9</code>  </p><pre><code>因为火狐把 回车 空格 也算作数据了</code></pre><p><code>所以直接通过childNodes直接获得准确的子类是不现实的</code></p><pre><code>在Element对象的范围内，可以用来查找其他节点的唯一有效方法就是getElementsByTagName()方法。上面的例子中，直接通过 ull.getElementsByTagName(&quot;li&quot;)获得子Element对象就行了。</code></pre><h3 id="Node对象"><a href="#Node对象" class="headerlink" title="Node对象"></a>Node对象</h3><h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><pre><code>1. nodeName        节点名称2. nodeType        节点类型3. nodeValue    节点的值</code></pre><h5 id="标签节点对应的值"><a href="#标签节点对应的值" class="headerlink" title="标签节点对应的值"></a>标签节点对应的值</h5><pre><code>nodeType    1nodeName    大写的标签名称 nodeValue    null</code></pre><h5 id="属性节点对应的值"><a href="#属性节点对应的值" class="headerlink" title="属性节点对应的值"></a>属性节点对应的值</h5><pre><code>获取方法 getAttributeNode(&quot;属性名称&quot;);nodeType    2nodeName    属性名称nodeValue    属性的值</code></pre><h5 id="文本节点对应的值"><a href="#文本节点对应的值" class="headerlink" title="文本节点对应的值"></a>文本节点对应的值</h5><pre><code>获取方法 element.firstChild 或者 lastChildnodeType    3nodeName    #textnodeValue    文本内容</code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>使用dom解析html的时候，需要html里面的标签，属性和文本都封装成对象&lt;span id=&quot;spanid&quot;&gt;呵呵呵&lt;/span&gt;&lt;script&gt;    //标签节点    var span1 = document.getElementById(&quot;spanid&quot;);    alert(span1.nodeType);    //输出    1    alert(Span1.nodeName);    //输出    SPAN    alert(span1.nodeValue);    //输出    null    //属性节点    var id1 = span1.getAttributeNode(&quot;id&quot;);    alert(id1.nodeType);    //输出    2    alert(id1.nodeName);    //输出    id    alert(id1.nodeValue);    //输出    spanid    //文本节点    var text = span1.firstChild;    alert(text.nodeType);    //输出    3    alert(text.nodeName);    //输出    #text    alert(text.nodeValue);    //输出    呵呵呵&lt;/script&gt;</code></pre><h3 id="父节点，子节点，同辈节点"><a href="#父节点，子节点，同辈节点" class="headerlink" title="父节点，子节点，同辈节点"></a>父节点，子节点，同辈节点</h3><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;ul 是 li 的父节点， li 是 ul 的子节点li 与 li 是 同辈节点，因为他们是同一级</code></pre><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><pre><code>parentNode</code></pre><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><pre><code>childNodes的到所有的子节点，但是兼容性查firstChild    第一个子节点lastChild    最后一个子节点</code></pre><h4 id="同辈节点"><a href="#同辈节点" class="headerlink" title="同辈节点"></a>同辈节点</h4><pre><code>nextSibling        下一个子节点previousSibling    前一个子节点</code></pre><h3 id="操作DOM树"><a href="#操作DOM树" class="headerlink" title="操作DOM树"></a>操作DOM树</h3><h4 id="appendChild方法"><a href="#appendChild方法" class="headerlink" title="appendChild方法"></a>appendChild方法</h4><pre><code>添加子节点到末尾特点：类似于剪切粘贴的效果</code></pre><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><h6 id="CSS内容"><a href="#CSS内容" class="headerlink" title="CSS内容"></a>CSS内容</h6><pre><code>#div1{    width:200px;    height:150px;    border:2px solid red;}#div2{    width:250px;    height:150px;    border: 5px dashed green;}</code></pre><h6 id="HTML内容"><a href="#HTML内容" class="headerlink" title="HTML内容"></a>HTML内容</h6><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;ul id=&quot;ulidll&quot;&gt;        &lt;li&gt;123&lt;/li&gt;        &lt;li&gt;456&lt;/li&gt;        &lt;li&gt;789&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1()&quot; /&gt;</code></pre><h6 id="js内容"><a href="#js内容" class="headerlink" title="js内容"></a>js内容</h6><pre><code>function add1(){    var div2 = document.getElementById(&quot;div2&quot;);    var ull = document.getElementById(&quot;ulidll&quot;);    div2.appendChild(ull);}通过结果可以看到，ul 的内容 从 div1 移动到 div2 中。</code></pre><h4 id="insertBefore-newnode-oldNode-方法"><a href="#insertBefore-newnode-oldNode-方法" class="headerlink" title="insertBefore(newnode, oldNode)方法"></a>insertBefore(newnode, oldNode)方法</h4><pre><code>在oldnode节点之前插入一个新的节点1. 创建标签    li2 = document.createElement(&quot;li&quot;);2. 创建文本    text = document.createTextNode(&quot;啦啦啦啦&quot;);3. 把文本添加到标签下    li2.appendChild(text);4. 获取 oldNode    var li3=document.getElementById(&quot;li3&quot;);5. 插入    var ul = document.getElementById(&quot;ul1&quot;);//获得父节点    ul.insertBefore(li2, li3);</code></pre><h4 id="removeChilid-删除节点"><a href="#removeChilid-删除节点" class="headerlink" title="removeChilid 删除节点"></a>removeChilid 删除节点</h4><pre><code>只能通过父节点删除，不能自己删自己1. 获取要删除标签    var li3 = document.getElementById(&quot;li3&quot;);2. 获取父节点    var par = document.getElementById(&quot;ul&quot;);3. 删除    par.removeChild(li3);</code></pre><h4 id="replaceChild-newnode-oldnode-替换节点"><a href="#replaceChild-newnode-oldnode-替换节点" class="headerlink" title="replaceChild(newnode, oldnode)替换节点"></a>replaceChild(newnode, oldnode)替换节点</h4><pre><code>只能通过父节点进行替换，不能自己替换自己1. 创建新节点    var li = document.createElement(&quot;li&quot;);    var text = document.createTextNode(&quot;文本内容&quot;);    li.appenChild(text);2. 获取旧节点    var oldli = document.getElementById(&quot;oldli&quot;);3. 获取父标签    var ul = document.getElementById(&quot;ul&quot;);4. 替换标签    ul.replaceChild(li, oldli);</code></pre><h4 id="cloneNode-boolean-复制节点"><a href="#cloneNode-boolean-复制节点" class="headerlink" title="cloneNode(boolean) 复制节点"></a>cloneNode(boolean) 复制节点</h4><pre><code>//复制ul列表到另一个div中1. 获取ul    var ul = document.getElementById(&quot;ul&quot;);2. 复制ul，放到类似于剪切板里面    var copyul = ul.cloneNode(true);3. 获取新的div    var newdiv = document.getElementById(&quot;newdiv&quot;);4. 复制进去    newdiv.appendChild(copyul);            因为 copyul 是复制的新的，所以appendChild的剪贴方法并不会删除掉原 ul</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Html&quot;&gt;&lt;a href=&quot;#Html&quot; class=&quot;headerlink&quot; title=&quot;Html&quot;&gt;&lt;/a&gt;Html&lt;/h2&gt;&lt;h3 id=&quot;什么是Html？&quot;&gt;&lt;a href=&quot;#什么是Html？&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cocos 内存管理</title>
    <link href="http://yoursite.com/2018/09/27/Cocos-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/27/Cocos-内存管理/</id>
    <published>2018-09-27T02:09:16.000Z</published>
    <updated>2018-09-27T03:31:25.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="delete和new"><a href="#delete和new" class="headerlink" title="delete和new"></a>delete和new</h2><h3 id="new运算符使用的一般格式为"><a href="#new运算符使用的一般格式为" class="headerlink" title="new运算符使用的一般格式为 　　"></a>new运算符使用的一般格式为 　　</h3><pre><code>new 类型 [初值] 　　用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。new int;//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针) 　　new int(100);//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址　　new char[10];//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 　　new int[5][4];//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址float *p=new float (3.14159);//开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p 　　</code></pre><h3 id="delete运算符使用的一般格式为"><a href="#delete运算符使用的一般格式为" class="headerlink" title="delete运算符使用的一般格式为 　　"></a>delete运算符使用的一般格式为 　　</h3><pre><code>delete [ ]指针变量 　　例如要撤销上面用new开辟的存放单精度数的空间(上面第5个例子)，应该用 　　delete p；　　前面用“new char[10];”开辟的字符数组空间，如果把new返回的指针赋给了指针变量pt，则应该用以下形式的delete运算符撤销该空间： 　　  delete [] pt；//在指针变量前面加一对方括号，表示是对数组空间的操作 　　</code></pre><h2 id="CREATE-FUNC-函数"><a href="#CREATE-FUNC-函数" class="headerlink" title="CREATE_FUNC()函数"></a>CREATE_FUNC()函数</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code>/**  * define a create function for a specific type, such as CCLayer  * @__TYPE__ class type to add create(), such as CCLayer  */  #define CREATE_FUNC(__TYPE__) \  static __TYPE__* create() \  { \      __TYPE__ *pRet = new __TYPE__(); \  //创建传过来的东西    if (pRet &amp;&amp; pRet-&gt;init()) \      { \          pRet-&gt;autorelease(); \          return pRet; \      } \      else \      { \          delete pRet; \          pRet = NULL; \          return NULL; \      } \  }</code></pre><h3 id="什么是CREATE-FUNC"><a href="#什么是CREATE-FUNC" class="headerlink" title="什么是CREATE_FUNC()"></a>什么是CREATE_FUNC()</h3><pre><code>为类似CCLayer类的特定类增加一个create函数，我们也可以看到在宏的下面定义了一个create()函数返回到类型就是宏带入的参数&quot;__TYPE__&quot;指针类型</code></pre><h3 id="create（）函数做了什么？"><a href="#create（）函数做了什么？" class="headerlink" title="create（）函数做了什么？"></a>create（）函数做了什么？</h3><pre><code>他执行了类的构造函数，执行了init()初始化函数，最后又设置创建出的对象为自动释放内存，这样其他人在使用这个类的时候，只要是用create（）函数创建出来的对象就是不用费心区管理释放内存</code></pre><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="什么时候引用计数"><a href="#什么时候引用计数" class="headerlink" title="什么时候引用计数"></a>什么时候引用计数</h3><pre><code>每一个对象都有一个关联的引用计数 —— 对该对象的活跃引用的数量。如果对象的引用计数是零，那么它就是垃圾（用户程序不可到达它），并可以回收。</code></pre><h2 id="Cocos2dx内存管理分为两块"><a href="#Cocos2dx内存管理分为两块" class="headerlink" title="Cocos2dx内存管理分为两块"></a>Cocos2dx内存管理分为两块</h2><pre><code>1. 通过加入 `autorelease` 来自动释放那些创建后未使用的对象1. 通过`节点管理`来保证对象在弃用后及时的删除</code></pre><h3 id="及时释放弃用的对象"><a href="#及时释放弃用的对象" class="headerlink" title="及时释放弃用的对象"></a>及时释放弃用的对象</h3><p><code>使用条件</code>：该对象是Node的子类对象<br><code>使用方法</code>：addChild，removeChild</p><h4 id="内存管理过程："><a href="#内存管理过程：" class="headerlink" title="内存管理过程："></a>内存管理过程：</h4><pre><code>addChild  添加对象后，对象可以被使用removeChild 删除对象后，对象被立刻删除（通过 delete）</code></pre><h3 id="及时释放未使用的对象"><a href="#及时释放未使用的对象" class="headerlink" title="及时释放未使用的对象"></a>及时释放未使用的对象</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><pre><code>新创建的对象如果 一帧 内不使用，就会被自动释放。（所谓一针，即是一个gameloop）</code></pre><h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><pre><code>对象通过CREAT_FUNC()宏创建或者对象使用autorelease加入了自动释放池</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>自动实现</code></pre><h4 id="管理过程"><a href="#管理过程" class="headerlink" title="管理过程"></a>管理过程</h4><h5 id="对象不使用的情况"><a href="#对象不使用的情况" class="headerlink" title="对象不使用的情况"></a>对象不使用的情况</h5><pre><code>对象创建        引用+1对象自动释放     引用-1</code></pre><h5 id="对象使用的情况"><a href="#对象使用的情况" class="headerlink" title="对象使用的情况"></a>对象使用的情况</h5><pre><code>对象创建        引用+1对象使用        引用+1//通过 addchild 使用对象对象自动释放    引用-1</code></pre><p>引用的初始值为0，如果一阵结束后对象的引用值还是0，那就会被delete掉</p><h2 id="内存管理的实现原理"><a href="#内存管理的实现原理" class="headerlink" title="内存管理的实现原理"></a>内存管理的实现原理</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p><code>Red</code>类：进行引用计数，提供加入自动释放池的接口。<br><code>AutoreleasePool</code>类：管理一个<code>vector</code>数组来存放自动释放池的对象。提供对释放池的清空操作<br><code>PoolManager</code>类：管理一个<code>vector</code>数组来存放自动释放池。默认情况下引擎只创建一个自动释放池，因此这个类是提供给开发者使用的，例如处于性能考虑添加自己的自动释放池<br><code>DisplayLinkDirector</code>类：只是一个导演类，提供游戏的主循环，实现每一帧的资源释放。这个类继承自<code>Director</code>类，也是唯一一个继承了<code>Director</code>的类，也就是说完全可以合并为一个类。</p><h4 id="Ref源码"><a href="#Ref源码" class="headerlink" title="Ref源码"></a>Ref源码</h4><pre><code>// 引用计数变量unsigned int _referenceCount;// 对象被构造后，引用计数值为 1Ref::Ref(): _referenceCount(1) //当Ref对象被创建时，引用计数的值为 1{#if CC_ENABLE_SCRIPT_BINDING    static unsigned int uObjectCount = 0;    _luaID = 0;    _ID = ++uObjectCount;    _scriptObject = nullptr;#endif#if CC_USE_MEM_LEAK_DETECTION    trackRef(this);#endif}// 引用+1void Ref::retain(){    CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;);    ++_referenceCount;}// 引用-1 。如果引用为0则释放对象void Ref::release(){    CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;);    --_referenceCount;    if (_referenceCount == 0)    {#if CC_USE_MEM_LEAK_DETECTION        untrackRef(this);#endif        delete this; // 注意这里 把对象 delete 了    }}// 提供加入自动释放池的接口。对象调用此函数即可加入自动释放池的管理。Ref* Ref::autorelease(){    PoolManager::getInstance()-&gt;getCurrentPool()-&gt;addObject(this);    return this;}//获取引用计数值unsigned int Ref::getReferenceCount() const{    return _referenceCount;}</code></pre><h4 id="AutoreleasePool源码"><a href="#AutoreleasePool源码" class="headerlink" title="AutoreleasePool源码"></a>AutoreleasePool源码</h4><pre><code>// 存放释放池对象的数组std::vector&lt;Ref*&gt; _managedObjectArray;// 往释放池添加对象void AutoreleasePool::addObject(Ref* object){    _managedObjectArray.push_back(object);}// 清空释放池，将其中的所有对象都 deletevoid AutoreleasePool::clear(){    // 释放所有对象    for (const auto &amp;obj : _managedObjectArray)    {        obj-&gt;release();    }    // 清空vector数组    _managedObjectArray.clear();}// 查看某个对象是否在释放池中bool AutoreleasePool::contains(Ref* object) const{    for (const auto&amp; obj : _managedObjectArray)    {        if (obj == object)            return true;    }    return false;}</code></pre><h4 id="PoolManager源码"><a href="#PoolManager源码" class="headerlink" title="PoolManager源码"></a>PoolManager源码</h4><pre><code>// 释放池管理器单例对象static PoolManager* s_singleInstance;// 释放池数组std::vector&lt;AutoreleasePool*&gt; _releasePoolStack;// 获取 释放池管理器的单例PoolManager* PoolManager::getInstance(){    if (s_singleInstance == nullptr)    {        // 新建一个管理器对象        s_singleInstance = new PoolManager();         // 添加一个自动释放池        new AutoreleasePool(&quot;cocos2d autorelease pool&quot;);// 内部使用了释放池管理器的push，这里的调用很微妙，读者可以动手看一看    }    return s_singleInstance;}// 获取当前的释放池AutoreleasePool* PoolManager::getCurrentPool() const{    return _releasePoolStack.back();}// 查看对象是否在某个释放池内bool PoolManager::isObjectInPools(Ref* obj) const{    for (const auto&amp; pool : _releasePoolStack)    {        if (pool-&gt;contains(obj))            return true;    }    return false;}// 添加释放池对象void PoolManager::push(AutoreleasePool *pool){    _releasePoolStack.push_back(pool);}// 释放池对象出栈void PoolManager::pop(){    CC_ASSERT(!_releasePoolStack.empty());    _releasePoolStack.pop_back();}</code></pre><h4 id="DisplayLinkDirector源码"><a href="#DisplayLinkDirector源码" class="headerlink" title="DisplayLinkDirector源码"></a>DisplayLinkDirector源码</h4><pre><code>void DisplayLinkDirector::mainLoop(){    //第一次当导演    if (_purgeDirectorInNextLoop)    {        _purgeDirectorInNextLoop = false;        purgeDirector();//进行清理工作    }    else if (! _invalid)    {        // 绘制场景，游戏主要工作都在这里完成        drawScene();        // 清空资源池        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();    }}</code></pre><h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><pre><code>首先，创建了一个 Node 对象A，Node 继承Ref，因此 Ref 的引用计数为1；然后，A通过 autorelease 将自己放入自动释放池；drawScene() 完成后，一帧结束，Director 通过释放池将池中的对象 clear()，即对 Node 对象A进行 release() 操作。A的引用计数变为0，执行 delete 释放A对象。、</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;delete和new&quot;&gt;&lt;a href=&quot;#delete和new&quot; class=&quot;headerlink&quot; title=&quot;delete和new&quot;&gt;&lt;/a&gt;delete和new&lt;/h2&gt;&lt;h3 id=&quot;new运算符使用的一般格式为&quot;&gt;&lt;a href=&quot;#new运算符使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xml</title>
    <link href="http://yoursite.com/2018/09/26/xml/"/>
    <id>http://yoursite.com/2018/09/26/xml/</id>
    <published>2018-09-26T12:59:29.000Z</published>
    <updated>2018-09-26T13:02:49.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xml概述："><a href="#xml概述：" class="headerlink" title="xml概述："></a>xml概述：</h2><pre><code>可扩展标记语言。(Extensible Markup Language)  允许开发者自由定义标签，可以将标签和内容有效分离。  xml不再侧重于数据如何展示，二十更过的关注数据如何存储和传输。  </code></pre><h2 id="xml应用场景："><a href="#xml应用场景：" class="headerlink" title="xml应用场景："></a>xml应用场景：</h2><pre><code>1. xml把数据从HTML分离出来。那温度距离，用html注重于显示而无关数据，用xml改变数据，让html读取。  2. 简化数据共享。提供了独立于软件和硬件的存储方式。  3. 简化数据的传输。通过xml，可以在不兼容的系统之间传输数据。  4. 简化平台的变更。  </code></pre><h2 id="xml的优势："><a href="#xml的优势：" class="headerlink" title="xml的优势："></a>xml的优势：</h2><pre><code>1. 简单易用的标记预语言。xml标签可以自己自由定义。2. 严格的格式。比html标签控制更严格。3. 数据逻辑和显示逻辑分离。html注重于显示，xml注重于数据存储。</code></pre><h2 id="xml文档规则："><a href="#xml文档规则：" class="headerlink" title="xml文档规则："></a>xml文档规则：</h2><pre><code>1. 有且只有一个根元素2. 元素必须合理结束3. 元素之间必须合理嵌套4. 元素的属性必须有值</code></pre><h2 id="xml存储信息："><a href="#xml存储信息：" class="headerlink" title="xml存储信息："></a>xml存储信息：</h2><pre><code>例如：书名    作者    价格         java思想    小王    79.00          Spring指南    小李    89.00  </code></pre><h2 id="xml的写法"><a href="#xml的写法" class="headerlink" title="xml的写法"></a>xml的写法</h2><h3 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h3><pre><code>1. 简体中文：GBK 或 GB23122. 繁体中文：BIG53. 西欧字符：ISO8859-14. 通用的国际编码：Unicode5. 针对Unicode的可变长度字符编码UTF8</code></pre><h3 id="合法标签名："><a href="#合法标签名：" class="headerlink" title="合法标签名："></a>合法标签名：</h3><pre><code>xml元素由开始标签和结束标签组合，结束标签比开始标签多一条斜线xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头不能包括 ‘&lt; &gt; , $’标签名尽量不要出现英文冒号“:”, 除非是在使用名空间标签名不能以字符“xml”等任意大小写组合开始标签名不能包含空格</code></pre><h3 id="空元素："><a href="#空元素：" class="headerlink" title="空元素："></a>空元素：</h3><pre><code>例：&lt;元素名 属性名=&quot;  &quot; /&gt;空元素不是内容为空的元素，空元素不接受子元素，也不接受字符内容&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; standalone = &quot;yes&quot; ?&gt;&lt;书籍列表&gt;    &lt;书名&gt; java思想&lt;/书名&gt;    &lt;价格&gt;79.00&lt;/价格&gt;    &lt;作者&gt;小王&lt;/作者&gt;    &lt;书名&gt;Spring指南&lt;/书名&gt;    &lt;价格&gt;89.00&lt;/价格&gt;    &lt;作者&gt;小李&lt;/作者&gt;&lt;/书籍列表&gt;那么 &lt;书籍列表&gt; 就是根元素</code></pre><h2 id="字符数据："><a href="#字符数据：" class="headerlink" title="字符数据："></a>字符数据：</h2><pre><code>开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。解决方法：    1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）：        &amp;lt;       ---&gt;     &quot;&lt;&quot;   小于符号        &amp;gt;      ---&gt;     &quot;&gt;&quot;   大于符号        &amp;amp;      ---&gt;     &quot;&amp;&quot;   and符号 &amp;        &amp;apos;    ---&gt;     &quot;&apos;&quot;     英文单引号        &amp;quot;    ---&gt;     &quot;&quot;&quot;     英文双引号    2. 使用CDATA标记        在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理        实体引用也会失去作用，变成纯文本        语法：        &lt;![CDATA[文本内容]]&gt;</code></pre><h2 id="换行处理："><a href="#换行处理：" class="headerlink" title="换行处理："></a>换行处理：</h2><pre><code>目前主流的操作系统，主要由3种换行符：    1. Windows平台：回车符（CR） 和 换行符 （LF） 的组合存储换行    2. Unix和Linux平台：以换行符（LF）存储换行    3. Macintosh平台：以回车符（CR）存储换行xml同一换行符（LF） 存储换行</code></pre><h2 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h2><pre><code>同一份xml文档中可能出现多个同名的元素和属性。必须添加标记判断语法：    xmlns[:prefix]= &quot;命名空间字符串&quot;    xmlns -&gt; xml namespace例如：    xmlns:hehe = &quot;http://www.***.com&quot;    &lt;hehe:name&gt;java思想&lt;/hehe:name&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xml概述：&quot;&gt;&lt;a href=&quot;#xml概述：&quot; class=&quot;headerlink&quot; title=&quot;xml概述：&quot;&gt;&lt;/a&gt;xml概述：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;可扩展标记语言。(Extensible Markup Language)  
允许开发者自由
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL命令</title>
    <link href="http://yoursite.com/2018/09/26/MySQL%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/26/MySQL命令/</id>
    <published>2018-09-26T08:30:14.000Z</published>
    <updated>2018-09-26T08:37:54.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下进入命令行"><a href="#Windows下进入命令行" class="headerlink" title="Windows下进入命令行"></a>Windows下进入命令行</h2><pre><code>ssh 用户名@ip地址  或者 mysql -h ip地址 -u root -p  然后输入密码  mysql -u 数据库用户名 -p  然后输入密码  </code></pre><h3 id="修改密码："><a href="#修改密码：" class="headerlink" title="修改密码："></a>修改密码：</h3><pre><code>`mysqladmin -u root -p 密码 password 新密码`  </code></pre><h3 id="增加用户："><a href="#增加用户：" class="headerlink" title="增加用户："></a>增加用户：</h3><pre><code>`insert into mysql.user(Host,User,Password)  values  (&quot;localhost&quot;,&quot;test&quot;,password(&quot;1234&quot;));（登陆地址，用户名，密码）  `</code></pre><h3 id="用户授权："><a href="#用户授权：" class="headerlink" title="用户授权："></a>用户授权：</h3><pre><code>`grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;;　 `   `权限包括：select,insert,update,delete，all privileges  `  `记得创建授权之后，flush privileges;//刷新系统权限表 `   </code></pre><h3 id="删除用户："><a href="#删除用户：" class="headerlink" title="删除用户："></a>删除用户：</h3><pre><code>`root权限下 Delete FROM user Where User=&apos;用户名&apos; and Host=&apos;ip地址&apos;; ``flush privileges;  `</code></pre><h3 id="修改密码：-1"><a href="#修改密码：-1" class="headerlink" title="修改密码："></a>修改密码：</h3><pre><code>`update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;test&quot; and Host=&quot;localhost&quot;;  `</code></pre><h3 id="查看数据库："><a href="#查看数据库：" class="headerlink" title="查看数据库："></a>查看数据库：</h3><pre><code>`show databases;  `</code></pre><h3 id="链接数据库："><a href="#链接数据库：" class="headerlink" title="链接数据库："></a>链接数据库：</h3><pre><code>`use 库名；  `</code></pre><h3 id="查看数据表："><a href="#查看数据表：" class="headerlink" title="查看数据表："></a>查看数据表：</h3><pre><code>`show tables;  `</code></pre><h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><pre><code>`show status like &apos;%下面变量%&apos;; ` </code></pre><hr><pre><code>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。   Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。   Connections 试图连接MySQL服务器的次数。   Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。   Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。   Delayed_writes 用INSERT DELAYED写入的行数。   Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。   Flush_commands 执行FLUSH命令的次数。   Handler_delete 请求从一张表中删除行的次数。   Handler_read_first 请求读入表中第一行的次数。   Handler_read_key 请求数字基于键读行。   Handler_read_next 请求读入基于一个键的一行的次数。   Handler_read_rnd 请求读入基于一个固定位置的一行的次数。   Handler_update 请求更新表中一行的次数。   Handler_write 请求向表中插入一行的次数。   Key_blocks_used 用于关键字缓存的块的数量。   Key_read_requests 请求从缓存读入一个键值的次数。   Key_reads 从磁盘物理读入一个键值的次数。   Key_write_requests 请求将一个关键字块写入缓存次数。       Key_writes 将一个键值块物理写入磁盘的次数。   Max_used_connections 同时使用的连接的最大数目。   Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。   Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。   Open_tables 打开表的数量。   Open_files 打开文件的数量。     Open_streams 打开流的数量(主要用于日志记载）   Opened_tables 已经打开的表的数量。     Questions 发往服务器的查询的数量。   Slow_queries 要花超过long_query_time时间的查询数量。   Threads_connected 当前打开的连接的数量。   Threads_running 不在睡眠的线程数量。   Uptime 服务器工作了多少秒。  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows下进入命令行&quot;&gt;&lt;a href=&quot;#Windows下进入命令行&quot; class=&quot;headerlink&quot; title=&quot;Windows下进入命令行&quot;&gt;&lt;/a&gt;Windows下进入命令行&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh 用户名@ip地址  
或者 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java的文件和时间操作</title>
    <link href="http://yoursite.com/2018/09/25/java%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/25/java的文件操作/</id>
    <published>2018-09-25T14:37:09.000Z</published>
    <updated>2018-09-25T15:55:52.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><h3 id="构造函数有："><a href="#构造函数有：" class="headerlink" title="构造函数有："></a>构造函数有：</h3><pre><code>传入相对路径（一个参数）  传入绝对路径（一个参数）  File类指定为当前文件的父级，当前文件的名称（两个参数）  </code></pre><h2 id="文件删除读写改名"><a href="#文件删除读写改名" class="headerlink" title="文件删除读写改名"></a>文件删除读写改名</h2><pre><code>File file = new File(&quot;hello.txt&quot;);//对于工程而言用相对路径，创建在根目录下。也可以用绝对路径指定文件夹  //File file = new File(&quot;bin/hello.txt&quot;);工程文件夹下的bin文件夹的hello.txt文件  //File file = new File(&quot;../hello.txt&quot;);工程文件夹的上一级文件中新建hello.txt文件  if(file.exists()){      System.out.printlen(file.isFile());//判断文件是文件      System.out.println(file.isDirectory());//判断文件是文件夹      File nameto = new File(&quot;new name .txt&quot;);      file.renameTo(nameto);//将file的名字改为nameti的名字      File nameto1 = new File(&quot;src/new name.txt&quot;);      file.renameTo(nameto1);//将文件移动到src目录下      file.delete();//删除文件  }else{      System.out.println(&quot;文件不存在&quot;);      try{          file.createNewFile();          System      }catch(IOException e){//抛出异常          e.printStackTrace();          System.out.println(&quot;文件无法创建&quot;);      }  }  </code></pre><h3 id="测试样例，用于文件的读取"><a href="#测试样例，用于文件的读取" class="headerlink" title="测试样例，用于文件的读取"></a>测试样例，用于文件的读取</h3><p>新建一个test.txt文件，内容随意。</p><pre><code>File file = new File(&quot;text.txt&quot;);if(file.exitst()){    try{        FileInputStream fis = new FileInputStream(file);//属于字节流        InputStreamReader isr = new InputStreamReader(fis. &quot;UTF-8&quot;);//属于字符流，在字节转换为字符的时候，需要指定编码，否则可能会出现乱码。        BufferedReader br = new BufferedReader(isr);//带有缓冲区的reader        String line;//用于存放临时数据        while ((line = br.readLine()) != null){            System.out.println(line);//输出读取的一行        }        关闭输入流，先打开的后关闭，后打开的先关闭。        br.close();        isr.close();        fis.close();    }catch (FileNotFoundException e){        该异常对应于 FileInputStream    }catch (UnsupportedEncodingException e){        该异常对应于 InputStreamReader    }catch (IOException e){        该异常对应于 ***.close()    }}</code></pre><h3 id="测试样例，用于写入文件"><a href="#测试样例，用于写入文件" class="headerlink" title="测试样例，用于写入文件"></a>测试样例，用于写入文件</h3><pre><code>File newfile = new File(&quot;newtest.txt&quot;);try{    FileOutPutStream fos = new FileOutputStream(newfile);    OutPutStreamWriter osw = new OutPutStream(fos, &quot;UTF-8&quot;);    BufferedWriter bw = new BufferedWriter(osw);    bw.write(&quot;你要写入的内容&quot;);    。。。。。。。    bw.close();    osw.close();    fos.close();    //同样，先打开的后关闭，后打开的先关闭。}</code></pre><h2 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h2><pre><code>File类可以表示文件或者文件夹，但是两者之间的是有区别的File folder = new File(&quot;my new folder&quot;);// folder.createNewFile()  使用该方法创建的是一个文件，只是文件没有后缀罢了folder.mkdir();//创建一个文件夹，返回值是一个bool类型，true为创建成功，false为失败//如果 已经存在 名为 “my new folder”的文件夹，则创建失败。也就是说不能出现同名的文件或者文件夹</code></pre><p><code>如果使用mkdir()，那么创建的文件夹必须是物理上存在的文件夹，也就是说，如果创建“one/two/test”这样的文件夹，但是 不存在one文件夹，那么是不会自动补全路径的。这时候我们就需要用 mkdirs()，也就是 file.mkdirs()这个语句。</code></p><pre><code>//文件夹给名字的方法跟文件改名字的方法类似File folder = new File(&quot;my new folder&quot;);File newfolder = new File(&quot;new folder&quot;);folder.renameTo(newfolder);//返回的是一个bool类型的值，可以通过if判断是否修改成功//用这种方式修改文件夹的名字forlder.delete();//删除文件夹，但是只能删除空文件夹</code></pre><p><code>在windows中，千万注意移动文件夹不要跨盘移动，否则失败。因为Windows的文件系统是森林格式，而Linux和Mac系统是数状的</code></p><h2 id="一些判断获取语句"><a href="#一些判断获取语句" class="headerlink" title="一些判断获取语句"></a>一些判断获取语句</h2><pre><code>File file = new File(&quot;test.txt&quot;);//判断文件是否存在    file.exists();//读取文件名称    file.getName();//读取文件相对路径    file.getPath();//读取文件的绝对路径    file.getAbsolutePath();//读取文件父级路径    file.getParent();//读取文件大小（字节）    file.length();//判断文件是否被隐藏（Linux和unix中，文件以 &quot; . &quot;开头代表隐藏）    file.isHidden();//判断文件是否可读    file.canRead();//判断文件是否可写    file.canWrite();//判断文件是否为文件夹    file.isDirectory();//当程序退出时将文件删除    file.deleteOnExit();</code></pre><h2 id="设置文件属性："><a href="#设置文件属性：" class="headerlink" title="设置文件属性："></a>设置文件属性：</h2><pre><code>File file = new File(&quot;test.file&quot;);//设置为可写    file.setWritable(true);//传入 true 则设置文件可写，否则设置为不可写//设置为可读    file.setReadable(true);//与上述相同。//设置为只读    file.setReadOnly();</code></pre><h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><pre><code>public static void printfFiles(File dir){{    if( dir.isDirectory() ){        File next[] = dir.listFiles();        for( int i = 0; i&lt;next.length; i++){            if( next[i].ifFile() ){//输出文件的名字                System.out.println(next[i].name);            }else{//递归的输出文件的名字                printfFiles(next[i]);            }        }    }}</code></pre><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><p>Date表示时间，日期。但是更新jdk之后就不推荐使用了。<br>官方解释是 使用Date类<code>不利于国际化</code>。所以jdk1.1版本后推荐使用Calendar类。使用DateFormat类进行时间日期的格式化。Long类型表示时间类型。String类型表示时间日期类的显示。 </p><pre><code>Date.getTime();//获取Date对象的时间  Date.setTime(long time);//设置Date的时间  Calendar rightnow = Calendar.getInstance();//获取当前时间  long now = System.currentTimeMillis();//获得系统的当前时间，但是这个时间只有机器能读懂Date d1 = new Date(now);// 获取人能够读懂的时间  Calendar c1 = Calendar .getInstance();  System.out.print(c1.getTime().toString());//获得人能够读懂的时间  </code></pre><p><code>String -&gt; 时间  &amp;&amp; 时间 -&gt; String</code></p><pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//指定日期的格式  sdf.format(date);//将Date类型转换为指定格式的String类型，返回的是一个String类型  sdf.parse(&quot;2015-06-01&quot;);//将String转换为Date类型，返回的是一个Date类型  //SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); 时间格式为 年月日  时分秒  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;File-类&quot;&gt;&lt;a href=&quot;#File-类&quot; class=&quot;headerlink&quot; title=&quot;File 类&quot;&gt;&lt;/a&gt;File 类&lt;/h2&gt;&lt;h3 id=&quot;构造函数有：&quot;&gt;&lt;a href=&quot;#构造函数有：&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2018/09/25/Git/"/>
    <id>http://yoursite.com/2018/09/25/Git/</id>
    <published>2018-09-25T07:47:09.511Z</published>
    <updated>2018-09-25T08:15:03.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git的起源"><a href="#Git的起源" class="headerlink" title="Git的起源"></a>Git的起源</h2><p>linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bitkeep说开源社区中的一个成员对bitkeep的协议进行逆向工程。因此，自己写了git。</p><p><code>SVN</code>-&gt;<code>集中式版本控制系统</code>：只有中央服务器有版本的数据库，其他电脑没有，所有版本控制都要通过中央服务器进行交互。（要是中央服务器当机离线，则就出大问题了）<br><code>git</code>-&gt;<code>分布式版本控制</code>：每一个台电脑上面都有一个版本的database。由于每台电脑都有数据库，所以大多数操作可以离线进行。支持比较多的控制模式-也可以安装一个中央服务器。  </p><ol><li>git每个版本存储的都是当前版本的所有内容，不需要与其他版本进行差异比较之后再进行文件的合成。  </li><li>git可以离线完成大部分操作。  </li><li>git有更优雅的分支和合并实现。  </li><li>git有更强大撤销修改和修改版本历史的能力。  </li><li>git速度更快，效率更高。</li></ol><h2 id="为什么学习git："><a href="#为什么学习git：" class="headerlink" title="为什么学习git："></a>为什么学习git：</h2><p>研究GitHub<br>越来越多的公司通过git调整</p><h2 id="git如何存储文件，历史记录："><a href="#git如何存储文件，历史记录：" class="headerlink" title="git如何存储文件，历史记录："></a>git如何存储文件，历史记录：</h2><p><code>git通过40个16进制字符的SHA-1 Hash 来唯一标识对象</code> 例如：     e98757d0598ab6eeaf1df0d87dd00826048bd80b<br>git有<code>四种对象</code>：  </p><pre><code>1. blob：文本文件或者二进制文件或者链接文件  2. tree：目录  3. commit：历史提交      4. tag：指向固定的历史提交  (-&gt;）指向的意思  </code></pre><p><code>tag</code>  <code>-&gt;</code>  <code>commit</code>  <code>-&gt;</code>  <code>tree</code>  <code>-&gt;</code>  <code>多个tree对象或者多个blob对象</code><br>对工作区的这些内容进行SHA-1 Hash 之后，就可以得到唯一标识。<br>如果两个文件内容是相同的，则他们指向同一个blob对象。而文件名这种信息会存在tree对象中。  </p><p>有了git对象之后，需要git仓库去存储对象，和操作对象。<br>git init   git clone  两种方法获取仓库。<br><img src="https://i.imgur.com/InyuRGB.png" alt=""><br>cd 到.git 文件夹中 （GIT_DIR!）-&gt; git工作区间     用 ls 查看git需要的文件<br>再退出来<br>用init方法创建一个裸仓库。然后查看仓库中有什么。<br>git init –bare git_bare_repo<br>通过–bare 方法创建一个 git_bare_repo 文件夹。这个文件夹只有git工作需要的文件。<br>git clone 克隆出一个仓库 一般来说需要远程裸仓库的地址<br>git clone git_bare_repo/ git_clone_repo （复制之前创建的本地仓库，并创建在文件夹  git_clone_repo中）  </p><h2 id="git分为三个区域："><a href="#git分为三个区域：" class="headerlink" title="git分为三个区域："></a>git分为三个区域：</h2><blockquote><ol><li>working directory（工作区，日常编辑代码的地方）  </li><li>staging area（暂存区，工作区与历史提交的缓存，维护的是虚拟的树形结构）  </li><li>history repository（历史仓库）   </li></ol></blockquote><p>（1）工作区  添加文件到  暂存区  提交整个暂存区的状态   历史纪录区<br>（2）历史记录区   检出文件到   暂存区和工作区<br>大部分时间我们都在做第一个工作<br>对应的就是 <code>git add（到暂存区）</code>  和  <code>git commit（到历史记录区）</code><br>    git status（查看工作区和暂存区的区别，确保提交是我们所需要的）<br>    git rm（从暂存区删掉我们不需要的东西）<br>    git mv（移动文件）<br>    gitignore（确保不想添加到暂存区和历史纪录区的文件不被添加）  </p><blockquote><p>先 创建  a b 两个文件<br>    touch a<br>    touch b<br>然后添加到暂存区<br>    git add a b<br>查看一下<br>    git status<br>提交到历史纪录<br>    git commit -m “initial commit” （加入一个提交的历史信息）<br>修改一下a<br>    vim a（加入一些文字信息）<br>再看一下 git status<br>    提示 a 修改了 但是没有提交到暂存区<br>提交a到暂存区中<br>    git add a<br>再status 看一下<br>    git status<br>再提交 a 就行<br>    git commit -m “modify a”<br>删除a，会删除 工作区 ，暂存区中的a<br>    git rm a<br>还原一下a<br>    git checkout a<br>如何只删除暂存区的文件，不删除工作目录的文件<br>    git rm –cached a  </p></blockquote><p><hr><br><img src="https://i.imgur.com/tAGY09M.png" alt=""></p><blockquote><p>git status 看看就会提示有一个没有跟踪的文件<br>git mv a c （将a名字命名为c）（这个命令是一系列操作的总和）<br>    如果直接再工作区修改文件名<br>        mv a c （工作目录直接 修改名字）<br>    再 git status<br>        提示 a 被删除了 ， 有个c 的文件没有被跟踪<br>    再 git add a c（添加a c 到文件中）<br>        提示文件 a 被更改为 c<br>git add -A 添加整个工作区都暂存区<br>git .gitignore    在顶层目录下创建一个.gitignore文件<br><em>.[oa]通过通配符提示git，以 o 和 a 结尾的文件不要添加到git仓库中<br>例如：加入了  </em>.~, *.pyc ， 但是如果以.pyc为后缀的文件，有一个要加到仓库，这个时候就要在文件名上加  !test.pyc，告诉 test.pyc 不要被忽略。如果需要ingore文件名第一个字符就是“！”，就要加上”\”转义字符。<br>**/res 匹配 res，所有路径下的res，任何文件夹下的res。<br>git add .gitignore<br>git commit -m “add ingore”//添加到仓库中，用于整个仓库的共享  </p></blockquote><h2 id="git暂存区"><a href="#git暂存区" class="headerlink" title="git暂存区"></a>git暂存区</h2><blockquote><p>.git/objects 对象库<br>当执行 git add 命令时，.git 目录下多了一个index文件，整个index文件就是暂存区，每条索引有个的四十位的十六进制的SHA-1 Hash，文件模式，权限，时间戳等。每个索引都对应对象库中的某个对象对应。<br>除了索引之外，还维护了提前计算好的tree对象的内容。当我们提交的时候，可以直接通过提前计算好的，直接生成索引等内容。<br>当文件名更改时，根据文件内容所计算出来的SHA-1 也不会变。<br>暂存区索引每次更新的时候，都会重新计算index 和暂存区的内容。  </p></blockquote><h2 id="git本地分支与合并"><a href="#git本地分支与合并" class="headerlink" title="git本地分支与合并"></a>git本地分支与合并</h2><pre><code>git branch（创建分支)  git tag（给commit做标记）  git checkout（分支之间的切换）  git stash（切换分支之前保存本地修改）  git merge（合并分支）</code></pre><blockquote><p>例如：git branch test  新建分支 test。但是只是新建，要切换过去才能使用<br>git checkout test 切换到test分支。<br>test分支做的修改，不会影响到master分区的工作。也就是说分支互不影响。</p></blockquote><pre><code>tag 分 轻量级 本地引用  和 annotady 带注解的tag通过 git log --online --decorate --graph -all 查看hash值，以及提交，查看历史示意图  git tag &quot;v0&quot; a1abda30   （a1abda30 就是上述命令查出的hash值）  git tag -a &quot;INITAL_COMMIT&quot; a1abda30   标注tag，提示输出tag信息。  git tag 查看以有的设置过的tag  git config --global alias.lol &quot;log --oneline --decorate --graph --all&quot; 用 git lol 代替 log --oneline --decorate --graph --all  git show v0 （v0是一个tag的名字）  </code></pre><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>提供个人或者企业的代码托管。可以查看其他的开源项目托管。<br><img src="https://i.imgur.com/qDXMcAv.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git的起源&quot;&gt;&lt;a href=&quot;#Git的起源&quot; class=&quot;headerlink&quot; title=&quot;Git的起源&quot;&gt;&lt;/a&gt;Git的起源&lt;/h2&gt;&lt;p&gt;linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <link href="http://yoursite.com/2018/09/25/ACM-Icpc-%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B/"/>
    <id>http://yoursite.com/2018/09/25/ACM-Icpc-徐州网络赛/</id>
    <published>2018-09-25T05:38:47.873Z</published>
    <updated>2018-09-25T06:54:20.219Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time Limit: 1000ms       Memory Limit: 262144KB</span><br></pre></td></tr></table></figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p> Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256, which can transit a string into just 256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string s, s[i] represents the i th character in the string)we calculates the value(|(int) L – s[i]|), and write down the number(keeping leading zero. The length of each answer equals to 2 because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(s)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “11 45 14”.  It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p> First line a integer T, the number of test cases(T &lt;= 10)  For each test case:  First line contains a integer N and a character z, (N &lt;= 1000000)  Second line contains a string with length N. Problem makes sure that all characters referred in the problem are only letters. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p> A single number which gives the answer. </p><h3 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h3><p>2<br>3 z<br>oMl<br>6 Y<br>YJSNPI </p><h3 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h3><p>6<br>10 </p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mur喜欢哈希算法，他有时加密另一个人的名字，然后用加密值给他打电话。例如，他打电</span><br><span class="line">话给Kimura KMR，并打电话给Suzuki YJSNPI。有一天，他读了一本关于SHA-256的</span><br><span class="line">书，它可以将字符串转换成256位。 Mur认为这很酷，他想出了一个新的算法来完成类似的</span><br><span class="line">工作。算法以这种方式工作：首先我们选择单个字母L作为种子，对于输入（您可以将输入</span><br><span class="line">视为字符串s，s [i]表示字符串中的第i个字符）我们计算值（ |（int）L - s [i] </span><br><span class="line">|），并记下数字（保持前导零。每个答案的长度等于2，因为字符串只包含字母和数字）。</span><br><span class="line">数字从左到右写入，最后将所有数字转换为单个整数（不带前导零）。例如，如果我们选</span><br><span class="line">择&apos;z&apos;作为种子，则字符串“oMl”变为“11 45 14”。很容易发现该算法无法将任何输入字</span><br><span class="line">符串转换为相同的长度。虽然在绝望中，Mur仍然想知道算法产生的答案的长度。由于穆尔</span><br><span class="line">的愚蠢，他甚至无法弄清楚这一点，所以你被分配了计算答案的工作。</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p> 第一行是整数T，测试用例数（T &lt;= 10）对于每个测试用例：第一行包含整数N和字符z，（N &lt;= 1000000）第二行包含长度为N的字符串。确保问题中提到的所有字符都只是字母。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p> 一个数字给出了答案。</p><h3 id="样本输入"><a href="#样本输入" class="headerlink" title="样本输入"></a>样本输入</h3><p>2<br>3 z<br>oMl<br>6 Y<br>YJSNPI</p><h3 id="样本输出"><a href="#样本输出" class="headerlink" title="样本输出"></a>样本输出</h3><p>6<br>10</p><blockquote><p>水题，但是特别坑。<br>这里先讲第二个样例： 减出来的结果是  00  15  06  11  09  16<br>这样去除前面的0，得出来的结果就是1506110916，这10位<br>如果全部都是0呢 比如 <br>4 z<br>zzzz<br> 这个时候就要输出 1 而不是 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">int len;</span><br><span class="line">char Seed, s;</span><br><span class="line">cin &gt;&gt; len &gt;&gt; Seed;</span><br><span class="line">        bool flag = false, fir = true;</span><br><span class="line">for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">int t = Seed - s;</span><br><span class="line">t = abs(t);</span><br><span class="line">            if(t != 0)</span><br><span class="line">                flag = true;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">                if(fir)&#123;</span><br><span class="line">                    if(t &gt;= 1 &amp;&amp; t &lt;= 9)</span><br><span class="line">                        sum += 1;</span><br><span class="line">                    else </span><br><span class="line">                        sum += 2;</span><br><span class="line">                    fir = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else sum += 2;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        if(flag == false)</span><br><span class="line">            sum = 1;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p> Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge a[i]. Unfortunately, the longer he learns, the fewer he gets. That means, if he reads books from l to r, he will get a[l]<em>L+a[l+1]</em>(L-1)+…+a[r1]*2+a[r] (L is the length of [l, r] that equals to r-l+1).  Now Ryuji has q questions, you should answer him: 1. If the question type is 1, you should answer how much knowledge he will get after he reads books [l, r] 2. If the question type is 2, Ryuji will change the ith book’s knowledge to a new value. </p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p> First line contains two integers n and q (n, q &lt;= 100000).  The next line contains n integers represent a<a href="a[i] &lt;= 1e9">i</a>  Then in next q line each line contains three integers a, b, c, if a = 1, it means question type is 1, and b, c represents [l, r]. if a = 2, it means question type is 2, and b, c means Ryuji changes the bth book’ knowledge to c. </p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p> For each question, output one line with one integer represent the answer.<br>Sample Input<br>5 3<br>1 2 3 4 5<br>1 1 3<br>2 5 0<br>1 4 5 </p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>10<br>8 </p><h2 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译"></a>翻译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Ryuji不是一个好学生，他不想学习。 但他应该学习n本书，每本书都有自己的知识[i]。 不幸的是，他学的越久，得到的就越少。</span><br><span class="line">   这意味着，如果他从l到r读书，他将获得a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]（L 是[l，r]的长度，等于r-l + 1）。 现在Ryuji有q问题.</span><br><span class="line">   你应该回答他： </span><br><span class="line">    1。如果问题类型是1，你应该回答他读书后会得到多少知识[l，r]</span><br><span class="line">    2.如果问题类型是2，Ryuji会改变 ith书对新价值的认识。</span><br><span class="line"> </span><br><span class="line">输入</span><br><span class="line">  第一行包含两个整数n和q（n，q &lt;= 100000）。 </span><br><span class="line">  下一行包含n个整数表示a [i]（a [i] &lt;= 1e9） </span><br><span class="line">  然后在下一个q行中每行包含三个整数a，b，c， </span><br><span class="line">  如果a = 1，则表示问题类型为1，b ，c代表[l，r]。 </span><br><span class="line">  如果a = 2，则表示问题类型为2，b，c表示Ryuji将bth book的知识更改为c。</span><br></pre></td></tr></table></figure><p>这里我维护的两个数组。一个是输入的数组x，另一个是数组z。<br>定义数组<code>z[i] = x[i] * (n-i+1)（i从1开始）</code><br>然后定义两个数组 y 和 shu。其中 y数组用于维护x，shu数组用于维护z。<br>这个解释一下z数组的用途，以及如何维护z数组。<br>题目求的是<code>a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]</code>，如果暴力求解绝对超时。所以有个z数组。<br>用样例来说：<br>输入的 1 2 3 4 5<br>那么 x 数组中就是  1 2 3 4 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z 数组中就是 5 8 9 8 5<br>求 1~3 的和。那么如果直接加上 z[1~3] ，那么就是a[1]<em>5 + a[2]</em>4 + a[3]<em>3。但是题目要求的是  a[1]</em>3+a[2]<em>2+a[3]</em>1，也就是减去2倍的(a[1]+a[2]+a[3])。而这个2倍其实就是 区间 （l，r）中r距离尾部的单位值。这里是5 - 3 = 2。<br>上面的例子很容易发现 z 数组的用途，提前预处理了题目要求的<code>a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]</code>。如此一来就可以用0（1）的时间求出要求的值，而不需要遍历。<br>再来看，题目有两种状态一个是区间求和，另一个是修改值。碰到这种题目很容易想到的就是树状数组或者线段树，我这里用的是树状数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sm = 400000+10;</span><br><span class="line">long long int x[sm];</span><br><span class="line">long long int n, q;</span><br><span class="line">long long int z[sm];// x存n个数，z ai*(n-i) i 从0 开始 </span><br><span class="line">long long int y[sm], shu[sm];// y 求区间和， 树状数组</span><br><span class="line"></span><br><span class="line">long long int lowbit(int x)&#123;</span><br><span class="line">return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long find_sum(long long int i, long long zu[])&#123;//区间求和 </span><br><span class="line">long long int ret =0 ;</span><br><span class="line">for(; i&gt;0 ; ret += zu[i], i -= lowbit(i));</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(long long int i, long long int val, long long zu[])&#123;//建树, 更新值 </span><br><span class="line">for(;i &lt;= n; zu[i] += val, i += lowbit(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">for(int i =1 ; i&lt;=n; i++)</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">update(i, x[i], y);//建立y，维护x数组</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">z[i] = x[i] * (n-i+1);</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">update(i, z[i], shu);//建立shu，维护z数组</span><br><span class="line"></span><br><span class="line">for(int i=1; i&lt;=q; i++)</span><br><span class="line">&#123;</span><br><span class="line">long long int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if(t == 1)&#123;</span><br><span class="line">long long int l, r, suml, sumr;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">long long int s1 = find_sum(r, shu) - find_sum(l-1, shu);//获得z数组的区间和</span><br><span class="line">long long int s2 = find_sum(r, y) - find_sum(l-1, y);//获取x数组的区间和</span><br><span class="line">cout &lt;&lt; s1 - s2*(n-r) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if(t == 2)&#123;</span><br><span class="line">long long int new_num, where;</span><br><span class="line">cin &gt;&gt; where &gt;&gt; new_num;//where代表位置，new_num代表值</span><br><span class="line">long long int mid = new_num - x[where]; </span><br><span class="line">update(where, mid, y);//更新y数组</span><br><span class="line">update(where, mid*(n - where + 1), shu);//更新shu数组</span><br><span class="line">x[where] = new_num;//更新x数组中的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>！！！！着重强调，如果用我这种方法做的人，一定要用`</code>long long<code></code> ！！！！`<br>本来觉得部分数据不大可以部分不用long long，结果不知道那块就是卡住了死交不过去，wa了四五发都是因为这个。</p><p>ACM本就是逆天而行，死在路上很正常。真的，看到别人大佬一队AK了，我才做了两题，就感觉对不起队友，对不起老师。天赋上的差距没办法，自己还是很菜，再加上最近在搭建服务器，导致算法上面没用心，最后一年了，好好搞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos 2d游戏——I wanna save the princess</title>
    <link href="http://yoursite.com/2018/09/25/cocos2dx/"/>
    <id>http://yoursite.com/2018/09/25/cocos2dx/</id>
    <published>2018-09-25T03:13:41.577Z</published>
    <updated>2018-09-27T02:14:04.750Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align: center;">基于cocos-2dx的游戏制作——I wanna save the princess</h2><p><b>在进行了两周的cocos学习之后，可以开始进行游戏的创作了。<br>I wanna主要复杂的地方在于地图的设计以及逻辑实现。下面依次进行介绍。（使用c++）</b></p><p></p><h3 style="text-align: left">一．    瓦片地图——tile map</h3><p></p><h4 style="text-align: left">1.    地图整体的大小。</h4><p>配合电脑可以全屏显示，设置为1080X1920的大小。<br><img src="https://i.imgur.com/nxXJgh7.png" alt=""></p><h4 style="text-align: left">2.    图块的大小。</h4><br><img src="https://i.imgur.com/PIXpNM7.png" alt=""><br>使用Tile map制作地图，因为它非常方便，可以将图片素材直接放到图块中，并且大小可以随意调节。<br><img src="https://i.imgur.com/XM4Csd9.png" alt=""><br><br><br><br>比如：所有的地图图块设置为30X30像素，因此普通的土块和草地都是30X30的大小。<br><img src="https://i.imgur.com/ApNK9MW.png" alt=""><br><br>但是在下面的场景中，因为水是直接在tile map中显示的，所以设置为了1920X900的大小。<br><img src="https://i.imgur.com/wUayzYq.png" alt=""><br><br><br><h4 style="text-align: left">3.    图层的设置。</h4><p>在这个界面中，可以新建多个图层，将不同属性的图块放入。<br><img src="https://i.imgur.com/yWCTAQL.png" alt=""></p><p>比如：土块和刺是分开的两个图层。<br><img src="https://i.imgur.com/ZdfvPzJ.png" alt=""></p><p><img src="https://i.imgur.com/XNNeWdU.png" alt=""><br>每一个形状的刺分别的一个图层。<br>向上的刺。<br><img src="https://i.imgur.com/F1SWGPV.png" alt=""></p><p>向左的刺。<br><img src="https://i.imgur.com/9ExyVbC.png" alt=""></p><p>隐藏的刺与可以触发的刺也是不同的图层。<br>地图上直接可见的，向上的刺。<br><img src="https://i.imgur.com/c439TCn.png" alt=""><br>并非直接可见，需要触发条件的，向上的刺。<br><img src="https://i.imgur.com/ADV21xM.png" alt=""></p><p>在图层的设置中，可以将同一属性的图层用一个新的图层覆盖，并且设置不可穿透的属性，这样在导入图层的时候会比较方便。<br><img src="https://i.imgur.com/P0Z1Y5h.png" alt=""><br>在所有不可穿透的图层中，覆盖了一层红色图层，在vs中导入的同时，设置为不可穿透。<br><img src="https://i.imgur.com/DSlwma2.png" alt=""><br>（不可穿透是利用下文中掩码的作用。）</p><h4 style="text-align: left">4.    人物图层。</h4><p>在建立图层的时候，选择添加对象层，然后选择建立矩形，在地图上的任一个地方画出任意大小的矩形，代表人物。<br><img src="https://i.imgur.com/tsLqFmW.png" alt=""><br>（相应操作在图上用红色方框表示。）</p><h4 style="text-align: left">5.    特殊图层。</h4><p>因为I wanna游戏的特殊，经常有不同的隐藏刺。这个部分首先需要在不同的图层中实现，然后需要一个对应的触发图层。</p><p>观察红色方框中图层的顺序，现在的位置是游戏地图中正常图层的位置，即土块将隐藏刺遮住了。<br><img src="https://i.imgur.com/2GKSLCB.png" alt=""></p><p>调整顺序后可以看到隐藏刺。<br><img src="https://i.imgur.com/zQZWbdh.png" alt=""></p><p>地图中红色图层的作用是，判断人物当前的位置x坐标是否与此图层中的某一个相同，相同则触发刺向上飞的事件。<br><img src="https://i.imgur.com/yf5xcJK.png" alt=""></p><p>这个触发图层的作用是，在地图中，人物在触碰到这个图层的同时，触发对应tag中的事件，比如让刺飞出，或是在踩到触发图层时冒出。</p><p><img src="https://i.imgur.com/gGIJNJK.png" alt=""><br>导入的图层为上一张图片中的yincang图层，设置tag为4。<br><img src="https://i.imgur.com/8UA4TaN.png" alt=""></p><p>人物的tag为1，当两个物体的tag分别为1和4的时候，触发事件。<br><img src="https://i.imgur.com/Tjxnvns.png" alt=""></p><p>在导入隐藏刺的同时设置冒出的移动，当人物与刺所在的图块接触，刺冒出。<br><img src="https://i.imgur.com/LSQgR0s.png" alt=""></p><p>触发刺飞出的事件。<br><img src="https://i.imgur.com/cUsSdHQ.png" alt=""></p><p></p><h3 style="text-align: left">二．    物理引擎</h3><p></p><h4 style="text-align: left">1．    建立物理世界。</h4><br><img src="https://i.imgur.com/I2FgNHO.png" alt=""><br><br><br><br><h4 style="text-align: left">2．    重力的添加以及改变。</h4><p>添加在创建物理世界时写入。<br>在第三个场景的水中，需要更改重力的大小。<br><img src="https://i.imgur.com/U22rqfa.png" alt=""></p><h4 style="text-align: left">3．    添加不同的刚体。</h4><p>普通的刚体，是矩形的。<br><img src="https://i.imgur.com/mHgHJV6.png" alt=""></p><p>因为刺是三角形的，所以需要建立一个数组存储三角形的三个顶点坐标，然后再附给物体，这样就是一个三角形的刚体。<br><img src="https://i.imgur.com/lAvxPE3.png" alt=""></p><h4 style="text-align: left">4．    介绍三种掩码。</h4><p>类别掩码setCategoryBitMask，接触检测掩码setContactTestBitmask，碰撞掩码setCollisionBitmask。<br>分别将两个物体的类别掩码与接触检测掩码进行逻辑与运算，可以判断是否触发接触事件，类似的，可以判断是否穿透或者碰撞。</p><p>人物的三种掩码。<br><img src="https://i.imgur.com/Osfqstw.png" alt=""></p><h4 style="text-align: left">5．    重新开始。</h4><p>将当前场景舍弃，重新生成一个新的场景，进行替换。<br><img src="https://i.imgur.com/X5PN8wP.png" alt=""></p><h4 style="text-align: left">6．    键盘事件。</h4><p>人物可以进行向左前进，向右前进，跳跃这三种动作，在此函数中，按下不同的键实现不同的事件。<br><img src="https://i.imgur.com/HsIWwV6.png" alt=""></p><p><img src="https://i.imgur.com/TUX2A2C.png" alt=""></p><h4 style="text-align: left">7．    标签的添加。</h4><p>在导入图层的时候就分别设置不同的tag，以便于在函数中进行相应的判断。<br><img src="https://i.imgur.com/lSDe7rU.png" alt=""></p><p>人物与刺碰撞，触发游戏结束的事件，在界面中添加游戏结束的图片，并且取消键盘事件，但可以按R键重新开始。（所有的刺tag都为3）<br><img src="https://i.imgur.com/k7Cmekz.png" alt=""></p><p>在最后切换场景时，有一个被隐藏了的触发图层，在人物接触到的同时进行tag的比较，从而可以切换场景。<br><img src="https://i.imgur.com/FONa3EU.png" alt=""><br><img src="https://i.imgur.com/uuU7qTS.png" alt=""><br><img src="https://i.imgur.com/MmH6mhx.png" alt=""></p><h4 style="text-align: left">8．    计时器函数</h4><p>进行场景中物理引擎的手动更新。<br><img src="https://i.imgur.com/lVQVhFL.png" alt=""></p><h4 style="text-align: left">9．    碰撞检测。</h4><p>利用三种掩码进行判断。<br>人物与土块。（人物的掩码在上方，三个都是7）<br><img src="https://i.imgur.com/dCYH27I.png" alt=""><br>（这个图层就是上方介绍过的覆盖图层）<br>进行判断后为不可穿透。</p><p>人物与水。<br><img src="https://i.imgur.com/VYZNULt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 style=&quot;text-align: center;&quot;&gt;基于cocos-2dx的游戏制作——I wanna save the princess&lt;/h2&gt;

&lt;p&gt;&lt;b&gt;在进行了两周的cocos学习之后，可以开始进行游戏的创作了。&lt;br&gt;I wanna主要复杂的地方在于地图
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/25/hello-world/"/>
    <id>http://yoursite.com/2018/09/25/hello-world/</id>
    <published>2018-09-25T00:51:53.263Z</published>
    <updated>2018-09-25T00:51:53.263Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
