<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lc_love_myh</title>
  
  <subtitle>&lt;b style=&quot;background-color:white;&quot; &gt;往后余生 心底温柔是你，目光所至也是你。&lt;/b&gt;</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-14T08:44:25.844Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lc_love_myh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0开始的JavaWeb---java篇</title>
    <link href="http://yoursite.com/2018/10/13/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb-java%E7%AF%87/"/>
    <id>http://yoursite.com/2018/10/13/从0开始的JavaWeb-java篇/</id>
    <published>2018-10-13T02:12:37.000Z</published>
    <updated>2018-10-14T08:44:25.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件系统体系结构"><a href="#软件系统体系结构" class="headerlink" title="软件系统体系结构"></a>软件系统体系结构</h2><h3 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h3><pre><code>1. B/S结构即浏览器/服务器（Browser/Server）</code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><pre><code>只需要编写服务器端程序</code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre><code>安全性差</code></pre><h3 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h3><pre><code>1. C/S 结构即 客户端/服务器（Client/Server），例如QQ2. 需要编写服务器程序，以及客户端程序，例如我们安装的就是QQ的客户端</code></pre><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><pre><code>软件更新时需要同时更新客户端和服务器两端，比较麻烦</code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><pre><code>安全性比较好</code></pre><h3 id="Web资源"><a href="#Web资源" class="headerlink" title="Web资源"></a>Web资源</h3><h4 id="Web资源介绍"><a href="#Web资源介绍" class="headerlink" title="Web资源介绍"></a>Web资源介绍</h4><pre><code>1. html：静态资源2. Jsp/Servlet：动态资源当然除了JavaWeb程序，还有其他Web程序，例如：ASP，PHP等。</code></pre><h4 id="静态资源和动态资源的区别"><a href="#静态资源和动态资源的区别" class="headerlink" title="静态资源和动态资源的区别"></a>静态资源和动态资源的区别</h4><p><img src="https://i.imgur.com/6CCQ2RM.png" alt=""></p><h4 id="访问Web资源"><a href="#访问Web资源" class="headerlink" title="访问Web资源"></a>访问Web资源</h4><pre><code>打开浏览器，输入URL：    协议名：//域名：端口/路径，例如：https://www.baidu.com:8080/index.html</code></pre><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><pre><code>Web服务器的作用时接收客户端的请求，给客户端做出响应。对于JavaWeb程序而言，还需要有Jsp/Servlet容器，Jsp/Servlet容器的基本功能是把动态资源转会为静态资源，当然Jsp/Servlet容器不知这些功能。我们需要使用的是Web服务器和Jsp/Servlet容器，通常这两者会集于一身。下面是对JavaWeb的服务器：    1. Tomcat(Apache):当前应用最广的JavaWeb服务器    2. JBoss(RedHat红帽):支持JavaEE，应用比较广    3. GlassFlsh(Orcale):ORacle开发JavaWeb服务器，应用不是很广    4. Resin(Caucho)：支持JavaEE，应用越来越广    5. Weblogic(Orcale):要钱的！支持JavaEE，适合大型项目    6. Websphere（IBM）：要钱的！支持JavaEE，适合大型项目</code></pre><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="Tomcat简述"><a href="#Tomcat简述" class="headerlink" title="Tomcat简述"></a>Tomcat简述</h4><pre><code>Tomcat服务器由Apache提供，开源免费。由于Sun和其他公司参与到了Tomcat的开放中，所以最新的Jsp/Servlet规范总是能在Tomcat中体现出来。</code></pre><h4 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><h5 id="tomcat的安装"><a href="#tomcat的安装" class="headerlink" title="tomcat的安装"></a>tomcat的安装</h5><pre><code>自行百度</code></pre><h5 id="tomcat端口改变"><a href="#tomcat端口改变" class="headerlink" title="tomcat端口改变"></a>tomcat端口改变</h5><pre><code>自行百度</code></pre><h5 id="tomcat配置"><a href="#tomcat配置" class="headerlink" title="tomcat配置"></a>tomcat配置</h5><pre><code>自行百度</code></pre><h5 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h5><p><img src="https://i.imgur.com/J24crxY.png" alt=""></p><pre><code>/work    tomcat把由jsp生成的servlet放于目录下/webapps    当发布web应用时，默认情况下把web应用文件放于次目录下/logs    存放tomcat的日志文件/share/lib    存放所有web应用都可以访问的jar文件/common/lib    存放tomcat服务器以及所有web应用都可以访问的jar应用/server/webapps    存放tomcat自带的两个web应用：admin应用和manager应用/server/lib        存放tomcat服务器所需的jar文件/server        包含三个子目录：classes。lib和webapps/conf    存放tomcat服务器的各种配置文件，其中最重要的文件是server.xml/bin    存放Windows平台以及linux平台上启动和关闭tomcat的脚本文件</code></pre><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><h4 id="创建一个静态网站"><a href="#创建一个静态网站" class="headerlink" title="创建一个静态网站"></a>创建一个静态网站</h4><pre><code>1. 在webapps目录下创建一个目录（命名必须不包含中文和空格），这个目录则为项目目录2. 在项目目录下创建一个html文件</code></pre><h4 id="创建一个动态网站"><a href="#创建一个动态网站" class="headerlink" title="创建一个动态网站"></a>创建一个动态网站</h4><pre><code>1. 在webapps目录下创建一个项目目录2. 在项目目录下创建如下内容    1. WEB-INF目录        1. WEB-INF目录下创建web.xml文件            1. xml文件中的内容，可以从其他的项目中复制        2. 创建一个lib目录，用户存放jar包        3. classes目录，用于存放自己写的class    2. 创建静态或动态页面WEB-INF下的项目，浏览器是不能访问的，所以为了安全起见，所以一些文件必须放到WEB-INF文件</code></pre><h4 id="配置外部应用"><a href="#配置外部应用" class="headerlink" title="配置外部应用"></a>配置外部应用</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><pre><code>conf/server.xml:打开server.xml文件，找到&lt;Host&gt;元素，在其中添加&lt;Context&gt;元素：    &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot;            unpackWARs=&quot;true&quot; autoDeplay=&quot;true&quot;&gt;        &lt;Context path=&quot;hello&quot; docBase=&quot;C:/hello&quot;/&gt;    &lt;/Host&gt;1. path：制定当前应用的名称2. docBase：指定应用的物理位置3. 浏览器访问路径：http://localhost:8080/hello/index.xml</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><pre><code>conf/catalana/localhost：在该目录下创建hello.xml文件，在该文件编写&lt;Context&gt;元素    &lt;Context docBase=&quot;C:/hello&quot;&gt;1. 文件名：指定当前应用的名称2. docBase：指定应用的物理位置3. 浏览器访问路径：http://localhost:8080/hello/index.xml</code></pre><h4 id="servet-xml的配置"><a href="#servet-xml的配置" class="headerlink" title="servet.xml的配置"></a>servet.xml的配置</h4><pre><code>1. &lt;Service name=&quot;Catalina&quot;&gt;    服务，名字为catalina服务中又有很多连接 &lt;Connector&gt;2. &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;    connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt;    用于接待HTTP/1.1的服务，端口是80端口，不处理请求3. &lt;Engine&gt; 引擎，用于处理请求，引擎下又分很多主机&lt;Host&gt;4. &lt;Host name=&quot;主机名&quot; appBase=&quot;基础目录&quot;        unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;主机下又有&lt;Context&gt;上下文5. &lt;Context&gt; 上下文，对应的就是一个项目6. servet.xml中还有很多监听器7. 引擎唯一的，Service唯一的，Host可以多个，Context可以多个</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h3><pre><code>Servlet是javaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要：    1. 接收请求数据    2. 处理请求    3. 完成响应例如客户端发出登陆亲求，或者输出注册请求，这些请求都应该由Servlet来完成处理！Servlet需要我们自己来编写，每个Servlet必须实现javax.servlet.Servlet接口</code></pre><p><img src="https://i.imgur.com/uJbkkiR.png" alt=""></p><h3 id="实现Servlet的方式"><a href="#实现Servlet的方式" class="headerlink" title="实现Servlet的方式"></a>实现Servlet的方式</h3><pre><code>实现Servlet的三种方式：    1. 实现javax.servlet.Servket接口    2. 继承javax.servlet.GenericServlet类    3. 继承javax.servlet.http.HttpServlet类我们通常会去继承HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口开始</code></pre><h3 id="使用Servlet"><a href="#使用Servlet" class="headerlink" title="使用Servlet"></a>使用Servlet</h3><p><img src="https://i.imgur.com/TGsdd4W.png" alt=""></p><h4 id="servlet的方法"><a href="#servlet的方法" class="headerlink" title="servlet的方法"></a>servlet的方法</h4><pre><code>是由tomcat调用的方法1. init()    1. 在Servlet对象创建之后马上执行，并且只执行一次2. service()    1. 会被调用多次，每次处理请求都是调用这个方法3. destroy()    1. 在Servlet被销毁之前调用，并且它只会被调用一次4. getServletConfig()    1. 获取Servlet的配置信息（从init函数中，可以获得Servlet的配置信息）5. getServletInfo()    1. 获取Servlet的信息（没什么用）</code></pre><h4 id="浏览器访问Servlet"><a href="#浏览器访问Servlet" class="headerlink" title="浏览器访问Servlet"></a>浏览器访问Servlet</h4><pre><code>1. 给Servlet指定一个Servlet路径（让Servlet与一个路径绑定在一起）    1. 需要在web.xml中对Servlet配置    2.  &lt;servlet&gt;               &lt;servlet-name&gt;XXX随意&lt;/servlet-name&gt;            &lt;servlet-class&gt;Servlet的路径&lt;servlet-class&gt;        &lt;/servlet&gt;    3.  &lt;servlet-mapping&gt;            &lt;servlet-name&gt;与上面的name相同&lt;/servlet-name&gt;            &lt;url-pattern&gt;/虚拟路径 例如：/aa/b/c&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;2. 浏览器访问Servlet路径    1. localhost:8080/项目名/虚拟路径名</code></pre><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><pre><code>1. 单例，一个类只有一个对象；当然可能存在多个Servlet类2. 线程不安全的，效率高3. Servlet由程序员写，但对象由服务器创建，调用响应的方法</code></pre><p><img src="https://i.imgur.com/nMe2CKX.png" alt=""></p><p><img src="https://i.imgur.com/XTD10M9.png" alt=""></p><p><img src="https://i.imgur.com/E6X43Wh.png" alt=""></p><h3 id="Servlet细节"><a href="#Servlet细节" class="headerlink" title="Servlet细节"></a>Servlet细节</h3><h4 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h4><pre><code>因为一个类型的Servlet只有一个实例对象，那么就有可能会出现同一个时间一个Servlet同属处理多个请求 那么Servlet是否为线程安全呢？ 答案是“不是线程安全的”这说明Servlet的工作效率很高，但也存在线程安全问题所以我们不应该在Servlet中随意创建成员变量因为可能会存在一个线程这个成员变量进行写操作，另一个线程对这个成员变量进行读操作1. 不要在Servlet中创建成员！创建局部变量即可2. 可创建无状态成员3. 可以创建有状态成员，但是状态必须为只读的</code></pre><h4 id="让服务器在启动时就创建Servlet"><a href="#让服务器在启动时就创建Servlet" class="headerlink" title="让服务器在启动时就创建Servlet"></a>让服务器在启动时就创建Servlet</h4><pre><code>默认情况下，服务器在某个Servlet第一次收到请求时创建它，也可以在web.xml中进行配置，使服务器启动的时候就创建Servlet&lt;servlet&gt;    &lt;servlet-name&gt;hello1&lt;/servlet-name&gt;    &lt;servlet-class&gt;cn.itcast.servlet.HelloWorld&lt;servlet-class&gt;    &lt;load-on-startup&gt;非负整数&lt;/load-on-startup&gt;    &lt;!-- 非负数，越小越先创建 --&gt;&lt;servlet&gt;</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a><url-pattern></url-pattern></h4><pre><code>&lt;url-pattern&gt;是&lt;servlet-mapping&gt;的子元素，用来指定Servlet的访问路径，即URL它必须是以 &quot;/&quot; 开头&lt;servlet-mapping&gt;    &lt;servlet-name&gt;text&lt;/servlet-name&gt;    &lt;url-pattern&gt;/a&lt;/url-pattern&gt;    &lt;url-pattern&gt;/b&lt;/url-pattern&gt;    &lt;url-pattern&gt;/c&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;那么说明这个Servlet绑定了多个url，一般也就一个，你设置多个也没什么用</code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><pre><code>一个项目只有一个ServletContext对象！application我们可以在N个Servlet中获取这个唯一的对象，使用它可以给多个Servlet传递数据Servlet之间互不一般是互不联系的，所以信息传递只能通过ServletContext</code></pre><h4 id="servletContext概述"><a href="#servletContext概述" class="headerlink" title="servletContext概述"></a>servletContext概述</h4><pre><code>服务器会为每个应用创建一个ServletContext对象：1. ServletContext 对象的创建时在服务器启动时完成2. ServletContext 对象的销毁时在服务器关闭时完成ServletContext对象的作用是在整个Web应用的动态资源之间共享数据！例如：    在A_Servlet中项 ServletContext对象中保存一个值，然后再B_Servlet中就可以获取这个值，这就是共享数据</code></pre><h4 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h4><pre><code>在Servlet获取ServletContext对象：1. 在 void init(ServletConfig config)中：ServletContext context = config.getServletContext();在GenericeServlet 或 HttpServlet 中获取ServletContext对象：1. GenericSeriet类中由getServletContext()方法，所以可以直接使用this.getServletContext()来获取2. HttpServlet中有getServletContext()方法获取在ServletContextEvent中1. getServletContext()方法获取在HttpSession中1. getServletContext()方法获取</code></pre><h4 id="设置，获取对象"><a href="#设置，获取对象" class="headerlink" title="设置，获取对象"></a>设置，获取对象</h4><pre><code>1. void serAttribute(String name,Objcet value):    这是一个键值对，name与value对应2. Object getAttribute(String name):    通过名为name 的键，去获得object类型的值3. void removeAttribute(String name):    移除名为name 的键值对4. Enumeration getAttributeNames():    获取所有域属性的名称</code></pre><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><h5 id="获取真实路径"><a href="#获取真实路径" class="headerlink" title="获取真实路径"></a>获取真实路径</h5><pre><code>使用ServletContext对象来获取web应用下的资源例如在hello应用的根目录下出创建a.txt文件，获取方法：    String realpath = servletContext.getRealPath(&quot;/a,txt&quot;),realpath的为a.txt的绝对路径</code></pre><h5 id="获取资源流"><a href="#获取资源流" class="headerlink" title="获取资源流"></a>获取资源流</h5><pre><code>可以通过ServletContext获取资源流，即把资源以输入流的方式获取：1. 获取a.txt资源流 InputStream in = ServletContext.getResourceAsStream(&quot;/a.txt&quot;);</code></pre><h5 id="获取指定目录下所有资源路径"><a href="#获取指定目录下所有资源路径" class="headerlink" title="获取指定目录下所有资源路径"></a>获取指定目录下所有资源路径</h5><pre><code>通过ServletContext获取指定目下所有资源路径例如获取/WEB-INF下所有的资源路径：    Set set = context.getResourcePaths(&quot;/WEB-INF&quot;);</code></pre><h2 id="Java画图（可用于验证码）"><a href="#Java画图（可用于验证码）" class="headerlink" title="Java画图（可用于验证码）"></a>Java画图（可用于验证码）</h2><pre><code>BufferedImage bi = new BufferedImage(150, 35, BufferedImage.TYPE_INT_RGB);//得到图片缓冲区，这是长宽，图片格式RGB还是RGBA//得到它的绘制环境（画这张图片的笔）Graphics2D g2 = (Graphics2D) bi.getGraphics();g2.setColor(Color.WHITE);//设置颜色g2.fillRect(0,0,79,35);//填充图片，就是设置背景色g2.setFont(new Font(&quot;宋体&quot;, Font.BOLD, 25));//设置字体//Font.BLOD 为字体格式，比如blod就是粗体g2.setColor(Color.BLACK);//设置颜色ge.drawString(&quot;hell0&quot;, point.x, point.y);//向图片区域中写String的内容ImageIO.write(bi, &quot;JPEG&quot;, new FileOutputStream(&quot;F:/a.jpg&quot;));//输出流，bi为图片缓冲区，&quot;JPEG&quot;为图片格式</code></pre><h2 id="response和request"><a href="#response和request" class="headerlink" title="response和request"></a>response和request</h2><pre><code>都是由服务器产生</code></pre><p><img src="https://i.imgur.com/KpOSoD7.png" alt=""></p><pre><code>服务器每次收到请求时，都会为这个请求开辟一个新的线程服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体服务器还会创建response对象，这个对象和客户端连接在一起，他可以用来向客户端发送响应</code></pre><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><pre><code>ServletResponse ---&gt; 与协议无关的类型HtppServletResponse ----&gt; 与http协议相关的类型二者无关，传入到Servlet中的时HttpServletResponse，所以可以强转为responsehttp协议中响应内容包括什么呢？</code></pre><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><pre><code>200 表示成功， 302 表示重定向， 404 表示客户端错误， 500表示服务器端错误1. sendError(int sc)2. sendError(int sc, String msg)3. setStatus(int sc)例如：    发送404    response.sendError(404, &quot;您访问的资源存在，就是不给你看&quot;);</code></pre><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><pre><code>响应头：Content-Type,Refresh,Location等1. setHeader(String name, String value):适用于单值的响应头2. addHeader(String name, String value):适用于多值的响应头3. setIntHeader(String name, String Value):适用于单值的int类型的响应头4. addIntHeader(String name, String value):适用于多值int类型的响应头5. setDateHeader(String name, long value):适用于单值的毫秒类型的响应头6. addDaTeHeader(String name, long value):适用于多值的毫秒类型的响应头；long型值为 毫秒值，代表过期时间，例如：    发送302，设置location头，完成重定向            response.setHeader(&quot;Location&quot;,&quot;/项目名/servlet路径&quot;);        response.setStatus(302);    定时刷新，设置Refresh头，其实就是定时重定向        PrintWriter write = rsponse.getWriter();        writer.print(&quot;欢迎登陆，5秒后自动跳转到主页&quot;);        response.setHeader(&quot;Redresh&quot;, &quot;5;URL=/项目名/重定向的servlet或jsp&quot;);    禁用浏览器缓存：Cache-Control, prama, expires        response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);        response.setHeader(&quot;prame&quot;,&quot;no-cache&quot;);        response.setDateHeader(&quot;expires&quot;,-1);//过期时间-1，立马过期    &lt;meta&gt;标签可以代替响应头</code></pre><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><pre><code>通常是html，也可以是图片response的两个流：    1. ServletOutPutStream,用来向客户端发送字节数据        ServletOutputStream out = response.getOutputStream();    2. PrintWriter,用来向客户端发送字符数据!需要设置编码        PrintWriter writer = response.getWriter();    两个流不能同时使用发送字节流：    String s = &quot;hello world&quot;;    byte[] bytes = s.getBytes();    response.getOutputStream().write(bytes);发送字节图片：    //运用commons-io库    String path = &quot;a.jpg&quot;;    FileInputStream in = new FileInputStream();    //读取输入流内容的字节到字节数组中    byte[] bytes = IOUtils.toByteArray(int);    response.getOutputStream().write(bytes);</code></pre><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><pre><code>这个重定向不同与上面的重定向，这个更快sendRedirect(String location)方法response.sendRedirect(&quot;/项目名/servlet虚拟路径或jsp名&quot;);</code></pre><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><pre><code>封装了客户端所有的请求数据Http协议中的数据都可以通过request对象来获取</code></pre><h4 id="获取常用信息"><a href="#获取常用信息" class="headerlink" title="获取常用信息"></a>获取常用信息</h4><pre><code>获取客户端Ip，请求方式Ip：request.getRemoteAddr();请求方式：request.getMethod();</code></pre><h4 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h4><pre><code>String getHeader(String name),适用于单值头int getIntHeader(String name),适用于单值int类型的请求头long getDateHeader(String name),适用于单值毫秒类型的请求头Enumeration&lt;String&gt; getHeaders(String name),适用于多值请求头例如：    通过user-agent识别用户浏览器类型        request.getHeader(&quot;User-Agent&quot;);    防盗链：如果请求不是通过本站发出的超链接发出的，发送错误状态码404        Refere这个请求头，表示请求的来源        String referer = req.getHeader(&quot;Rederer&quot;);        if(referer == null || referer.contains(&quot;localhost&quot;)){            resp.sendRedirect(&quot;https://www.baidu.com&quot;);            System.out.println(&quot;baidu&quot;);        } else{            System.out.println(&quot;hello&quot;);        }</code></pre><h4 id="获取请求URL"><a href="#获取请求URL" class="headerlink" title="获取请求URL"></a>获取请求URL</h4><pre><code>String getScheme();获取协议String getServerName();获取服务器名String getServerPort();获取服务器端口String getContextPath();获取项目名String getServletPath();获取Servlet路径String getQueryString();获取参数部分，即问好后面的部分String getRequestURI();获取请求URI，等于项目名+Servlet路径String getRequestURL();获取请求URL，等于不包含参数的整个请求路径</code></pre><p><img src="https://i.imgur.com/moO8HuU.png" alt=""></p><h4 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h4><pre><code>请求参数时由客户端发送给服务器的    1. 有可能在请求体中（post）    2. 可能在URL中（get）1. String getParameter(String name):获取指定名称的请求参数值，适用于单值请求2. String[] getParameterValues(String name);获取指定名称的请求参数值，适用于多值请求参数3. Map&lt;String, String[]&gt; getParameterMap():获取所有请i去参数，其中key为参数名，value为参数值，例如：    超链接参数    表单数据</code></pre><h4 id="请求转发和请求包含"><a href="#请求转发和请求包含" class="headerlink" title="请求转发和请求包含"></a>请求转发和请求包含</h4><pre><code>RequestDispatcher rd = request.getRequestDispatcher(&quot;/MyServlet&quot;);//参数是被包含或被转发的Servlet虚拟路径请求转发：rd.forward(request,response);（常用）请求包含：rd.include(request,response);有时一个请求需要多个Servlet协作才能完成，所以需要一个Servlet跳到另一个Servlet1. 一个请求跨多个Servlet，需要使用转发和包含2. 请求转发：由下一个Servlet完成相应体，当前Servlet可以设置响应头（留头不留体）    1. 即request.setHeader()中的内容，可以传递到第二个servlet    2. response.write()这类的内容不会传递回去，即第一个Servlet的内容不会输出浏览器3. 请求包含：由两个Servlet共同完成相应体（都留）4. 物理是请求转发还是请求包含，都在一个请求范围内，使用同一个resquest和response</code></pre><h4 id="请求转发与重定向不同"><a href="#请求转发与重定向不同" class="headerlink" title="请求转发与重定向不同"></a>请求转发与重定向不同</h4><pre><code>1. 请求转发是一次请求，重定向是两次转发2. 请求转发地址栏不变，重定向后会显示一个请求的地址3. 请求转发只能转发到本项目其他servet，而重定向哪都能去4. 请求转发为服务端行为，重定向是客户端行为</code></pre><h4 id="request域"><a href="#request域" class="headerlink" title="request域"></a>request域</h4><pre><code>Servlet中三大域对象：request,session,application,1. void setAttribute(String name);2. Object getAttribute(String name);3. void removeAttribute(String name);同一个请求范围内使用request.getAttribute()和request.setAttribute()可以使用但是如果是重定向则不能获取，因为不是同一个请求</code></pre><p><img src="https://i.imgur.com/ntAKbGY.png" alt=""></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><pre><code>常见字符编码：iso-8859-1（不支持中文），gbk（系统默认编码，中国的国标码），utf-8（万国码，支持全世界的编码，所以我们要使用这个）</code></pre><p><img src="https://i.imgur.com/ix3MrnG.png" alt=""></p><h3 id="响应编码"><a href="#响应编码" class="headerlink" title="响应编码"></a>响应编码</h3><pre><code>1. 当使用response.getWriter()来向客户端发送字符数据时   如果在之前没有设置编码，那么默认使用iso，以为不支持中文，所以一定是乱码2. 在使用response.getWriter()之前可以使用response.setCharaceterEncoding()   来设置字符流的编码为gbk或utf-83. 在使用response.getWriter()之前可以使用resonse.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;)   来设置响应头，通知浏览器服务器这边使用的utf-84. serHeader(&quot;Content-Type&quot;,&quot;text/html;charset=utf-8&quot;)的快捷方式是:setContentType(&quot;text/html;charset=utf-8&quot;);</code></pre><h3 id="请求编码"><a href="#请求编码" class="headerlink" title="请求编码"></a>请求编码</h3><pre><code>1. 客户端发送给服务器的请求参数是什么编码：    请求页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是是什么2. 服务器默认使用ISO-8859-1来解码，所以中文肯定出现乱码3. 请求编码处理分为两种：get，post：get请求参数不再请求体中，而post请求参数在请求体中，所以处理方式不同</code></pre><h5 id="GET请求编码处理"><a href="#GET请求编码处理" class="headerlink" title="GET请求编码处理"></a>GET请求编码处理</h5><pre><code>1. Sting username = request.getParameter(&quot;name&quot;);2. byte[] bytes = name.getBytes(&quot;ISO-8859-1&quot;);3. name = new String(bytes, &quot;utf-8&quot;);4. 在server.xml中配置URIEncoding=utf-8</code></pre><h5 id="POST请求编码处理"><a href="#POST请求编码处理" class="headerlink" title="POST请求编码处理"></a>POST请求编码处理</h5><pre><code>1. String usernmae = new String(request.getParameter(&quot;iso-8859-1&quot;),&quot;utf-8&quot;);2. 在获取参数之前调用request.setCharacterEncoding(&quot;utf-8&quot;);</code></pre><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><pre><code>表单的类型：Content-Type:application/x-www-form-urlencoded    就是把中文转换为%后面跟随两位16进制1. 他不是字符编码2. 它是用来在客户端和服务器之间传递参数用的一种方式3. URL编码需要先指定一种字符编码，把字符串解码后得到byte[],   然后把小于0的字节+256，再转换为16进制，前面再加%4. POST请求默认就是使用URL编码，tomcat会自动使用URL编码5. URL编码：String name = URLEncoder.encode(name, &quot;utf-8&quot;);6. URL解码：String name = URLDecoder.decode(name,&quot;utf-8&quot;);</code></pre><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><pre><code>1. web.xml中&lt;url-pattern&gt;路径    要么以“*”开头要么以&quot;/&quot;开头2. 转发和包含路径    1. 以&quot;/&quot;开头：相对当前项目路径    2. 不以&quot;/&quot;开头：相对当前Servlet路径3. 重定向路径（客户端路径）    1. 以&quot;/&quot;开头：相对当前主机，所以必须后面自己加上项目名4. 页面中超链接和表单路径    1. 与重定向相同，都是客户端路径，需要添加项目名    2. &lt;form action=&quot;/项目/servlet&quot;&gt;    3. 如果不已&quot;/&quot;开头，那么相对当前页面所在路径    4. 建议使用以&quot;/&quot;开头的路径，因为如果页面路径改变，那么servlet就找不到了5. ServletContext获取资源路径    1. 相对于当前项目目录，即index.jsp所在路径6. ClassLoader获取资源路径    1. 相对classes目录7. Class获取资源路径    1. 以&quot;/&quot;开头，相对Classes目录    2. 不以&quot;/&quot;开头，相对当前.class文件所在目录</code></pre><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>jsp程序是java为了适应web开发而扩展的一种程序形式，是java程序针对web开发进行的简化。用户通过浏览器向服务器发送指定页面的请求，接下来web服务器读取jsp文件，jsp文件会被转换为一个普通java文件，java文件进行编译，得到一个class文件，web服务器装在解释执行class文件，并将执行结果响应至客户端。tomcat把为每个jsp页面创建的java文件和class 文件，放在安装目录下的 \work\Catalina\localhost\同名文件夹内。</code></pre><h3 id="JSP的作用"><a href="#JSP的作用" class="headerlink" title="JSP的作用"></a>JSP的作用</h3><pre><code>Servlet：1. 缺点：不适合设置html响应体，需要大量的response.getWriter().print(html);2. 优点：动态资源，可以编程html:1. 缺点：html是静态页面，不能包含动态信息2. 优点：不用为输出html标签而发愁JSP：1. 优点：在原有html的基础上添加java脚本，构成jsp页面</code></pre><h3 id="JSP和Servlet的分工"><a href="#JSP和Servlet的分工" class="headerlink" title="JSP和Servlet的分工"></a>JSP和Servlet的分工</h3><pre><code>JSP：1. 作为请求发起页面，例如显示表单，超链接2. 作为请求结束页面，例如显示数据Servlet：1. 作为请求中处理数据的环节</code></pre><h3 id="JSP的组成"><a href="#JSP的组成" class="headerlink" title="JSP的组成"></a>JSP的组成</h3><pre><code>1. JSP = html + java脚本 + jsp标签（指令）2. jsp中无创建既可使用的对象有9个，被称为9大内置对象，例如：request,out等3. 3中java脚本：    1. &lt;% .... %&gt;：Java片段，用于定义0~N条Java语句    2. &lt;%=....%&gt;：java表达式，用于输出，用于输出一条表达式的结果    3. &lt;%!....%&gt;：声明，用来创建类的成员变量和成员方法(基本不用)</code></pre><h4 id="jsp声明语法："><a href="#jsp声明语法：" class="headerlink" title="jsp声明语法："></a>jsp声明语法：</h4><pre><code>&lt;%!        String str = &quot;hello world&quot;;        String getStr(){    return &quot;hello world2&quot;;       }%&gt;声明必须再&quot;&lt;%!&quot; 和 &quot;%&gt;&quot; 之间进行。声明部分只能定义成员方法（函数）和成员变量，不能直接包含程序域。这里定义了一个str变量在jsp文件中使用， 例：&lt;hr&gt;// &lt;hr&gt; 是分割线的意思&lt;%   out.println(this.str)   %&gt;//通过this 的方法调用变量或者方法（函数）&lt;hr&gt;&lt;% = this.getStr()%&gt;//注意加了一个“=”</code></pre><h4 id="jsp程序脚本："><a href="#jsp程序脚本：" class="headerlink" title="jsp程序脚本："></a>jsp程序脚本：</h4><pre><code>包括变量的声明，表达式和程序逻辑声明的变量转换为_service 方法中的变量，因而是局部变量语句块可以自由的与页面代码组合使用&lt;% int i = 100; %&gt;// 这里的 i 是脚本变量  上面的 加了 “!”的是成员变量&lt;% if (i &gt; 10) {  %&gt;    &lt;h1&gt;i &gt; 10 &lt;/h1&gt;&lt;% }else{ %&gt;    &lt;h1&gt; i &lt;= 10 &lt;/h1&gt;&lt;% } %&gt;  // 这里就是 java 和 jsp 的交叉写法。当然而可以直接用out.prinln 但是正常网页中，显示的不会是单调的黑字输出，而是有样式的输出。从下面的例子中可以看出 脚本变量 与 成员变量 的区别：&lt;!% int global = 0 %&gt;&lt;% int test = 0        global ++;       test ++;%&gt;&lt;%      out.println(global);      out.println(&quot;&lt;br&gt;&quot;);      out.printlin(test);%&gt;将其在加载到eclipse的工程中，然后不断刷新页面，会发现global的值会每次刷新都“+1”，但是test的值总是从0 加到 1就像是全局变量与局部变量的区别。</code></pre><h4 id="jsp注释："><a href="#jsp注释：" class="headerlink" title="jsp注释："></a>jsp注释：</h4><pre><code>语法格式：&lt;%--你要注释的内容--%&gt;有点像html 的注释写法，就是多了两个%。但是，jsp既然嵌套了java语言，那么java的注释写法依然是可用的。“//”  单行注释“/*  */”多行注释java注释一般多用于 &quot;&lt;%%&gt;&quot; 中</code></pre><h4 id="jsp内容输出表达式"><a href="#jsp内容输出表达式" class="headerlink" title="jsp内容输出表达式"></a>jsp内容输出表达式</h4><pre><code>语法格式：&lt;% = 输出的变量名 %&gt;例如：&lt;% int i = 10 %&gt;i 的值是 ：&lt;% = i %&gt;当然你也可以直接用 &lt;% out.println(i) %&gt;，但是嘛 写得多还不好控制格式</code></pre><h4 id="jsp包引入语法"><a href="#jsp包引入语法" class="headerlink" title="jsp包引入语法"></a>jsp包引入语法</h4><pre><code>语法格式：&lt;% @ page import = &quot;java.util.Date&quot; %&gt; // 引入一个 java.util.Date 的包&lt;% @ page import = &quot;java.io.*&quot; %&gt; //一次进入多个 java.io. 的包&lt;% @ page import = &quot;java.util.Date,  java.io.* &quot;%&gt; //一次引入多个包，用逗号隔开。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件系统体系结构&quot;&gt;&lt;a href=&quot;#软件系统体系结构&quot; class=&quot;headerlink&quot; title=&quot;软件系统体系结构&quot;&gt;&lt;/a&gt;软件系统体系结构&lt;/h2&gt;&lt;h3 id=&quot;B-S&quot;&gt;&lt;a href=&quot;#B-S&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法入门 嘤嘤嘤</title>
    <link href="http://yoursite.com/2018/10/12/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%98%A4%E5%98%A4%E5%98%A4/"/>
    <id>http://yoursite.com/2018/10/12/算法入门-嘤嘤嘤/</id>
    <published>2018-10-12T11:13:24.000Z</published>
    <updated>2018-10-15T13:16:08.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习算法的建议"><a href="#学习算法的建议" class="headerlink" title="学习算法的建议"></a>学习算法的建议</h2><h3 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h3><pre><code>1. 数理基础，着力加强2. 兴趣爱好，能否持久的喜欢它3. 做事有系统，规范，着眼于大的方面</code></pre><h3 id="C-或Java"><a href="#C-或Java" class="headerlink" title="C++或Java"></a>C++或Java</h3><pre><code>熟练掌握C++或者Java，语言作为基础，即使算法能理解，也无法表示出来</code></pre><h3 id="数理基础"><a href="#数理基础" class="headerlink" title="数理基础"></a>数理基础</h3><pre><code>对于数学定理，公式推导等，要熟悉</code></pre><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code>对于数据结构，吃透了能够受益终身。不要指望数据结构，这个东西方面太广，不要只去看你有什么没学，你更要看你学了什么</code></pre><h3 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a>计算思维</h3><pre><code>思维方式在前人的基础上，形成自己的方式；同时学习一些套路，解题的套路，等等</code></pre><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><pre><code>计算几何重于计算</code></pre><h3 id="凸包问题（计算几何的核心）"><a href="#凸包问题（计算几何的核心）" class="headerlink" title="凸包问题（计算几何的核心）"></a>凸包问题（计算几何的核心）</h3><h4 id="什么是凸包"><a href="#什么是凸包" class="headerlink" title="什么是凸包"></a>什么是凸包</h4><p><img src="https://i.imgur.com/phyPiVI.png" alt=""></p><pre><code>凸包就是这样的，由外部的点连成边能够包住所有的点 </code></pre><h4 id="颜料混合"><a href="#颜料混合" class="headerlink" title="颜料混合"></a>颜料混合</h4><pre><code>颜料混合问题能够帮助你了解凸包题目：    给你 x 颜料：红色 10%，绿色 35%    给你 y 颜料：红色 16%，绿色 20%问你能否组成    U 颜料：红色12%，绿色30%    V 颜料：红色13%，绿色22%如果再给你 Z 颜料：红色7%，绿色15%你能否组成 V 颜料呢？</code></pre><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><pre><code>将每种颜料构成一个点，我们所拥有的点作为顶点，只要目标点在顶点围成的边界里面，那么就可以得到颜料</code></pre><p><img src="https://i.imgur.com/zDVl8uX.png" alt=""></p><h4 id="In-Triangle-Test-判断点是否在三角形内"><a href="#In-Triangle-Test-判断点是否在三角形内" class="headerlink" title="In-Triangle Test(判断点是否在三角形内)"></a>In-Triangle Test(判断点是否在三角形内)</h4><p><img src="https://i.imgur.com/QSoeHA5.png" alt=""></p><pre><code>只要点在直线 PQ，QR，RP 的左边，那么点就在三角形内部。计算几何中，一般以逆时针方向 bool InTriangle(P, Q, R, S){    bool a = ToLeft(P, Q, S);    bool b = ToLeft(Q, R, S);    bool c = ToLeft(Q, R, S);    return a == b &amp;&amp; b == c;}//因为不知道PQR的排列顺序，虽然图片上是逆时针，但是实际中可能是逆时针可能是顺时针，所以全为True和全为False都成立</code></pre><h2 id="InsertionSort"><a href="#InsertionSort" class="headerlink" title="InsertionSort"></a>InsertionSort</h2><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><pre><code>last in,first out后进先出的数据结构</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code>出栈（pop）入栈（push）</code></pre><h3 id="InsertionSort（插入排序）"><a href="#InsertionSort（插入排序）" class="headerlink" title="InsertionSort（插入排序）"></a>InsertionSort（插入排序）</h3><pre><code>对于一串数字进行排序，所用的空间复杂度为O(1),且必须用栈进行排序。这里我们定义两个栈——L，R，和一个额外的变量int一开始，数据全部都在R里面，然后依次移动到L栈中：    当 R 中的要移动的数据(R.top()) T 比 L 中最后的数据(L.top())小的时候，将要移动的数据 T 存到 额外空间 int 中    再将 L 中的数据，依次出栈，入栈到R中，直到 L 栈中最后的数据(L.top())比 T 小的时候停止循环执行上述内容，直到 R 的内容为空的时候停止这里 用到 new 和 delete 方法，保证内存为O(1)比较 t 和 L.top()的大小关系的时候，需要判断 L 是否为空</code></pre><h2 id="Largest-Rectangle-in-a-Histogram-直方图中最大的矩形"><a href="#Largest-Rectangle-in-a-Histogram-直方图中最大的矩形" class="headerlink" title="Largest Rectangle in a Histogram(直方图中最大的矩形)"></a>Largest Rectangle in a Histogram(直方图中最大的矩形)</h2><p><img src="https://i.imgur.com/n02CYjq.png" alt=""></p><pre><code>在很多不规则的图形中，找到面积最大的矩形，然后裁剪出来</code></pre><p><img src="https://i.imgur.com/Je4FQqo.png" alt=""></p><pre><code>从某方面看，就是找某种意义上的极值点</code></pre><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><pre><code>求出最低点K    maxRect(h,low,high)        k = findPoint(h,low,high);然后是分别查看最低点的左边和右边    maxRect(h, low, k);    maxRect(h, k+1, high);    H[k]*(hi-low);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习算法的建议&quot;&gt;&lt;a href=&quot;#学习算法的建议&quot; class=&quot;headerlink&quot; title=&quot;学习算法的建议&quot;&gt;&lt;/a&gt;学习算法的建议&lt;/h2&gt;&lt;h3 id=&quot;必备条件&quot;&gt;&lt;a href=&quot;#必备条件&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python爬虫</title>
    <link href="http://yoursite.com/2018/10/08/python%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2018/10/08/python爬虫/</id>
    <published>2018-10-08T14:05:35.000Z</published>
    <updated>2018-10-08T15:56:28.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="爬虫的实际例子："><a href="#爬虫的实际例子：" class="headerlink" title="爬虫的实际例子："></a>爬虫的实际例子：</h2><pre><code>1. 搜索引擎（百度、谷歌、360搜索等）。2. 伯乐在线。3. 惠惠购物助手。4. 数据分析与研究（数据冰山知乎专栏）。5. 抢票软件等。</code></pre><h2 id="什么是网络爬虫："><a href="#什么是网络爬虫：" class="headerlink" title="什么是网络爬虫："></a>什么是网络爬虫：</h2><h3 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h3><pre><code>爬虫是一个模拟人类请求网站行为的程序。可以自动请求网页、并数据抓取下来然后使用一定的规则提取有价值的数据。专业介绍：百度百科。通用爬虫和聚焦爬虫：通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。        主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。聚焦爬虫：是面向特定需求的一种网络爬虫程序,他与通用爬虫的区别在于：        聚焦爬虫在实施网页抓取的时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。</code></pre><h2 id="为什么用Python写爬虫程序："><a href="#为什么用Python写爬虫程序：" class="headerlink" title="为什么用Python写爬虫程序："></a>为什么用Python写爬虫程序：</h2><pre><code>PHP：PHP是世界是最好的语言，但他天生不是做这个的    而且对多线程、异步支持不是很好，并发处理能力弱。爬虫是工具性程序，对速度和效率要求比较高。Java：生态圈很完善，是Python爬虫最大的竞争对手。    但是Java语言本身很笨重，代码量很大。重构成本比较高，任何修改会导致代码大量改动。爬虫经常要修改采集代码。C/C++：运行效率是无敌的。但是学习和开发成本高。写个小爬虫程序可能要大半天时间。Python：语法优美、代码简洁、开发效率高、支持的模块多。    相关的HTTP请求模块和HTML解析模块非常丰富。还有Scrapy和Scrapy-redis框架让我们开发爬虫变得异常简单。</code></pre><h2 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h2><pre><code>Python3.6开发环境。Pycharm 2017 professional版。虚拟环境。`virtualenv/virtualenvwrapper`。</code></pre><h2 id="http协议和Chrome抓包工具"><a href="#http协议和Chrome抓包工具" class="headerlink" title="http协议和Chrome抓包工具"></a>http协议和Chrome抓包工具</h2><h3 id="什么是http和https协议："><a href="#什么是http和https协议：" class="headerlink" title="什么是http和https协议："></a>什么是http和https协议：</h3><pre><code>HTTP协议：全称是HyperText Transfer Protocol，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是80端口。 HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是443端口。</code></pre><h3 id="在浏览器中发送一个http请求的过程："><a href="#在浏览器中发送一个http请求的过程：" class="headerlink" title="在浏览器中发送一个http请求的过程："></a>在浏览器中发送一个http请求的过程：</h3><pre><code>当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。当我们在浏览器输入URL http://www.baidu.com 的时候，浏览器发送一个Request请求去获取 http://www.baidu.com 的html文件，服务器把Response文件对象发送回给浏览器。浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。</code></pre><h3 id="url详解："><a href="#url详解：" class="headerlink" title="url详解："></a>url详解：</h3><pre><code>URL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成：        scheme://host:port/path/?query-string=xxx#anchorscheme：代表的是访问的协议，一般为http或者https以及ftp等。host：主机名，域名，比如www.baidu.com。port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。anchor：锚点，后台一般不用管，前端用来做页面定位的。在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。</code></pre><h3 id="常用的请求方法："><a href="#常用的请求方法：" class="headerlink" title="常用的请求方法："></a>常用的请求方法：</h3><pre><code>在Http协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是get请求和post请求。get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用get请求。post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。 以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，</code></pre><p>有可能一个应该使用get方法的请求就一定要改成post请求，这个要视情况而定。</p><h3 id="请求头常见参数："><a href="#请求头常见参数：" class="headerlink" title="请求头常见参数："></a>请求头常见参数：</h3><pre><code>在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据放在body中（在post请求中），第三个就是把数据放在head中。这里介绍在网络爬虫中经常会用到的一些请求头参数：User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。        如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。        因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。        一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。</code></pre><h3 id="常见响应状态码："><a href="#常见响应状态码：" class="headerlink" title="常见响应状态码："></a>常见响应状态码：</h3><pre><code>200：请求正常，服务器正常的返回数据。301：永久重定向。比如在访问www.jingdong.com的时候会重定向到www.jd.com。302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。400：请求的url在服务器上找不到。换句话说就是请求url错误。403：服务器拒绝访问，权限不够。500：服务器内部错误。可能是服务器出现bug了。Chrome抓包工具：</code></pre><h3 id="Chrome浏览器"><a href="#Chrome浏览器" class="headerlink" title="Chrome浏览器"></a>Chrome浏览器</h3><pre><code>Chrome浏览器是一个非常亲近开发者的浏览器。可以方便的查看网络请求以及发送的参数。对着网页右键-&gt;检查。然后就可以打开开发者选项。以下用图片来说明。 </code></pre><p><img src="https://i.imgur.com/Ru1ov2J.png" alt="1"><br><img src="https://i.imgur.com/zC66TIe.png" alt="2"><br><img src="https://i.imgur.com/htxzlhU.png" alt="3"><br><img src="https://i.imgur.com/fvnOJFn.png" alt="4"></p><h2 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h2><pre><code>urllib库是Python中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。</code></pre><h3 id="urlopen函数："><a href="#urlopen函数：" class="headerlink" title="urlopen函数："></a>urlopen函数：</h3><pre><code>在Python3的urllib库中，所有和网络请求相关的方法，都被集到urllib.request模块下面了，以先来看下urlopen函数基本的使用：from urllib import requestresp = request.urlopen(&apos;http://www.baidu.com&apos;)print(resp.read())实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。</code></pre><h4 id="以下对urlopen函数的进行详细讲解："><a href="#以下对urlopen函数的进行详细讲解：" class="headerlink" title="以下对urlopen函数的进行详细讲解："></a>以下对urlopen函数的进行详细讲解：</h4><pre><code>url：请求的url。data：请求的data，如果设置了这个值，那么将变成post请求。返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。有read(size)、readline、readlines以及getcode等方法。</code></pre><h3 id="urlretrieve函数："><a href="#urlretrieve函数：" class="headerlink" title="urlretrieve函数："></a>urlretrieve函数：</h3><pre><code>这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地：from urllib import requestrequest.urlretrieve(&apos;http://www.baidu.com/&apos;,&apos;baidu.html&apos;)</code></pre><h3 id="urlencode函数："><a href="#urlencode函数：" class="headerlink" title="urlencode函数："></a>urlencode函数：</h3><pre><code>用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据。示例代码如下：from urllib import parsedata = {&apos;name&apos;:&apos;爬虫基础&apos;,&apos;greet&apos;:&apos;hello world&apos;,&apos;age&apos;:100}qs = parse.urlencode(data)print(qs)</code></pre><h3 id="parse-qs函数："><a href="#parse-qs函数：" class="headerlink" title="parse_qs函数："></a>parse_qs函数：</h3><pre><code>可以将经过编码后的url参数进行解码。示例代码如下：from urllib import parseqs = &quot;name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet=hello+world&amp;age=100&quot;print(parse.parse_qs(qs))urlparse和urlsplit：有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用urlparse或者是urlsplit来进行分割。示例代码如下：from urllib import request,parseurl = &apos;http://www.baidu.com/s?username=zhiliao&apos;result = parse.urlsplit(url)# result = parse.urlparse(url)print(&apos;scheme:&apos;,result.scheme)print(&apos;netloc:&apos;,result.netloc)print(&apos;path:&apos;,result.path)print(&apos;query:&apos;,result.query)</code></pre><h3 id="urlparse和urlsplit"><a href="#urlparse和urlsplit" class="headerlink" title="urlparse和urlsplit"></a>urlparse和urlsplit</h3><pre><code>urlparse和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。比如有一个url为：url = &apos;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&apos;，那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。</code></pre><h2 id="request-Request类："><a href="#request-Request类：" class="headerlink" title="request.Request类："></a>request.Request类：</h2><pre><code>如果想要在请求的时候增加一些请求头，那么就必须使用request.Request类来实现。比如要增加一个User-Agent，示例代码如下：from urllib import requestheaders = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;}req = request.Request(&quot;http://www.baidu.com/&quot;,headers=headers)resp = request.urlopen(req)print(resp.read())</code></pre><h2 id="ProxyHandler处理器（代理设置）"><a href="#ProxyHandler处理器（代理设置）" class="headerlink" title="ProxyHandler处理器（代理设置）"></a>ProxyHandler处理器（代理设置）</h2><pre><code>很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理：from urllib import request# 这个是没有使用代理的# resp = request.urlopen(&apos;http://httpbin.org/get&apos;)# print(resp.read().decode(&quot;utf-8&quot;))# 这个是使用了代理的handler = request.ProxyHandler({&quot;http&quot;:&quot;218.66.161.88:31769&quot;})opener = request.build_opener(handler)req = request.Request(&quot;http://httpbin.org/ip&quot;)resp = opener.open(req)print(resp.read())</code></pre><h3 id="常用的代理有："><a href="#常用的代理有：" class="headerlink" title="常用的代理有："></a>常用的代理有：</h3><pre><code>西刺免费代理IP：http://www.xicidaili.com/快代理：http://www.kuaidaili.com/代理云：http://www.dailiyun.com/</code></pre><h2 id="什么是cookie："><a href="#什么是cookie：" class="headerlink" title="什么是cookie："></a>什么是cookie：</h2><pre><code>在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。</code></pre><h3 id="cookie的格式："><a href="#cookie的格式：" class="headerlink" title="cookie的格式："></a>cookie的格式：</h3><pre><code>Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE参数意义：NAME：cookie的名字。VALUE：cookie的值。Expires：cookie的过期时间。Path：cookie作用的路径。Domain：cookie作用的域名。SECURE：是否只在https协议下起作用。</code></pre><h3 id="使用cookielib库和HTTPCookieProcessor模拟登录："><a href="#使用cookielib库和HTTPCookieProcessor模拟登录：" class="headerlink" title="使用cookielib库和HTTPCookieProcessor模拟登录："></a>使用cookielib库和HTTPCookieProcessor模拟登录：</h3><pre><code>Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：from urllib import requestheaders = {    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;,    &apos;Cookie&apos;: &apos;anonymid=jacdwz2x-8bjldx; depovince=GW; _r01_=1; _ga=GA1.2.1455063316.1511436360; _gid=GA1.2.862627163.1511436360; wp=1; JSESSIONID=abczwY8ecd4xz8RJcyP-v; jebecookies=d4497791-9d41-4269-9e2b-3858d4989785|||||; ick_login=884e75d4-f361-4cff-94bb-81fe6c42b220; _de=EA5778F44555C091303554EBBEB4676C696BF75400CE19CC; p=61a3c7d0d4b2d1e991095353f83fa2141; first_login_flag=1; ln_uact=970138074@qq.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn121/20170428/1700/main_nhiB_aebd0000854a1986.jpg; t=3dd84a3117737e819dd2c32f1cdb91d01; societyguester=3dd84a3117737e819dd2c32f1cdb91d01; id=443362311; xnsid=169efdc0; loginfrom=syshome; ch_id=10016; jebe_key=9c062f5a-4335-4a91-bf7a-970f8b86a64e%7Ca022c303305d1b2ab6b5089643e4b5de%7C1511449232839%7C1; wp_fold=0&apos;}url = &apos;http://www.renren.com/880151247/profile&apos;req = request.Request(url,headers=headers)resp = request.urlopen(req)with open(&apos;renren.html&apos;,&apos;w&apos;) as fp:    fp.write(resp.read().decode(&apos;utf-8&apos;))但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储cookie的对象。而HTTPCookieProcessor处理器主要作用是处理这些cookie对象，并构建handler对象。</code></pre><h3 id="http-cookiejar模块："><a href="#http-cookiejar模块：" class="headerlink" title="http.cookiejar模块："></a>http.cookiejar模块：</h3><pre><code>该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。登录人人网：利用http.cookiejar和request.HTTPCookieProcessor登录人人网。相关示例代码如下：from urllib import request,parsefrom http.cookiejar import CookieJarheaders = {    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;}def get_opener():    cookiejar = CookieJar()    handler = request.HTTPCookieProcessor(cookiejar)    opener = request.build_opener(handler)    return openerdef login_renren(opener):    data = {&quot;email&quot;: &quot;970138074@qq.com&quot;, &quot;password&quot;: &quot;pythonspider&quot;}    data = parse.urlencode(data).encode(&apos;utf-8&apos;)    login_url = &quot;http://www.renren.com/PLogin.do&quot;    req = request.Request(login_url, headers=headers, data=data)    opener.open(req)def visit_profile(opener):    url = &apos;http://www.renren.com/880151247/profile&apos;    req = request.Request(url,headers=headers)    resp = opener.open(req)    with open(&apos;renren.html&apos;,&apos;w&apos;) as fp:        fp.write(resp.read().decode(&quot;utf-8&quot;))if __name__ == &apos;__main__&apos;:    opener = get_opener()    login_renren(opener)    visit_profile(opener)</code></pre><h3 id="保存cookie到本地："><a href="#保存cookie到本地：" class="headerlink" title="保存cookie到本地："></a>保存cookie到本地：</h3><pre><code>保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名：from urllib import requestfrom http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar(&quot;cookie.txt&quot;)handler = request.HTTPCookieProcessor(cookiejar)opener = request.build_opener(handler)headers = {    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;}req = request.Request(&apos;http://httpbin.org/cookies&apos;,headers=headers)resp = opener.open(req)print(resp.read())cookiejar.save(ignore_discard=True,ignore_expires=True)</code></pre><h3 id="从本地加载cookie："><a href="#从本地加载cookie：" class="headerlink" title="从本地加载cookie："></a>从本地加载cookie：</h3><pre><code>从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法：from urllib import requestfrom http.cookiejar import MozillaCookieJarcookiejar = MozillaCookieJar(&quot;cookie.txt&quot;)cookiejar.load(ignore_expires=True,ignore_discard=True)handler = request.HTTPCookieProcessor(cookiejar)opener = request.build_opener(handler)headers = {    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;}req = request.Request(&apos;http://httpbin.org/cookies&apos;,headers=headers)resp = opener.open(req)print(resp.read())</code></pre><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><pre><code>虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。</code></pre><h3 id="安装和文档地址："><a href="#安装和文档地址：" class="headerlink" title="安装和文档地址："></a>安装和文档地址：</h3><pre><code>利用pip可以非常方便的安装：pip install requests中文文档：http://docs.python-requests.org/zh_CN/latest/index.htmlgithub地址：https://github.com/requests/requests</code></pre><h3 id="发送GET请求："><a href="#发送GET请求：" class="headerlink" title="发送GET请求："></a>发送GET请求：</h3><pre><code>最简单的发送get请求就是通过requests.get来调用：response = requests.get(&quot;http://www.baidu.com/&quot;)</code></pre><h3 id="添加headers和查询参数："><a href="#添加headers和查询参数：" class="headerlink" title="添加headers和查询参数："></a>添加headers和查询参数：</h3><pre><code>如果想添加 headers，可以传入headers参数来增加请求头中的headers信息。如果要将参数放在url中传递，可以利用 params 参数。相关示例代码如下： import requests kw = {&apos;wd&apos;:&apos;中国&apos;} headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;} # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode() response = requests.get(&quot;http://www.baidu.com/s&quot;, params = kw, headers = headers) # 查看响应内容，response.text 返回的是Unicode格式的数据 print(response.text) # 查看响应内容，response.content返回的字节流数据 print(response.content) # 查看完整url地址 print(response.url) # 查看响应头部字符编码 print(response.encoding) # 查看响应码 print(response.status_code)</code></pre><h3 id="发送POST请求："><a href="#发送POST请求：" class="headerlink" title="发送POST请求："></a>发送POST请求：</h3><pre><code>最基本的POST请求可以使用post方法：response = requests.post(&quot;http://www.baidu.com/&quot;,data=data)</code></pre><h3 id="传入data数据："><a href="#传入data数据：" class="headerlink" title="传入data数据："></a>传入data数据：</h3><pre><code>这时候就不要再使用urlencode进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码： import requests url = &quot;https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0&quot; headers = {     &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;,     &apos;Referer&apos;: &apos;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&apos; } data = {     &apos;first&apos;: &apos;true&apos;,     &apos;pn&apos;: 1,     &apos;kd&apos;: &apos;python&apos; } resp = requests.post(url,headers=headers,data=data) # 如果是json数据，直接可以调用json方法 print(resp.json())</code></pre><h3 id="使用代理："><a href="#使用代理：" class="headerlink" title="使用代理："></a>使用代理：</h3><pre><code>使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。示例代码如下：import requestsurl = &quot;http://httpbin.org/get&quot;headers = {    &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&apos;,}proxy = {    &apos;http&apos;: &apos;171.14.209.180:27829&apos;}resp = requests.get(url,headers=headers,proxies=proxy)with open(&apos;xx.html&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as fp:    fp.write(resp.text)</code></pre><h3 id="cookie："><a href="#cookie：" class="headerlink" title="cookie："></a>cookie：</h3><pre><code>如果在一个响应中包含了cookie，那么可以利用cookies属性拿到这个返回的cookie值：import requestsurl = &quot;http://www.renren.com/PLogin.do&quot;data = {&quot;email&quot;:&quot;970138074@qq.com&quot;,&apos;password&apos;:&quot;pythonspider&quot;}resp = requests.get(&apos;http://www.baidu.com/&apos;)print(resp.cookies)print(resp.cookies.get_dict())</code></pre><h3 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h3><pre><code>之前使用urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。那么如果使用requests，也要达到共享cookie的目的，那么可以使用requests库给我们提供的session对象。注意，这里的session不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用requests来实现。示例代码如下：import requestsurl = &quot;http://www.renren.com/PLogin.do&quot;data = {&quot;email&quot;:&quot;970138074@qq.com&quot;,&apos;password&apos;:&quot;pythonspider&quot;}headers = {    &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&quot;}# 登录session = requests.session()session.post(url,data=data,headers=headers)# 访问大鹏个人中心resp = session.get(&apos;http://www.renren.com/880151247/profile&apos;)print(resp.text)</code></pre><h3 id="处理不信任的SSL证书："><a href="#处理不信任的SSL证书：" class="headerlink" title="处理不信任的SSL证书："></a>处理不信任的SSL证书：</h3><pre><code>对于那些已经被信任的SSL整数的网站，比如https://www.baidu.com/，那么使用requests直接就可以正常的返回响应。示例代码如下：resp = requests.get(&apos;http://www.12306.cn/mormhweb/&apos;,verify=False)print(resp.content.decode(&apos;utf-8&apos;))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;爬虫的实际例子：&quot;&gt;&lt;a href=&quot;#爬虫的实际例子：&quot; class=&quot;headerlink&quot; title=&quot;爬虫的实际例子：&quot;&gt;&lt;/a&gt;爬虫的实际例子：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 搜索引擎（百度、谷歌、360搜索等）。
2. 伯乐在线。
3. 惠惠购
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web安全</title>
    <link href="http://yoursite.com/2018/10/03/web%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/10/03/web安全/</id>
    <published>2018-10-03T10:39:24.000Z</published>
    <updated>2018-10-08T12:12:52.166Z</updated>
    
    <content type="html"><![CDATA[<pre><code>安全问题：1. 用户身份被盗用2. 用户密码泄露3. 用户资料被盗取4. 网站数据库是否泄露5. 其他攻击种类：1. 跨站脚本攻击XSS2. 跨站请求伪造攻击3. 前端Cookies安全性4. 点击劫持攻击5. 传输过程安全问题6. 用户密码安全问题7. SQL注入攻击8. 信息泄露和社会工程学配置环境：    1. 安装npm    2. 安装node.js    3. npm install nodemon -g（一旦更改代码就自动重启，不用手动重启了 -g 是global全局的意思）    4. 安装mysql</code></pre><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><pre><code>Cross Site Scripting ：跨站脚本攻击跨站：我的网站，自然希望网站里面所有的逻辑都来自自己写的代码。如果我的网站运行了来自其他网站的脚本，就叫跨站。</code></pre><p><img src="https://i.imgur.com/7GoBQpj.png" alt=""></p><pre><code>这样一来人为的给网页一个脚本，一般来说只要是网页脚本能做的事情，xss注入的脚本都能做。1. 获取页面数据2. 获取Cookies3. 劫持前端逻辑（改变原有的逻辑）4. 发送请求（通过图片，form等方式发送到攻击者指定的网站）5. 偷取网站的用户数据6. 偷取网站任意数据7. 欺骗用户8. ......例如，我在QQ空间内一个说说内混杂了XSS，所有访问的我空间的看到那篇说说的人都会在不知情的情况下向我规定的地方发送我想要的数据</code></pre><h3 id="XSS攻击分类"><a href="#XSS攻击分类" class="headerlink" title="XSS攻击分类"></a>XSS攻击分类</h3><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><pre><code>直接由url带过去的，页面直接显示这段代码写好url，再发给别人访问，以此获取访问者数据。但是可能网址很长，或者一眼能看出 网址包含的脚本，所以用长网址生成短网址这改一下https://dwz.cn/#/?_k=uu9n2n</code></pre><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><pre><code>XSS被保存在网站数据中，在其他用户访问的时候被其他用户执行</code></pre><h4 id="XSS攻击注入点"><a href="#XSS攻击注入点" class="headerlink" title="XSS攻击注入点"></a>XSS攻击注入点</h4><pre><code>1. HTML节点内容    1. 标签内内容是由用户输入，动态生成的2. HTML属性    1. 某个标签的属性是由用户输入，定义的3. JavaScript代码    1. js代码中存在由后台注入的变量，或者用户的输入的数据，有可能导致js代码的逻辑改变4. 富文本    1. 有各式的html文本    2. qq空间发的说说这种就叫富文本例如：    &lt;img src=&quot;&quot; /&gt; 其中src是用户上传或者输入的    这时，我们上传一个名为 1&quot; onerror=&quot;alert(0) 的文件，这样原本的src就被替换成 &lt;img src=&quot;1&quot; onerror=&quot;alert(0)&quot; /&gt;例如：    js代码从后台拿用户数据，但是用户数据是XSS的脚本    var data = &quot;hello &quot;;alert(1);&quot;&quot;;例如：    qq邮箱中，有文本编辑器，即为富文本。富文本传输的其实就是一堆复杂的html代码，也就是说可以人为的修改其原本想表达的东西</code></pre><h3 id="防御XSS"><a href="#防御XSS" class="headerlink" title="防御XSS"></a>防御XSS</h3><pre><code>1. 浏览器自动拦截    当你的js参数出现在连接中，浏览器会进行自动拦截。    但是防御极其有限，只能防御注入在html和属性中的部分XSS，而js中的和富文本中的并不能拦截2. 对文本中进行转义    当XSS注入的时候，对 &quot;&lt;&quot; 和 &quot;&gt;&quot;进行转义，使之失去标签的作用         &quot;&lt;&quot;     ——&gt; &amp;lt;         &quot;&gt;&quot;     ——&gt; &amp;gt;    除此之外，html的属性需要 双引号，单引号，或者不需要引号，所以继续转义        &quot; &quot; &quot;    ——&gt; &amp;quto;        &quot; &apos; &quot;    ——&gt; &amp;apos;        &quot; &quot;        ——&gt; &amp;#32;3. 对js从后台数据库提取的数据进行转义    转义字符 或者 转换成 json4. 对于富文本设置 黑名单 或者 白名单    黑名单：禁止某些属性或者标签的出现        优点：好写，只需要进行正则        缺点：html标签属性繁杂，一不小心就容易疏忽某些标签属性    白名单：只允许某些标签或者属性的出现        优点：完全防止禁用标签或者属性的出现        缺点：不好写</code></pre><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><pre><code>Content Security Policy内容安全策略，用于指定哪些内容可执行CSP是http的头，规定了有哪些来源，可以限制    1. child-src(页面的自内容), connect-src(网络连接，如ajax), default-src(当其他没指定，就用default)2. font-src(字体), frame-src(框架), img-src(图片)3. manifest-src9Webapp的信息), media-src(视频音频), object-src(插件)4. script-src(脚本), style-src(css), worker-src(servers work等)定义了一些来源：1. &lt;host-source&gt;(host规定信任域名)&lt;scheme-source&gt;(根据信任协议判断是否信任) &apos;self&apos;(同域可信任)2. &apos;unsage-inline&apos;(指定是否信任直接插入页面的内容) &apos;unsafe-eval&apos; (是否调用eval，函数)&apos;none&apos;(不信任任何内容)3. &apos;nonce-&lt;base64-value&gt;&apos;(指定一个一次性的内容，) &lt;hash-source&gt;(后台定义hash表，前端计算跟hash相同的才会执行)4. &apos;strict-dynamic&apos;(信任脚本之后，脚本新链接的网站或者其他脚本是否信任)基本格式：Content-security-Policy:default-src &apos;self&apos; http://example.com;connect-src &apos;non1&apos;;Content-Security-Policy:connect-src http://example.com;script-src http://example.com/&lt;meta http-equiv=&quot;Content-Srcurity-Policy&quot; content=&quot;default-src https;&quot;&gt;</code></pre><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><pre><code>Cross Site Request Forgy跨站请求伪造例如：    我在A网站登陆了A网站的账号，我打开了B网站，B网站有脚本可以让我在不知情的情况下对A网站进行了操作，比如获取隐私数据，转账等</code></pre><h3 id="CSRF的运行顺序"><a href="#CSRF的运行顺序" class="headerlink" title="CSRF的运行顺序"></a>CSRF的运行顺序</h3><pre><code>1. B网站向A网站2. 带A网站的Cookies3. 不访问A网站前端4. referer为B网站</code></pre><h3 id="CSRF的特征"><a href="#CSRF的特征" class="headerlink" title="CSRF的特征"></a>CSRF的特征</h3><pre><code>1. 利用用户登陆态2. 用户不知情3. 完成业务请求4. ......</code></pre><h3 id="CSRF的危害"><a href="#CSRF的危害" class="headerlink" title="CSRF的危害"></a>CSRF的危害</h3><pre><code>1. 盗取用户资金（转账，消费）2. 冒充用户发帖背锅3. 损害网站名誉4. ......</code></pre><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h3><h4 id="进制第三方网站带Cookies"><a href="#进制第三方网站带Cookies" class="headerlink" title="进制第三方网站带Cookies"></a>进制第三方网站带Cookies</h4><pre><code>Cookies新带了 same-site属性，也就是说只有来自同一网站的请求才能带CookiesCookies添加SameSite属性：    SameSite = Strict：不允许任何链接带Cookies    SameSite = Lax：允许部分带Cookies，但是像ajax这种不能带Cookies    SameSite = true</code></pre><h4 id="在前端页面加入验证信息"><a href="#在前端页面加入验证信息" class="headerlink" title="在前端页面加入验证信息"></a>在前端页面加入验证信息</h4><pre><code>既然CSRF不经过前端，那么设置一下，只有你经过前端才能访问到数据，那么也许可以拦截CSRF的攻击</code></pre><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><pre><code>通过图形验证码的方式，攻击者网站是无法知道随机的验证码是多少的缺点：    1. 有局限性，毕竟不能给所有操作加上验证码    2. 用户体验不好</code></pre><h5 id="token"><a href="#token" class="headerlink" title="token"></a>token</h5><pre><code>token是服务端生成的一串字符串，以作用户端进行请求的一个令牌，当第一次登陆之后，服务器生成一个token并将此返回给客户端。以后客户端只要带上这个token就行了，不需要带上用户密码提交的时候必须加上token信息才能生效，而只有经过前端才能获得token，也就是说通过这种方式可以防止第三方平台的不知情操作</code></pre><h4 id="什么是referer"><a href="#什么是referer" class="headerlink" title="什么是referer"></a>什么是referer</h4><pre><code>上面 &quot;CSRF的运行顺序&quot; 中提到了referer是什么呢？referer是HTTP协议中的一个请求头，包含了请求时来自哪里的信息。所以CSRF中的referer中的请求位置时 攻击者 网站很容易的我们可以想到，验证请求位置是否是正常用户端来防止CSRF的发生其实 referer 的拼写应该是 referrer，所以这个是为数不多的错误拼写的单词</code></pre><h2 id="前端Cookies问题"><a href="#前端Cookies问题" class="headerlink" title="前端Cookies问题"></a>前端Cookies问题</h2><pre><code>Cookies是什么？1. 它是一个前端数据的存储，它的存储是放在前端的。2. 后端可以通过http头设置Cookies的值。3. 请求时通过http头传给后端4. 前端也可以读写Cookies5. 遵守同源策略：当协议，域名，端口全部一致的时候才能读写前端只要通过 &quot;document.cookie&quot; 就可以取到Cookies了，追加可以直接 &quot; document.cookie = &quot;userId=2&quot; &quot;Cookies 可以修改原来的值，也能追加新的值，而且Cookies有自己的结构</code></pre><h3 id="Cookies-的特性"><a href="#Cookies-的特性" class="headerlink" title="Cookies 的特性"></a>Cookies 的特性</h3><pre><code>1. Cookies 有一个域名，表明在哪些地方可以使用2. Cookies 有一个有效期，表明在那段时间可以用3. Cookies 有一个路径，表明用在网络的哪一级，就像url层级一样4. Cookies 只能被http协议使用，即http-only5. secure 指定Cookies能否在 https中使用以上都可以在开发者工具中看到，可以通过js查看：    document.cookie在 父路径中无法查看 子路径的Cookies例如：    127.0.0.1:8080 界面无法看到 127.0.0.1:8080/user/login 中的Cookies，但反过来就可以Cookies没有删除方法，想删除Cookies只有设置Cookies的有效期为过去的时间，才能删除Cookies</code></pre><h3 id="Cookies作用"><a href="#Cookies作用" class="headerlink" title="Cookies作用"></a>Cookies作用</h3><pre><code>1. 存储个性化设置    1. 用户在我的网站用的什么皮肤    2. 用户上次浏览到那个界面    3. 某个菜单是打开还是关闭2. 存储未登录时用户唯一标识3. 存储已登录用户的凭证4. 存储其他业务数据</code></pre><h4 id="Cookies-登陆用户凭证"><a href="#Cookies-登陆用户凭证" class="headerlink" title="Cookies-登陆用户凭证"></a>Cookies-登陆用户凭证</h4><pre><code>1. 前端提交用户名和密码2. 后端验证用户名和密码3. 后端设置http头，设置用户凭证    1. 用户ID（不安全，容易被篡改）    2. 用户ID+签名（签命通过自己的算法算出，安全性高）    3. SessionID（随机的字符串）</code></pre><h3 id="Cookies-和-CSS的关系"><a href="#Cookies-和-CSS的关系" class="headerlink" title="Cookies 和 CSS的关系"></a>Cookies 和 CSS的关系</h3><pre><code>XSS可能偷取Cookieshttp-only的Cookies有几率避免Cookies被盗</code></pre><h3 id="Cookies-和-CSRF的关系"><a href="#Cookies-和-CSRF的关系" class="headerlink" title="Cookies 和 CSRF的关系"></a>Cookies 和 CSRF的关系</h3><pre><code>CSRF利用了用户的Cookies发送数据等但是攻击站点无法读写Cookies最好能阻止第三方使用Cookies</code></pre><h3 id="Cookies-安全策略"><a href="#Cookies-安全策略" class="headerlink" title="Cookies-安全策略"></a>Cookies-安全策略</h3><pre><code>1. 加签命放篡改（数据是明文，只是验证有没有被修改）2. 私有变换（加密）3. http-only（防止XSS）4. secure5. same-site</code></pre><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><pre><code>操作是用户完成，但是并不是用于自主意愿完成的通过用户的点击完成某个操作，但是用户并不知情。例如：    用户登录网站A，此时打开网站B，在网站B上的点击操作，实际上应用在的网站A中    B网站里面其实是一个&lt;iframe&gt;，将A网站的架构放在了&lt;iframe&gt;中，然后通过设置opcity来隐藏这个&lt;iframe&gt;，再然后就给&lt;body&gt;一个背景贴图    贴图中有按钮样子的图片，也有其他的图片，混淆视听，当用于点击贴图中的图片的时候，其实点的是&lt;iframe&gt;中的按钮</code></pre><h3 id="点击劫持的特征"><a href="#点击劫持的特征" class="headerlink" title="点击劫持的特征"></a>点击劫持的特征</h3><pre><code>1. 用户亲手操作2. 用户不知情3. ......</code></pre><h3 id="点击劫持的危害"><a href="#点击劫持的危害" class="headerlink" title="点击劫持的危害"></a>点击劫持的危害</h3><pre><code>1. 盗取用户资金（转账，消费）2. 获取用户敏感信息3. ......</code></pre><h3 id="点击劫持的防御"><a href="#点击劫持的防御" class="headerlink" title="点击劫持的防御"></a>点击劫持的防御</h3><pre><code>点击劫持攻击的前提是 通过&lt;iframe&gt;将目标网站嵌套到自己网站</code></pre><h4 id="用Javascript禁止内嵌"><a href="#用Javascript禁止内嵌" class="headerlink" title="用Javascript禁止内嵌"></a>用Javascript禁止内嵌</h4><pre><code>在js中，如果没有内嵌那么 top === window如果被内嵌了，top 并不是 === window，&lt;iframe&gt;中的window就是&lt;iframe&gt;的window 但是 top 指的是 &lt;body&gt;的windowif(top.location != window.location){      top.location = window.location  }通过上面的代码，窗口会进行跳转，跳转到&lt;iframe&gt;的界面，也就是原界面但是 &lt;iframe&gt;中，有一个sandbox属性来限制&lt;iframe&gt;的功能，例如禁掉js的能力，所以js并不能百分百解决点击劫持</code></pre><h4 id="X-FRAME-OPTIONS-直接禁止内嵌"><a href="#X-FRAME-OPTIONS-直接禁止内嵌" class="headerlink" title="X-FRAME-OPTIONS 直接禁止内嵌"></a>X-FRAME-OPTIONS 直接禁止内嵌</h4><pre><code>ctx.set(&apos;X-FRAME-OPTIONS&apos;, &apos;DEMY&apos;);DENY            禁止内嵌SAME-ORIGIN        同一个网站可以使用SAMEORIIN        嵌入页和被嵌入页在同一域下ALLOW-FROM+网站    允许指定网址内嵌</code></pre><h4 id="其他辅助手段"><a href="#其他辅助手段" class="headerlink" title="其他辅助手段"></a>其他辅助手段</h4><pre><code>1. 验证码2. ......</code></pre><h2 id="HTTP传输窃听"><a href="#HTTP传输窃听" class="headerlink" title="HTTP传输窃听"></a>HTTP传输窃听</h2><pre><code>HTTP是一个明文协议，也就是说不会对数据进行加密客户端和服务器的发送都是明文的而数据包会经过很多中间节点，而这些节点愿意的话可以修改这些数据</code></pre><p><img src="https://i.imgur.com/fk6k3FK.png" alt=""></p><pre><code>1. 窃听    开启服务器代理，http请求可以直接查看文件请求头，响应头，响应body。2. 篡改    在代理软件中，修改资源文件为我电脑中的资源文件，那么在客户端看到或显示的我的资源</code></pre><h3 id="窃听和篡改"><a href="#窃听和篡改" class="headerlink" title="窃听和篡改"></a>窃听和篡改</h3><pre><code>窃听：你传输过程中的所有数据可以直接被别人看到1. 窃听用户密码2. 切丁患处敏感信息3. 非法获取个人资料篡改：在传输过程中，修改或者插入信息1. 插入广告2. 重定向网站3. 无法防御的XSS和CSRF攻击（如果修改了html或者js，那么我们做的防御没有任何意义）</code></pre><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><pre><code>HTTP协议是明文协议，中间方就可以直接查看篡改。HTTPS TLS(SSL)加密 在 传输层加密TLS 就是 SSL，现在称之为TLS，以前是SSL</code></pre><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><pre><code>中间人对客户端来说是服务器，对服务器来说是客户端，它是一个伪装的设备也就是说，中间人可以查看客户端与服务器之间的通信，而不受TLS加密的影响</code></pre><h3 id="确认服务器身份"><a href="#确认服务器身份" class="headerlink" title="确认服务器身份"></a>确认服务器身份</h3><pre><code>CA：数字证书中心</code></pre><p><img src="https://i.imgur.com/24cItvo.png" alt=""></p><pre><code>保证安全的点：1. 证书无法被伪造2. 证书私钥不被泄露（恶意攻击者盗用私钥，可以查看篡改）3. 域名管理权不能泄露（一旦泄露，被恶意攻击者指向自己的服务器，证书就会给攻击者的服务器而不给你）4. CA坚守原则（验证不通过，不给证书）</code></pre><h2 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h2><h3 id="密码的作用"><a href="#密码的作用" class="headerlink" title="密码的作用"></a>密码的作用</h3><pre><code>&quot;证明你是你&quot;，说白了就是证明一下登陆操作的人是合法用户原理很简单，就是申请账号的时候是你最开始设置的密码和你现在使用的密码相同，对比一下就是了</code></pre><h3 id="密码泄露渠道"><a href="#密码泄露渠道" class="headerlink" title="密码泄露渠道"></a>密码泄露渠道</h3><pre><code>1. 数据库被偷2. 服务器被入侵3. 通讯过程被窃听4. 内部人员泄露数据5. 其他网站（撞库，A网站的数据泄露，攻击者拿着用户的密码试用户在其他网站的密码）6. ......</code></pre><h3 id="密码存储"><a href="#密码存储" class="headerlink" title="密码存储"></a>密码存储</h3><pre><code>1. 严禁密码的明文存储（防泄露，数据库中存储不用明文，加密）2. 单向变换（一个密码对应一个密文）3. 变化复杂度要求（防猜解）4. 密码复杂度要求（防猜解）5. 加盐（放猜解）</code></pre><h4 id="哈希算法——信息摘要算法"><a href="#哈希算法——信息摘要算法" class="headerlink" title="哈希算法——信息摘要算法"></a>哈希算法——信息摘要算法</h4><pre><code>明文-密文     一一对应雪崩效应     只要明文有一点不一样，密文完全不一样密文-明文    无法反推密文固定长度    一般来说32为字符串常见哈希算法    md5, sha1, sha256</code></pre><h4 id="密码单项变化彩虹表"><a href="#密码单项变化彩虹表" class="headerlink" title="密码单项变化彩虹表"></a>密码单项变化彩虹表</h4><pre><code>以md5为例，先暴力出所有的可能的明文的密文，然后根据窃听得到的密文去反过来查明文。这样子存着所有结果的密文表就被成为彩虹表1. 混合加密    但是我们可以 混合多种加密算法，例如：        md5(明文) = 密文        md5(md5(明文)) = 密文        md2(sha1(明文)) = 密文        md5(sha256(sha1(明文))) = 密文    这样子就算是查彩虹表，最后得到的可能很难是正确的2. 复杂密码    虽然可以用算密文反过去映射明文，但是位数越多，越复杂的密码，破解所需的时间和内存就越大，一个20为的密码需要900G的硬盘来存储密码</code></pre><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><pre><code>md5（ID + 原始密码 + 盐（随机生成的字符串） + 固定随机串（服务器一开始就定义的不变的字符串）*N个（顺序随意））= 最终密码就是自动的给原始密码一个复杂的字符串，让其安全</code></pre><h3 id="密码变化次数越安全"><a href="#密码变化次数越安全" class="headerlink" title="密码变化次数越安全"></a>密码变化次数越安全</h3><pre><code>1. 加密成本几乎不变（生成密码时速度慢一些，但是只生成一次）    1. 对使用者来说，这点时间几乎是小事    2. 对解密者来说，破解时间成倍增加2. 彩虹表失效（数量太大，无法建立链接）3. 解密成本增加N倍</code></pre><h3 id="密码传输的安全性"><a href="#密码传输的安全性" class="headerlink" title="密码传输的安全性"></a>密码传输的安全性</h3><pre><code>1. https传输2. 频率限制（限制固定时间内只能登陆多少次）3. 前端加密意义有限（传输层窃听并不知道明文密码，但是攻击者也可以传输你传输的密文）</code></pre><h3 id="生物特征密码"><a href="#生物特征密码" class="headerlink" title="生物特征密码"></a>生物特征密码</h3><pre><code>1. 指纹（唇纹）2. 声纹3. 虹膜4. 人脸</code></pre><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><pre><code>1. 私密性-容易泄露（指纹随时可以提取，圣文也是，人脸也是）2. 安全性-碰撞（可能出现识别错误）3. 唯一性-终身唯一 无法修改（如果别人获取了你的密码，你不能去改你的指纹密码对吧）</code></pre><h2 id="接入层注入问题"><a href="#接入层注入问题" class="headerlink" title="接入层注入问题"></a>接入层注入问题</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><pre><code>1. 存放结构化数据2. 可搞笑操作大量数据（维护，查询）3. 方便处理数据之间的关联关系4. 常见的：access/sqlite/mysql/mssql server</code></pre><h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><pre><code>数据库查询语言1. 被广泛接受的语言，各大数据库都能接受，已经被标准化2. 但是标准话并不代表完全语言，每个数据库的SQL都有一点不一样3. 类似自然语言4. 用于关系型数据库</code></pre><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><pre><code>在web中，数据库操作都是通过事先定义的代码实现的，毕竟用户不可能直接操作数据库例如：    select * from table where id = ${id};</code></pre><h4 id="什么是注入"><a href="#什么是注入" class="headerlink" title="什么是注入"></a>什么是注入</h4><pre><code>如果用户传入的是一个 &quot; 1 or 1 = 1 &quot;，这个是一个id但是插入到sql中变成了：    select * from table where id = 1 or 1 = 1;    类似于XSS，去用传入的数据修改原本的逻辑结构例如：    select * from user where username = &apos;${data.username}&apos; and password = &apos;${data.password}&apos;这个时候，用户传入的是 &quot;username&quot; &quot;1&apos; or &apos;1&apos;=&apos;1&quot;那么原本的查询语句就变成了：    select * from user where username=&apos;username&apos; and password = &apos;1&apos;or&apos;1&apos;=&apos;1&apos;那么很容易发现， &quot; or &quot;这个关键字 否认了前面所有的判断，导致攻击者随便找个账户都能登陆</code></pre><h4 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h4><pre><code>1. 在网址后加上 &quot; and 1=1 &quot;网页不会产生变化2. 但是加上 &quot; and 1=0 &quot;    网页就变化报错了，通过这个可以检查是否有sql注入的危险3. 或者插入 &quot; or 1=1 &quot;访问一些当前用户没有权限访问的页面4. 同理通过 &quot;and union(version(), 1, 1)=6&quot;来判断数据库的版本位数第一位是否是6，这种方式获得数据库信息5. 知道数据库的信息，可以查看该版数据库的漏洞6. 还有通过其他的sql语句可以探测到 数据库的字段，例如ID，password是否存在，来推测表的结构7. 这里只介绍了很小很小的一部分，还有很多可以去搜索</code></pre><h4 id="sql注入的危害"><a href="#sql注入的危害" class="headerlink" title="sql注入的危害"></a>sql注入的危害</h4><pre><code>1. 猜解密码（用工具很快）2. 获取数据（信息泄露）3. 删库删表4. 拖库5. ......</code></pre><h4 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h4><pre><code>1. 关闭错误输出    1. 攻击者通过错误输出信息来判断注入方向是否正确2. 检查数据类型    例如： 120.0.0.1/post/10中10是页面的id    但是 攻击者通过 120.0.0.1/post/100 or 1=1来随机的查看页面    这个时候只要判断后面的值是否是数字，就能判断出是否是攻击者，我们只接收前面的10，不接受后面的字符串3. 对数据进行转义（escape()模块）    因为上面只是简单的id，但是有的时候搜索需要字符，所以不能一棒子打死    对于某些情况，可以通过转义来限制用户输入的意思，防止注入语句4. 使用参数化查询（需要安装mysql2）    先告诉数据库，我要传一个id，你帮我找一下    再传一个id过去，不管这个id是什么，数据库只会查找id而不会执行这个id    先给个意图，再给参数    npm install mysql2 --save5. 使用ORM（对象关系映射）    把数据库的数据，通过代码的对象映射出来，一个对象就是一个记录    一般语言都有人写好了ORM    npm install sequelize --save（node.js的ORM）</code></pre><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><pre><code>非关系型数据库，不同于sql，一定程度上可以防御sql注入但是也是可以sql注入的</code></pre><h5 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h5><pre><code>1. 检查数据类型2. 类型转换3. 写完整条件</code></pre><h2 id="接入层上传问题"><a href="#接入层上传问题" class="headerlink" title="接入层上传问题"></a>接入层上传问题</h2><h3 id="上传问题"><a href="#上传问题" class="headerlink" title="上传问题"></a>上传问题</h3><pre><code>1. 上传文件2. 再次访问上传的文件3. 上传的文件被当成程序解析如果上传的文件只是图片，音频就还行，但是如果是可执行文件就会出现大问题，因为攻击者的逻辑会被执行所以需要判断上传文件的后缀等，防止不符合要求的文件上传</code></pre><h2 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h2><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><pre><code>1. 泄露系统敏感信息2. 泄露用户敏感信息3. 泄露用户密码</code></pre><h3 id="信息泄露的途径"><a href="#信息泄露的途径" class="headerlink" title="信息泄露的途径"></a>信息泄露的途径</h3><pre><code>1. 错误信息失控2. sql注入3. 水平权限控制不当4. XSS/CSRF5. 快递单/房产中介6. ......</code></pre><h3 id="社会工程学-1"><a href="#社会工程学-1" class="headerlink" title="社会工程学"></a>社会工程学</h3><pre><code>通过渠道挖出你的个人信息</code></pre><p><img src="https://i.imgur.com/KFpGqX6.png" alt=""></p><pre><code>仅仅通过你的昵称，查出你的姓名，进而查到更多隐私信息，然后建立出一个个人数据模型你的身份由你掌握的资料确定，当你的个人信息被别人掌握，别人就可以伪装成你的身份，然后用你的身份去做坏事</code></pre><h3 id="社会工程学案例"><a href="#社会工程学案例" class="headerlink" title="社会工程学案例"></a>社会工程学案例</h3><h4 id="电信诈骗（徐玉玉案件）"><a href="#电信诈骗（徐玉玉案件）" class="headerlink" title="电信诈骗（徐玉玉案件）"></a>电信诈骗（徐玉玉案件）</h4><pre><code>为什么会出现电信诈骗，因为骗子通过掌握的关于你的信息去获取你的信任高考录取之后，成绩公示，报纸公示，让徐玉玉的个人信息被不法分子获取，并且利用这些信息进行诈骗</code></pre><h4 id="伪装公检法"><a href="#伪装公检法" class="headerlink" title="伪装公检法"></a>伪装公检法</h4><pre><code>处于对公检法的信任，外加对方可以报出你的个人信息，甚至一些私人信息，你不会怀疑对方</code></pre><h4 id="QQ视频借钱"><a href="#QQ视频借钱" class="headerlink" title="QQ视频借钱"></a>QQ视频借钱</h4><pre><code>伪装好友，发送QQ视频，由于信息泄露可以获取一个人的视频，声音</code></pre><h4 id="微信伪装好友"><a href="#微信伪装好友" class="headerlink" title="微信伪装好友"></a>微信伪装好友</h4><pre><code>就算一开始你不信，但是久而久之你就以为她是你的好友</code></pre><h3 id="OAuth思想"><a href="#OAuth思想" class="headerlink" title="OAuth思想"></a>OAuth思想</h3><pre><code>即 现在网站的 授权登陆 的思想</code></pre><p><img src="https://i.imgur.com/fIstJMH.png" alt=""><br><code>access Token为每个用户对应的那一个Token，所以每次查询，只能查一个人，一定范围内保护用户资料</code></p><pre><code>特点：1. 一切行为由用户授权2. 授权行为不泄露敏感信息3. 授权会过期</code></pre><h3 id="利用OAuth思想防止资料泄露"><a href="#利用OAuth思想防止资料泄露" class="headerlink" title="利用OAuth思想防止资料泄露"></a>利用OAuth思想防止资料泄露</h3><p><img src="https://i.imgur.com/lJ3UsPM.png" alt=""></p><pre><code>1. 用户授权读取票据2. 无授权的资料不能读取（防止一个人查询其他人的资料）3. 不允许批量获取数据、4. 数据接口可风控审计（获取查询数据的时间，位置等）</code></pre><h2 id="其他安全问题"><a href="#其他安全问题" class="headerlink" title="其他安全问题"></a>其他安全问题</h2><h3 id="拒绝服务-DOS"><a href="#拒绝服务-DOS" class="headerlink" title="拒绝服务 DOS"></a>拒绝服务 DOS</h3><pre><code>模拟正常用户访问网站，但是访问量成千上万甚至过亿，来占用服务器大量的资源，以至于网站不能正常打开访问</code></pre><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><pre><code>1. TCP半连接    TCP的三次握手，我们只发送第一次请求，让服务器处于准备好并等待我们第三次握手的状态，这个时候就会影响服务器工作2. HTTP链接3. DNS    当TCP和HTTP的潮水攻击都被防下来的时候，转而攻击你的DNS（域名解析服务器）</code></pre><h4 id="大范围分布式拒绝服务攻击DDOS"><a href="#大范围分布式拒绝服务攻击DDOS" class="headerlink" title="大范围分布式拒绝服务攻击DDOS"></a>大范围分布式拒绝服务攻击DDOS</h4><pre><code>在DOS的基础上，用大范围的机器攻击网站服务器1. 流量可达几十到上百G2. 分布式（肉鸡，代理）3. 极难防御（无法辨别正常用户和恶意用户）</code></pre><h4 id="DOS攻击防御"><a href="#DOS攻击防御" class="headerlink" title="DOS攻击防御"></a>DOS攻击防御</h4><pre><code>1. 防火墙（防火墙有办法尝试过滤恶意流量）2. 交换机，路由器（只能防护小范围）3. 流量清洗（对流量进行分析，找出特征，分辨正常访问）4. 高防IP（云服务提供的，当面对DOS攻击时，把IP转为服务器提供商提供的另一个IP，而另一个IP拥有大规模的流量清洗服务）5. 编写代码时 避免重逻辑业务6. 快速失败快速返回7. 防雪崩机制8. 有损服务9. CDN（静态网页发送到CDN上，减少服务器的压力）</code></pre><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><pre><code>请求被窃听或记录，再次发送相同的请求，产生意外的结果例如：1. 用户被多次消费2. 用户登陆态被盗取（重新发送之后，伪装成原用户）3. 多次抽奖</code></pre><h4 id="重放冲击防御"><a href="#重放冲击防御" class="headerlink" title="重放冲击防御"></a>重放冲击防御</h4><pre><code>1. 加密（HTTPS）2. 请求加时间戳（防止二次发送）3. 加上token（session，每次发送的token都会变化，那么同样的请求 token就会很容易识别出来）4. nonce（num+once，是只用一次的数字，就像ID一样）5. 数字签名</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;安全问题：
1. 用户身份被盗用
2. 用户密码泄露
3. 用户资料被盗取
4. 网站数据库是否泄露
5. 其他

攻击种类：
1. 跨站脚本攻击XSS
2. 跨站请求伪造攻击
3. 前端Cookies安全性
4. 点击劫持攻击
5. 传输过程安全问题
6.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从0开始的JavaWeb---H5篇</title>
    <link href="http://yoursite.com/2018/09/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb/"/>
    <id>http://yoursite.com/2018/09/29/从0开始的JavaWeb/</id>
    <published>2018-09-29T12:37:38.000Z</published>
    <updated>2018-10-13T02:12:59.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><h3 id="什么是Html？"><a href="#什么是Html？" class="headerlink" title="什么是Html？"></a>什么是Html？</h3><pre><code>HyperText Markup Language：超文本标记语言** 超文本：超出文本的范畴，使用html可以轻松实现** 标记：html所有的操作都是通过标记实现的。标记，就是标签  ** 网页语言：超文本标记语言</code></pre><h3 id="第一个html程序："><a href="#第一个html程序：" class="headerlink" title="第一个html程序："></a>第一个html程序：</h3><pre><code>例如：创建Java文件 后缀名为.java**先编译，后运行（jvm）同理：html文件后缀是.html**直接通过浏览器就可以运行</code></pre><h3 id="html规范："><a href="#html规范：" class="headerlink" title="html规范："></a>html规范：</h3><pre><code>1. 一个html文件开始标签和结束的标签&lt;html&gt;&lt;/html&gt;2. html包含两个部分内容：    &lt;head&gt;&lt;/head&gt;     &lt;body&gt;&lt;/body&gt; 3. html的标签有开始标签，也要有结束标签 4. html的代码不区分大小写&lt;font&gt; == &lt;FONT&gt; 5. 部分标签没有结束标签：    例如：&lt;br /&gt;//内部加个&quot;/&quot;，标签内结束</code></pre><h3 id="html的操作思想："><a href="#html的操作思想：" class="headerlink" title="*html的操作思想："></a>*html的操作思想：</h3><pre><code>网页中有很多的数据，不同的数据可能需要不同的显示效果，这个时候需要使用标签把要操作的数据封装起来，通过修改标签的属性值实现标签内数据样式的变化。一个标签就像等于一个容器，想要修改容器内数据的样式，只需要改变容器的属性值，就可以实现容器内的数据样式的变化。</code></pre><h3 id="html中常用的标签"><a href="#html中常用的标签" class="headerlink" title="html中常用的标签"></a>html中常用的标签</h3><h4 id="文字标签和注释标签"><a href="#文字标签和注释标签" class="headerlink" title="文字标签和注释标签"></a>文字标签和注释标签</h4><h5 id="文字标签：修改文字的样式"><a href="#文字标签：修改文字的样式" class="headerlink" title="*文字标签：修改文字的样式"></a>*文字标签：修改文字的样式</h5><pre><code>例如：&lt;font&gt; &lt;/font&gt;属性：color : 文字颜色(颜色的英文单词，或者十六进制rgb)     size : 文字大小（1~7）</code></pre><h5 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h5><pre><code>Java的注释有三种：&quot;//&quot; , &quot;/* */&quot; &quot;/*****/&quot;html的注释: &lt;!--  注释内容 --&gt;(源文件可以查看的注释)</code></pre><h4 id="标题标签，水平线标签和特殊字符"><a href="#标题标签，水平线标签和特殊字符" class="headerlink" title="标题标签，水平线标签和特殊字符"></a>标题标签，水平线标签和特殊字符</h4><h5 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h5><pre><code>&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt; ~~~~  &lt;h6&gt;&lt;/h6&gt;文字大小 从h1 到 h6 以此变小，并且每个标签都会自动换行</code></pre><h5 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h5><pre><code>&lt;hr /&gt; 标签内结束属性：    **size：水平线的粗细    **color：水平线的颜色</code></pre><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><pre><code>想在网页中显示 &quot;&lt;html&gt;是一个特殊标签&quot;如果直接写 &quot;&lt;html&gt;是一个特殊标签&quot;，则只会显示 &quot;是一个特殊标签&quot;需要转义&quot;&lt;html&gt;&quot;：    &amp;lt;       ---&gt;     &quot;&lt;&quot;   小于符号    &amp;gt;      ---&gt;     &quot;&gt;&quot;   大于符号    &amp;amp;      ---&gt;     &quot;&amp;&quot;   and符号 &amp;    &amp;apos;    ---&gt;     &quot;&apos;&quot;   英文单引号    &amp;quot;    ---&gt;     &quot;&quot;&quot;   英文双引号    &amp;nbsp;  ---&gt;     &quot; &quot;   空格转义</code></pre><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><pre><code>如果想在网页显示 列表的效果。</code></pre><h5 id="lt-dl-gt-lt-dl-gt-：表示列表的范围"><a href="#lt-dl-gt-lt-dl-gt-：表示列表的范围" class="headerlink" title="&lt;dl&gt;&lt;/dl&gt;：表示列表的范围"></a>&lt;dl&gt;&lt;/dl&gt;：表示列表的范围</h5><pre><code>    在&lt;dl&gt;里面  &lt;dt&gt;&lt;/dt&gt;：上层内容    在&lt;dl&gt;里面  &lt;dd&gt;&lt;/dd&gt;：下层内容例如：    &lt;dl&gt;        &lt;dt&gt;学习内容&lt;/dt&gt;            &lt;dd&gt;java&lt;/dd&gt;            &lt;dd&gt;C++&lt;/dd&gt;            &lt;dd&gt;Python&lt;/dd&gt;        &lt;dt&gt;学习进度&lt;/dt&gt;            &lt;dd&gt;没学&lt;/dd&gt;            &lt;dd&gt;没学&lt;/dd&gt;            &lt;dd&gt;没学&lt;/dd&gt;    &lt;/dl&gt;</code></pre><dl><br><dt>学习内容</dt><br><dd>java</dd><br><dd>C++</dd><br><dd>Python</dd><br><dt>学习进度</dt><br><dd>没学</dd><br><dd>没学</dd><br><dd>没学</dd><br></dl><h5 id="lt-ol-gt-lt-ol-gt-：有序列表的范围"><a href="#lt-ol-gt-lt-ol-gt-：有序列表的范围" class="headerlink" title="&lt;ol&gt;&lt;ol&gt;：有序列表的范围"></a>&lt;ol&gt;&lt;ol&gt;：有序列表的范围</h5><pre><code>    在&lt;ol&gt;&lt;/ol&gt;标签内部：&lt;li&gt;    属性：        type：这是排序方式 默认（缺省）为 1. 2. 3....            type = &quot;a&quot;            type = &quot;i&quot;例如：    &lt;ol type=&quot;a&quot;&gt;    &lt;li&gt;java&lt;/li&gt;    &lt;li&gt;C++&lt;/li&gt;    &lt;li&gt;Python&lt;/li&gt;    &lt;/ol&gt;</code></pre><ol type="a"><br><li>java</li><br><li>C++</li><br><li>Python</li><br></ol><h5 id="lt-ul-gt-lt-ul-gt-：无序列表的范围"><a href="#lt-ul-gt-lt-ul-gt-：无序列表的范围" class="headerlink" title="&lt;ul&gt;&lt;/ul&gt;：无序列表的范围"></a>&lt;ul&gt;&lt;/ul&gt;：无序列表的范围</h5><pre><code>属性：    type：        circle    空心圆            disc    实心圆（默认）        square    实心方块&lt;ol type=&quot;a&quot;&gt;&lt;li&gt;java&lt;/li&gt;&lt;li&gt;C++&lt;/li&gt;&lt;li&gt;Python&lt;/li&gt;&lt;/ol&gt;</code></pre><p><ul type="circle"></ul></p><p><li>java</li></p><p><li>C++</li></p><p><li>Python</li><br></p><h4 id="lt-img-gt-图像标签（重点）"><a href="#lt-img-gt-图像标签（重点）" class="headerlink" title="&lt;img&gt;图像标签（重点）"></a>&lt;img&gt;图像标签（重点）</h4><pre><code>&lt;img src=&quot;a.jpg&quot; width=&quot;宽像素&quot; height=&quot;高像素&quot; alt=&quot;显示的文字&quot;/&gt;--src：图片的路径--width：图片的宽度--height：图片的高度--alt：图片上显示的文字，把鼠标移动到图片上面，停留片刻显示内容</code></pre><h4 id="路径的介绍"><a href="#路径的介绍" class="headerlink" title="路径的介绍"></a>路径的介绍</h4><h5 id="第一类：绝对路径"><a href="#第一类：绝对路径" class="headerlink" title="第一类：绝对路径"></a>第一类：绝对路径</h5><pre><code>D:\blog\lc_love_hehe\source\_posts\p.jpghttp://www.baidu.com/b.jag</code></pre><h5 id="第二类：相对路径"><a href="#第二类：相对路径" class="headerlink" title="第二类：相对路径"></a>第二类：相对路径</h5><pre><code>一个文件相对于另外一个文件的位置三种写法：    当图片与html在同一个文件夹内，直接使用 b.jpg    当图片在html的同级文件夹img中，使用img/b.jpg    当图片在html的上级文件夹中，../b.jpg</code></pre><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><h5 id="连接资源"><a href="#连接资源" class="headerlink" title="连接资源"></a>连接资源</h5><pre><code>&lt;a href=&quot;连接到资源的路径&quot;&gt;显示在页面上的内容&lt;/a&gt;    href：连接的资源的地址    target：设置打开的方式，默认是当前页打开。        _blank：在新窗口打开        _self：当前页打开    当超链接不需要到任何地址的时候，href=&quot;#&quot;&lt;a href=&quot;https://usuiforhe.github.io/&quot; target=&quot;_blank&quot;&gt;test&lt;/a&gt;</code></pre><h5 id="定位资源"><a href="#定位资源" class="headerlink" title="定位资源"></a>定位资源</h5><pre><code>&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;//定义顶部的位置&lt;a name=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;//定位到网页中name为top的位置，记得加上#&lt;pre&gt;原样输出例如：public static void main(String[] args){    Syste.out.println(&quot;hello world&quot;);}&amp;lt;pre&amp;gt;public static void main(String[] args){    Syste.out.println(&quot;hello world&quot;);}&amp;lt;/pre&amp;gt;</code></pre><p>public static void main(String[] args){    Syste.out.println(“hello world”);}</p><p><pre><br>public static void main(String[] args){<br>    Syste.out.println(“hello world”);<br>}<br></pre><br><code>加上了 &lt;pre&gt; 标签后，原本一行的代码，变成了我们要的换行的效果</code></p><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><pre><code>可以对数据进行格式化，使数据显示更加清晰&lt;table&gt;&lt;/table&gt;:表示表格的范围在&lt;table&gt;里面： &lt;caption&gt;表格标题在&lt;table&gt;里面： &lt;tr&gt;在&lt;tr&gt;里面：&lt;td&gt;画图分析表格的写法：    首先定义一个表格的范围使用table        定义一行使用 tr        定义一个单元格使用 td    操作技巧：        首先数有多少行，数每行里有多少个单元格    例如：        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;学科&lt;/td&gt;                &lt;td&gt;学习进度&lt;/td&gt;                &lt;td&gt;梦想&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;python&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;                &lt;td rowspan=&quot;3&quot;&gt;想学&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;C++&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;Java&lt;/td&gt;                &lt;td&gt;没学&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    属性：    &lt;table&gt;中：        border：表格线的粗细        bordercolor：表格线的颜色        cellspacing：表格之间的距离        align：left center right  框中文字的位置    &lt;td&gt;中：        colspan：0~无穷大，跨列        rowspan：0~无穷大，跨行</code></pre><table><br>    <tr><br>        <td>学科</td><br>        <td>学习进度</td><br>        <td>梦想</td><br>    </tr><br>    <tr><br>        <td>python</td><br>        <td>没学</td><br>        <td rowspan="3">想学</td><br>    </tr><br>    <tr><br>        <td>C++</td><br>        <td>没学</td><br>    </tr><br>    <tr><br>        <td>Java</td><br>        <td>没学</td><br>    </tr><br></table><h4 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h4><p><code>可以提交数据到服务器的标签，这个过程可以使用表单标签实现</code>  </p><blockquote><p>&lt;form&gt;&lt;/form&gt;：定义表单范围<br>输入项：可以输入内容或者选择内容的部分<br>    大部分的输入项 使用 &lt;input type = “输入类型” /&gt;  </p></blockquote><pre><code>Input  类型：type = &quot;email/url/number/range/date picker/search/color/tel&quot;      &lt;input type=&quot;password&quot;&gt;密码框&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男  单选框&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;苹果&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;香蕉&lt;input type=&quot;checkbox&quot; name=&quot;love&quot;/&gt;栗子  多选框&lt;input type = &quot;url&quot; name = &quot;url&quot;&gt;    手机端弹出字母键盘，电脑端无差别  &lt;input type = &quot;email&quot; name = &quot;email&quot;&gt;    手机端弹出字母键盘，电脑端无差别  &lt;input type = &quot;tel&quot; name = &quot;tel&quot;&gt;    手机端弹出数字键盘，电脑端无差别  &lt;input type = &quot;number&quot; name = &quot;number&quot;&gt;    手机端弹出数字键盘，电脑端右边多处两个按钮控制加减，只能输入参与运算的内容“+ - . 1 2 3 4 5 6 7 9 e”  data picker input类型:      date —— 选取 日， 月， 年      month —— 选取月，年      week ——    选取 周和年      time ——     选取时间（小时和分钟）          datetime    —— 选取时间，日，月，年（utc时间）      datetime-local —— 选取时间，日，月， 年（本地时间）  使用方法一样 &lt;input type = &quot;date&quot; name = &quot;date&quot; &gt; 手机端显示的是 日期键盘  &lt;input type = &quot;range&quot; name = &quot;range&quot; min = &quot;最小值&quot; max = &quot;最大值&quot;&gt;  &lt;input type = &quot;image&quot; src=&quot;a.jpg&quot;/&gt;设置按钮为图片，作用是提交&lt;input type = &quot;search&quot; name = &quot;search&quot; &gt;  &lt;input type = &quot;color&quot; name = &quot;color&quot;&gt;弹出颜色选择  &lt;input type = &quot;hidden&quot;/&gt;     隐藏项，不会显示在页面中的&lt;input type = &quot;button&quot; /&gt;    普通按钮&lt;input type = &quot;submit&quot; /&gt;     提交按钮&lt;input type = &quot;reset&quot; value=&quot;你想显示的文字&quot;/&gt;    重置按钮&lt;selsect&gt;    &lt;option&gt;1&lt;/option&gt;    &lt;option&gt;2&lt;/option&gt;    &lt;option&gt;3&lt;/option&gt;&lt;/select&gt;下拉选项&lt;textarea cols=&quot;列数&quot; rows=&quot;行数&quot;&gt;&lt;/textarea&gt; 文本域</code></pre><p><code>最好每个输入项都有个name属性，方便后台提取数据。后台通过name属性获取对应输入的值</code></p><pre><code>表单属性：  autocomplete/autofocus/multiple/placeholder/required/action/method  action    是提交数据到的那个页面method    常用的就两种“get”“post”，默认getenctype    关于文件上传的属性&lt;form autocomplete = &quot;on&quot;（#自动完成功能，存下之前提交过的字段#）action = &quot;****&quot;    ausofocous = &quot;&quot;&gt;      &lt;input type = &quot;text&quot; name = &quot;text&quot;  autofocus = &quot;autofocus&quot;&gt;(#不写  autocomplete 默认开启存储  autofocus 光标自动确定该input#)      &lt;input type = &quot;email&quot; name = &quot;email&quot; autocomplete = &quot;off&quot;&gt;（#关闭自动存储#）      &lt;input type = &quot;file&quot; multiple = &quot;muliple&quot; / &gt;(#muliple 是乘法，代表多个的意思，同时上传多个文件#)      ps. multiple 在类型为type的时候，也可以用，多个邮箱之间用 分号 隔开。 如果没有multiple ，email类型也可以传多个email，但是用了multiple 的 input，会传出一个数组到后台，而没有用的则会传出一整个字符串，难以操作。      &lt;input type = &quot;text&quot; placeholder = &quot;用户名&quot; /&gt;(#提示输入用户名，开始输入时提示消失#)      ps. placeholder 适用于： text, search, url, tel, email, password。      &lt;input type = &quot;text&quot; required = &quot;required&quot; /&gt; （#required 规定必须在提交之前填写输入域（不能为空）#）      &lt;input type = &quot;submit&quot;&gt;  &lt;/form&gt;`</code></pre><h4 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h4><pre><code>&lt;b&gt;        加粗&lt;s&gt;        删除线&lt;u&gt;        下划线&lt;i&gt;        斜体&lt;pre&gt;    原样输出&lt;sub&gt;    下标&lt;sup&gt;    上标&lt;div&gt;    盒子，自带换行&lt;span&gt;    盒子，不带换行</code></pre><h4 id="html的头标签"><a href="#html的头标签" class="headerlink" title="html的头标签"></a>html的头标签</h4><pre><code>html由两部分组成 head 和 body在head里面的标签就是头标签    title：显示在标签上显示的内容    base：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标（target属性）    例如：        &lt;base target=&quot;_blank&quot;&gt;        //这是所有的超链接都是新窗口打开    meta：可以提供有关页面的基本信息    例如：        &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=01-hello.html&quot;&gt;        // refresh 模拟页面请求， 3 3秒后， url 跳转的目标页面    link：定义文档与外部资源的关系</code></pre><h4 id="框架标签（过时）"><a href="#框架标签（过时）" class="headerlink" title="框架标签（过时）"></a>框架标签（过时）</h4><pre><code>&lt;frameset&gt;    属性：        rows：按行进行划分        cols：按列进行划分    &lt;frameset rows=&quot;80,*&quot;&gt;划分为两行，第一行高80        &lt;frame&gt;    具体显示的页面    &lt;frame name = &quot;lower_left&quot; src=&quot;b.html&quot;&gt;使用框架标签时候，不能写在body里面，需要把body去掉。</code></pre><h3 id="HTML样例"><a href="#HTML样例" class="headerlink" title="HTML样例"></a>HTML样例</h3><pre><code>&lt;body&gt;    &lt;header&gt;        &lt;div&gt;logo&lt;/div&gt;        &lt;nav&gt;            &lt;a href=&quot;test.html&quot;&gt;首页&lt;/a&gt;            &lt;a href=&quot;#&quot;&gt;介绍&lt;/a&gt;            &lt;a href=&quot;#&quot;&gt;案例&lt;/a&gt;            &lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt;            &lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;        &lt;/nav&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;aside&gt;            &lt;a href=&quot;#se1&quot;&gt;setcion1&lt;/a&gt;            &lt;a href=&quot;#se2&quot;&gt;section2&lt;/a&gt;            &lt;a href=&quot;#se3&quot;&gt;section3&lt;/a&gt;        &lt;/aside&gt;        &lt;article&gt;            Today, Rikka is going to learn how to use BIT to solve some simple data structure tasks. While studying,            She finds there is a magic expression x&amp;(−x) in the template of BIT. After searching for some literature,            Rikka realizes it is the implementation of the function lowbit(x).            lowbit(x) is defined on all positive integers. Let a1...am be the binary representation of x while a1 is the            least significant digit, k be the smallest index which satisfies ak = 1. The value of lowbit(x) is equal to            2            k−1            .            After getting some interesting properties of lowbit(x), Rikka sets a simple data structure task for you:            At first, Rikka defines an operator f(x), it takes a non-negative integer x. If x is equal to 0, it will return            0. Otherwise it will return x − lowbit(x) or x + lowbit(x), each with the probability of 1            2            .            Then, Rikka shows a positive integer array A of length n, and she makes m operations on it.            There are two types of operations:            • 1 L R, for each index i ∈ [L, R], change Ai to f(Ai).            • 2 L R, query for the expectation value of ∑R            i=L Ai            . (You may assume that each time Rikka calls f,            the random variable used by f is independent with others.)            Input            The first line contains a single integer t(1 ≤ t ≤ 3), the number of the testcases.            The first line of each testcase contains two integers n, m(1 ≤ n, m ≤ 105            ). The second line contains n            integers Ai(1 ≤ Ai ≤ 108            ).            And then m lines follow, each line contains three integers t, L, R(t ∈ {1, 2}, 1 ≤ L ≤ R ≤ n).            Output            For each query, let w be the expectation value of the interval sum, you need to output (w × 2            nm)            mod 998244353.            It is easy to find that w × 2            nm must be an integer.        &lt;/article&gt;    &lt;/section&gt;    &lt;input placeholder=&quot;选择手机品牌&quot; list=&quot;phtonlist&quot; /&gt;&lt;!--input的list 必须和datalist的id相同--&gt;    &lt;datalist id=&quot;phtonlist&quot;&gt;        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;    &lt;/datalist&gt;    &lt;meter value=&quot;220&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt;&lt;!-- 当前值为220 最低为20 最高为380 标准在200~240之间 最好的取值为220--&gt;    &lt;meter value=&quot;180&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt;    &lt;meter value=&quot;260&quot; min=&quot;20&quot; max=&quot;380&quot; low=&quot;200&quot; high=&quot;240&quot; optimum=&quot;220&quot;&gt;&lt;/meter&gt;    &lt;meter value=&quot;0.75&quot;&gt;75%&lt;/meter&gt;    &lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;    &lt;progress max=&quot;100&quot;&gt;&lt;/progress&gt;    &lt;details&gt;        &lt;summary&gt;你要显示的标题&lt;/summary&gt;        内容：。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。    &lt;/details&gt;    &lt;menu type=&quot;toolbar&quot;&gt;        &lt;li&gt;            &lt;menu aria-label=&quot;File&quot;&gt;                &lt;button type=&quot;button&quot;&gt;new1&lt;/button&gt;                &lt;button type=&quot;button&quot;&gt;new2&lt;/button&gt;                &lt;button type=&quot;button&quot;&gt;new3&lt;/button&gt;            &lt;/menu&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;button type=&quot;button&quot;&gt;new4&lt;/button&gt;            &lt;button type=&quot;button&quot;&gt;new5&lt;/button&gt;            &lt;button type=&quot;button&quot;&gt;new6&lt;/button&gt;        &lt;/li&gt;    &lt;/menu&gt;    &lt;footer&gt;        copyright......    &lt;/footer&gt;    &lt;p&gt;我们来&lt;ruby&gt;聊&lt;rt&gt;liao&lt;/rt&gt;&lt;/ruby&gt;天&lt;/p&gt;&lt;/body&gt;</code></pre><h2 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS-层叠样式表"></a>CSS-层叠样式表</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><pre><code>一层一层的，与优先级有关</code></pre><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><pre><code>有很多的属性和属性值，改变标签的属性值，是标签变换</code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><pre><code>CSS将网页内容和显示样式进行分离，提高了显示功能，解决了html代码对样式定义的重复，提高了后期样式代码的可维护性。</code></pre><h3 id="CSS和Html的结合方式"><a href="#CSS和Html的结合方式" class="headerlink" title="CSS和Html的结合方式"></a>CSS和Html的结合方式</h3><pre><code>1. 在每个html标签上都有一个style属性。通过style属性修改标签样式    &lt;span style=&quot;background-color:red; color=green;&quot;&gt;测试&lt;/span&gt;2. 使用html的一个标签实现 &lt;style&gt; 标签，写在head里面    &lt;style type=&quot;text/css&quot;&gt;        div{            background-color:red;            color = green        }//所有div的样式都这样    &lt;/style&gt;3. 在&lt;style&gt;标签中使用语句 @import url (css文件的路径)    &lt;style type=&quot;text/css&quot;&gt;        @import url(div.css)    &lt;/style&gt;4. 使用头标签&lt;link&gt;,引入外部css文件    &lt;link rel=&quot;srtlesheet&quot; type=&quot;text/css&quot; href=&quot;css_3.css&quot; /&gt;Ps.第三种结合方式，缺点：在某些浏览器下不支持。一般来说，是用第四种结合方式。</code></pre><h3 id="CSS的优先级"><a href="#CSS的优先级" class="headerlink" title="CSS的优先级"></a>CSS的优先级</h3><pre><code>从上到下，从外到内，CSS的优先级从低到高。后加载的优先级高。</code></pre><h3 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h3><pre><code>1. 选择器名称{    属性名：属性值；    属性名：属性值；}2. 属性与属性之间用分号隔开3. 属性与属性值之间用冒号链接4. 如果一个属性有多个属性值的话，那么多个值用空格隔开</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><pre><code>&lt;标签 id=&quot;test&quot;&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 #test{        background-color: red;    }来选择 id 为test的标签。也就是说 id 前面加上 &quot; # &quot;</code></pre><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><pre><code>&lt;标签 class=&quot;test&quot;&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 .test{        background-color:red;    }来选择 class 为test的标签。也就是说 class 前面加上 &quot; . &quot;</code></pre><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><pre><code>&lt;标签&gt;文字内容&lt;/标签&gt;在CSS文件中：    通过 标签{        background-color:red;    }来选择 标签</code></pre><p><code>class 选择器的优先级 &gt; 标签选择器的优先级</code><br><code>id选择器的优先级 &gt; class选择器的优先级</code><br><code>标签内部的style属性的优先级 &gt; id 选择器的优先级</code></p><h4 id="关联选择器"><a href="#关联选择器" class="headerlink" title="关联选择器"></a>关联选择器</h4><pre><code>&lt;div&gt;&lt;p&gt;test&lt;/p&gt;&lt;/div&gt;要选中 p 标签 那么CSS这样写    div p{        background-color:red;    }两个中间一个空格，这样就选中 div 子标签中的 p 标签</code></pre><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><pre><code>&lt;div&gt;test111&lt;/div&gt;&lt;p&gt;test222&lt;/p&gt;想把div和p设置成一样的样式，那么CSS中这么写    div,p{        background-color:red;    }中间用逗号连接，表示两个都选中</code></pre><h4 id="伪类元素选择器"><a href="#伪类元素选择器" class="headerlink" title="伪类元素选择器"></a>伪类元素选择器</h4><pre><code>CSS里面提供了一些定义好的样式，可以拿过来使用原始状态        鼠标放上去的状态        点击             点击之后：link        ：hover                ：active        visited例如CSS文件中：    a:link{        background-color: red;    }    a:hover{        background-color: blue;    }    a:active{        background-color: black;    }第一个字符        第一行            在文字标签前面加上:first-letter    :first-line        ：before例如CSS文件中：    p:before    {        content:&quot;台词：&quot;;    }那么 所有的 p 标签前面 都会加上 &quot;台词&quot; 这两个字</code></pre><table><br><tr> <td>选择符类型</td> <td>表达式</td> <td>描述</td></tr><br><tr><td>子串匹配的属性选择符</td><td> E[att^=”val”] </td><td>匹配具有att属性、且值以val开头的E元素 </td> </tr><br><tr> <td>子串匹配的属性选择符</td> <td>E[att$=”val”]</td> <td>匹配具有att属性、且值以val结尾的E元素 </td> </tr><br><tr> <td>子串匹配的属性选择符</td> <td>E[att*=”val”]</td> <td>匹配具有att属性、且值中含有val的E元素 </td> </tr><br><tr> <td>结构性伪类</td> <td> E:root</td> <td> 匹配文档的根元素。在HTML中，根元素永远是HTML </td> </tr><br><tr> <td>结构性伪类</td> <td> E:nth-child(n)</td> <td> 匹配父元素中的第n个子元素E </td> </tr><br><tr> <td>结构性伪类</td> <td> E:nth-last-child(n)</td> <td> 匹配父元素中的倒数第n个结构子元素E</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:nth-of-type(n)</td> <td> 匹配同类型中的第n个同级兄弟元素E<br></td></tr><tr> <td>结构性伪类</td> <td> E:nth-last-of-type(n)</td> <td> 匹配同类型中的倒数第n个同级兄弟元素E </td> </tr><br><tr> <td>结构性伪类</td> <td> E:last-child</td> <td> 匹配父元素中最后一个E元素</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:first-of-type </td> <td>匹配同级兄弟元素中的第一个E元素 </td> </tr><br><tr> <td>结构性伪类 </td> <td>E:only-child </td> <td>匹配属于父元素中唯一子元素的E</td> </tr><br><tr> <td>结构性伪类 </td> <td>E:only-of-type </td> <td>匹配属于同类型中唯一兄弟元素的E</td> </tr><br><tr> <td>结构性伪类</td> <td> E:empty</td> <td> 匹配没有任何子元素（包括text节点）的元素E</td> </tr><br><tr> <td>目标伪类</td> <td> :target</td> <td> 匹配相关URL指向的E元素</td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E:enabled</td> <td> 匹配所有用户界面（form表单）中处于可用状态的E元素 </td> </tr><br><tr> <td>UI元素状态伪类 </td> <td>E:disabled </td> <td>匹配所有用户界面（form表单）中处于不可用状态的E元素 </td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E:checked</td> <td> 匹配所有用户界面（form表单）中处于选中状态的元素E </td> </tr><br><tr> <td>UI元素状态伪类</td> <td> E::selection</td> <td> 匹配E元素中被用户选中或处于高亮状态的部分</td> </tr><br><tr> <td>否定伪类</td> <td> E:not(s)</td> <td> 匹配所有不匹配简单选择符s的元素E</td> </tr><br><tr><td>通用兄弟元素选择器</td> <td> E ~ F </td> <td>匹配E元素之后的F元素 </td> </tr><br></table><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><pre><code>div+CSS，给div一个样式，设置它的位置以及外观。又因为这div就像一个盒子一样，所以也叫做盒子模型。</code></pre><p><code>在进行布局前需要把数据封装到一块一块的区域内</code></p><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><pre><code>属性：    border：统一设置        none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset        无边框| 隐藏边框|点线或实线|虚线或实线| 实线 |双线边框  | 3D凹槽 | 3D凸槽 |3D凹边 |3D凸边    border-top：上边框    border-bottom：下边框    border-left：左边框    border-right：右边框    border: 粗细（px） 样式（上述）颜色；</code></pre><h4 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h4><pre><code>padding：length（px）//统一设置padding-bottom    :    文字内容距离下边框的距离padding-left    :    文字内容距离左边框的距离padding-right    :    文字内容距离有边框的距离padding-top        :    文字内容距离上边框的距离</code></pre><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><pre><code>margin：外边距，边框距离外边框的距离margin：length（px）//统一设置margin-top        :    边框距离上外边框的距离margin-bottom    :    边框距离下外边框的距离margin-right    :    边框距离右外边框的距离margin-left        :    边框距离左外边框的距离</code></pre><h3 id="CSS的布局的漂浮"><a href="#CSS的布局的漂浮" class="headerlink" title="CSS的布局的漂浮"></a>CSS的布局的漂浮</h3><pre><code>float：none | left | rightnone    ：默认值。对象不漂浮left    ：文本流向对象的右边right    ：文本流向对象的左边</code></pre><h3 id="CSS的布局的定位"><a href="#CSS的布局的定位" class="headerlink" title="CSS的布局的定位"></a>CSS的布局的定位</h3><pre><code>Position    属性：    static:默认值。无特殊定位，对象遵循HTML定位规则    absolute：将对象从文档流中脱出，使用left,right,top,bottom等属性相对于其进行绝对定位    ——————即，这个盒子独立出来，不由html自动按文档流分配位置，后面的盒子自动补齐该和自动空位    relative：对象不可层叠，但将依据left,right,top,bottom等属性在正常文档流中偏移位置。    ——————即，这个盒子没有从文档流中拖出，位置还在，但是可以移动而不影响其他的盒子的原有位置</code></pre><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h3><pre><code>JavaScript是基于对象和时间驱动的脚本语言，主要应用在客户端</code></pre><h4 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h4><pre><code>提供好了很多对象，可以直接拿过来使用</code></pre><h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><pre><code>html做网站是静态效果，加入了js后就可以完成动态的效果</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>1. 交互性（信息的动态交互）2. 安全性（不可以直接访问本地磁盘）3. 跨平台性（只要是可以解析js的浏览器都可以执行，与平台无关）</code></pre><h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><pre><code>三部分：1. ECMAScript    ECMA：欧洲计算机协会    由ECMA组织指定的js语法，语句......2. BOM    broswer object model：浏览器对象模型3. DOM    document object model：文档对象模型</code></pre><h3 id="JavaScript与HTML的结合"><a href="#JavaScript与HTML的结合" class="headerlink" title="JavaScript与HTML的结合"></a>JavaScript与HTML的结合</h3><pre><code>1. 使用一个标签    &lt;script type=&quot;text/javascript&quot;&gt;JavaScript代码&lt;/script&gt;2. 使用script引入外部标签文件    创建一个js文件，写js代码        &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt; 这样写的话 &lt;script&gt;&lt;/script&gt;中间的代码不会执行</code></pre><h3 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h3><h4 id="js的原始类型和声明变量"><a href="#js的原始类型和声明变量" class="headerlink" title="js的原始类型和声明变量"></a>js的原始类型和声明变量</h4><pre><code>1. string：字符串    var str=&quot;abc&quot;;2. number：数字类型    var m = 123;3. boolean：数字类型    var flag=true;4. null:对象引用为空5. undifined：定义了一个变量，但是这个变量没有赋值    var aa；用typeof（变量名）；查看当前变量的数据类型</code></pre><h4 id="js的语句"><a href="#js的语句" class="headerlink" title="js的语句"></a>js的语句</h4><pre><code>1.判断语句：     1. if语句    if(a == 5){        alert(&quot;5&quot;);    }else{        alert(&quot;不是5&quot;)        }    2. switch语句（支持所有的数据类型）    switch(变量){        case 5:操作;break;        case 6:操作;break;        case 7:操作;breal;        default:操作;break;    }2. 循环语句    1. for循环        for(var i=0; i&lt;10; i++){            alert(i);        }    2. whilt循环        var i=4;        whilt(i--){            alert(i);        }</code></pre><h4 id="js的运算符"><a href="#js的运算符" class="headerlink" title="js的运算符"></a>js的运算符</h4><pre><code>1. -2. +3. *4. /5. &amp;6. ++7. --8. +=9. -=</code></pre><h5 id="字符串加减"><a href="#字符串加减" class="headerlink" title="字符串加减"></a>字符串加减</h5><pre><code>j=123alert(j/1000*1000)java中输出的 0； 但是JavaScript中输出的 123；js中不区分整形浮型点var str = &quot;457&quot;alert(str+1);Java和JavaScript中输出的都是4571; 加法做的是字符串相见alert(str-1);JavaScript输出的是 456，即进行了减法运算alert(&quot;abc&quot;-1);JavaScript输出NAN，提示错误，不是一个数字。 </code></pre><h5 id="Boolean的操作"><a href="#Boolean的操作" class="headerlink" title="Boolean的操作"></a>Boolean的操作</h5><pre><code>var flag=true;alert(flag+1);JavaScript中输出的是 2。也就是说 true = 1；反之，flase = 0。</code></pre><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=== 和 == 的区别"></a>=== 和 == 的区别</h5><pre><code>JavaScript中， == 用于判断两个参数的值是否相等 === 用于判断两个参数 类型和值是否都相等    例如：        var x = &quot;5&quot;, y = 5;        x == y 则为 true        x === y 则为false</code></pre><h4 id="引入知识"><a href="#引入知识" class="headerlink" title="引入知识"></a>引入知识</h4><pre><code>直接向页面输出的语句（可以直接把内容显示在页面上）document.write(&quot;aaa&quot;);document.write(&quot;&lt;hr /&gt;&quot;);可以直接写入数据，也可以写入html代码，当然也可以混合都写</code></pre><h3 id="js的数组"><a href="#js的数组" class="headerlink" title="js的数组"></a>js的数组</h3><pre><code>js数组中，写什么都可以,可以是数据的混合，可以同时包括int，string或者其他类型</code></pre><h4 id="定义数组的三种方式"><a href="#定义数组的三种方式" class="headerlink" title="定义数组的三种方式"></a>定义数组的三种方式</h4><pre><code>1. var arr=[1,2,&quot;34&quot;];2. 使用内置的对象 Array对象    var arr = new Array(5);//定义一个数组，数组长度是53. 使用内置对象 Array对象    var arr2 = new Array(3,4,5);//定义一个数组，数组里面的元素为 3，4，5</code></pre><h4 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h4><pre><code>length：表示数组的长度    var len = arr.length;数组的长度是可以变的数组可以存放不同的数据类型的数据</code></pre><h3 id="js的函数"><a href="#js的函数" class="headerlink" title="js的函数"></a>js的函数</h3><h4 id="在js里面定义函数有三种定义方式"><a href="#在js里面定义函数有三种定义方式" class="headerlink" title="在js里面定义函数有三种定义方式"></a>在js里面定义函数有三种定义方式</h4><pre><code>1. 关键字：function    funciton 方法名（参数列表）{        方法体；        返回值；（返回值可有可无）    }2. 匿名函数：function    var func = funtion （参数列表）{        方法体和返回值；    }    调用直接  func();3. 内部对象：Function（用的少，了解就行）`动态函数`    var func = new Function(&quot;参数列表&quot;，“方法体和返回值”);    var test = new Function(&quot;x,y&quot;,&quot;var sum;sum=x+y;return sum;&quot;);</code></pre><h3 id="js的全局变量和局部变量"><a href="#js的全局变量和局部变量" class="headerlink" title="js的全局变量和局部变量"></a>js的全局变量和局部变量</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><pre><code>在script标签内部顶一个变量，这个变量在页面中js部分都可以使用</code></pre><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><pre><code>在方法内部定义一个变量，只能在方法内部使用</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>全局变量：    &lt;script&gt;        var a = 10;        function func(){            alert(a);        }        func();    &lt;/script&gt;    &lt;script&gt;        alert(a);    &lt;/script&gt;    可以跨script标签使用的变量。称之为全局变量局部变量：    &lt;script&gt;        function func(){            var a = 10;            alert(a);        }        func();        alert(a);//报错    &lt;/script&gt;    局部变量只能在方法内部使用</code></pre><h3 id="script应该放的位置"><a href="#script应该放的位置" class="headerlink" title="script应该放的位置"></a>script应该放的位置</h3><h4 id="位置差别"><a href="#位置差别" class="headerlink" title="位置差别"></a>位置差别</h4><pre><code>&lt;script&gt;原则上放任意位置都可以执行，但是还是要注意位置html文档是从上到下解析的，如果用js去获得html的标签，一定要在获取标签的后面，不然会得到一个 null 的变量，导致错误。</code></pre><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><pre><code>把script标签放到&lt;/body&gt;后面，&lt;/html&gt;前面</code></pre><h4 id="js的重载"><a href="#js的重载" class="headerlink" title="js的重载"></a>js的重载</h4><pre><code>function add1(a, b){ return a+b }function add1(a, b, c){ return a+b+c }function add1(a, b, c, d){ return a+b+c+d }add1(2,3)    add(2,2,3)    add(2,2,3,3)第一个得出结果NAN，第二个得出结果NAN，第三个得出正确结果</code></pre><h5 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h5><h3 id="JavaScript基础DOM"><a href="#JavaScript基础DOM" class="headerlink" title="JavaScript基础DOM"></a>JavaScript基础DOM</h3><h4 id="js的String对象"><a href="#js的String对象" class="headerlink" title="js的String对象"></a>js的String对象</h4><h5 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h5><h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><pre><code>只有一个需要注意：length  字符串的长度</code></pre><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><p>####### 与html相关的方法<br>    设置数据样式的方法</p><pre><code>1. bold() 使用粗体显示字符串  document.write(str.bold());2. fontcolor() 使用指定的颜色来显示字符串  document.write(str.fontcolor(&quot;red&quot;));3. fontsize() 使用指定的尺寸来显示字符串  document.wirte(str.fontsize(1));//参数值为1~74. link() 将字符串显示为链接  document.write(str.link(www.baidu.com));//即字符串成为一个超链接5. big() 用大号字体显示字符串  document.write(str.big());6. blink() 显示闪动字符串  document.write(str.blink());7. sup() 把字符串显示为上标  8. sub() 把字符串显示为下标  9. small() 使用小字号来显示字符串 10. strike() 使用删除线来显示字符串  </code></pre><p>####### 与Java相似的方法<br>    对数据进行操作的方法</p><pre><code>1. split() 把字符串分割为字符串数组  2. charAt() 返回在指定位置的字符  str.cjarAt(1);3. concat() 连接字符串  str.concat(str2);4. indexOf() 检索字符串  str.indexof(&quot;as&quot;);//不存在返回-15. charCodeAt() 返回在指定的位置的字符的 Unicode 编码   6. fixed() 以打字机文本显示字符串  7. fromCharCode() 从字符编码创建一个字符串  8. italics() 使用斜体显示字符串  9. lastIndexOf() 从后向前搜索字符串  10. localeCompare() 用本地特定的顺序来比较两个字符串  11. match() 找到一个或多个正则表达式的匹配  12. replace() 替换与正则表达式匹配的子串  str.replace(&quot;a&quot;, &quot;c&quot;);//把a替换成c13. search() 检索与正则表达式相匹配的值  14. slice() 提取字符串的片断，并在新的字符串中返回被提取的部分   15. substr() 从起始索引号提取字符串中指定数目的字符  str.substr(start, length);截取从start开始长度为length的字符串16. substring() 提取字符串中两个指定的索引号之间的字符  str.substring(start, end);截取从start开始 end 截至的字符串17. toLocaleLowerCase() 把字符串转换为小写  18. toLocaleUpperCase() 把字符串转换为大写  19. toLowerCase() 把字符串转换为小写  20. toUpperCase() 把字符串转换为大写  21.    toSource() 代表对象的源代码  22. toString() 返回字符串   23. valueOf() 返回某个字符串对象的原始值  </code></pre><h3 id="js的Date对象"><a href="#js的Date对象" class="headerlink" title="js的Date对象"></a>js的Date对象</h3><pre><code>js获取当前事件    var date = new Date();</code></pre><h4 id="Date对象的方法"><a href="#Date对象的方法" class="headerlink" title="Date对象的方法"></a>Date对象的方法</h4><pre><code>1. toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串 date.toLocaleString();2. toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串3. toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串4. setFullYear() 设置 Date 对象中的年份（四位数字）5. setMonth() 设置 Date 对象中月份 (0 ~ 11) 注意是 0~11，而不是1~12 ！！！！6. setHours() 设置 Date 对象中的小时 (0 ~ 23)7. setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)8. setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)9. setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)10. getFullYear() 从 Date 对象以四位数字返回年份11. getMonth() 返回 Date 对象的月份 (0~11)  setMonth() 设置 Date 对象中月份 (0 ~ 11)。 12. getHours() 返回 Date 对象的小时 (0 ~ 23)13. getMinutes() 返回 Date 对象的分钟 (0 ~ 59) 14. getSeconds() 返回 Date 对象的秒数 (0 ~ 59)15. getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)16. getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 </code></pre><h3 id="js的Math对象"><a href="#js的Math对象" class="headerlink" title="js的Math对象"></a>js的Math对象</h3><pre><code>全都是静态方法，调用函数时直接    Math.方法名（参数）</code></pre><h4 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h4><pre><code>1. abs(x) 返回数的绝对值2. acos(x) 返回数的反余弦值3. asin(x) 返回数的反正弦值4. atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值5. atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）6. ceil(x) 对数进行上舍入7. cos(x) 返回数的余弦8. exp(x) 返回 e 的指数9. floor(x) 对数进行下舍入10. log(x) 返回数的自然对数（底为e）11. max(x,y) 返回 x 和 y 中的最高值12. min(x,y) 返回 x 和 y 中的最低值13. pow(x,y) 返回 x 的 y 次幂14. random() 返回 0 ~ 1 之间的随机数15. round(x) 把数四舍五入为最接近的整数 16. sin(x) 返回数的正弦17. sqrt(x) 返回数的平方根18. tan(x) 返回角的正切19. toSource() 返回该对象的源代码20. valueOf() 返回 Math 对象的原始值 </code></pre><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4><pre><code>1. E 返回算术常量 e，即自然对数的底数（约等于2.718）2. LN2 返回 2 的自然对数（约等于0.693）3. LN10 返回 10 的自然对数（约等于2.302）4. LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）5. LOG10E 返回以 10 为底的 e 的对数（约等于0.434）6. PI 返回圆周率（约等于3.14159）7. SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）8. SQRT2 返回 2 的平方根（约等于 1.414）</code></pre><h3 id="js的全局函数"><a href="#js的全局函数" class="headerlink" title="js的全局函数"></a>js的全局函数</h3><pre><code>由于不属于任何一个对象，直接名称使用1. decodeURI()    解码某个编码的URI2. decodeURIComponent()        解码一个编码的URI组件3. encodeURI()    把字符串编码为URI4. encodeURIComponent()        把字符串编码为URI组件5. escape()        对字符串进行编码6. eval()        计算JavaScript字符串，并把它作为脚本代码来执行7. getClass()    返回一个javaObject的JavaClass8. isFinite()    检查某个值是否为有穷大的数9. isNaN（）        检查某个值是否是数字10. parseFloat()    解析一个字符串并返回一个浮点数11. parseInt()        解析一个字符串并返回一个整数12. unescape()        对由escape()编码的字符串进行解码</code></pre><h2 id="js函数的重载"><a href="#js函数的重载" class="headerlink" title="js函数的重载"></a>js函数的重载</h2><h3 id="js的重载是否存在？"><a href="#js的重载是否存在？" class="headerlink" title="js的重载是否存在？"></a>js的重载是否存在？</h3><pre><code>不存在重载。函数名相同的以后定义的为准。也就是说方法名相同的情况下，后定义的会覆盖掉先定义的方法。</code></pre><h3 id="js可以通过其他的方式去模拟重载"><a href="#js可以通过其他的方式去模拟重载" class="headerlink" title="js可以通过其他的方式去模拟重载"></a>js可以通过其他的方式去模拟重载</h3><pre><code>在js的函数中，传入的参数列表，可以通过一个js自带的 aruguments[]数组去访问传入的参数。例如：    function add(a, b, c){        arguments[0] == a;        arguments[1] == b;        arguments[2] == c;    }js的函数你可以传入多个参数，例如 add(1,2,3,4,5,6)，虽然定义的 add函数只有三个参数，但是通过arguments可以获得 传入的所有参数 1,2,3,4,5,6 只是 a=1,b=2,c=3 罢了通过arguments.length 判断传入参数大小，以此来手动进行重载</code></pre><h2 id="js的bom对象"><a href="#js的bom对象" class="headerlink" title="js的bom对象"></a>js的bom对象</h2><pre><code>bom：broswer object model 浏览器对象模型通过bom对象，可以直接对浏览器进行操作。</code></pre><h3 id="有哪些对象"><a href="#有哪些对象" class="headerlink" title="有哪些对象"></a>有哪些对象</h3><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>Navigator 对象包含有关浏览器的信息。</code></pre><h5 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. appCodeName 返回浏览器的代码名 2. appMinorVersion 返回浏览器的次级版本3. appName 返回浏览器的名称    alert(navigator.appName);4. appVersion 返回浏览器的平台和版本信息5. browserLanguage 返回当前浏览器的语言6. cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值7. cpuClass 返回浏览器系统的 CPU 等级8. onLine 返回指明系统是否处于脱机模式的布尔值9. platform 返回运行浏览器的操作系统平台10. systemLanguage 返回 OS 使用的默认语言11. userAgent 返回由客户机发送服务器的 user-agent 头部的值12. userLanguage 返回 OS 的自然语言设置 </code></pre><h5 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. javaEnabled() 规定浏览器是否启用 Java2. taintEnabled() 规定浏览器是否启用数据污点 (data tainting)</code></pre><h4 id="screen（屏幕对象）"><a href="#screen（屏幕对象）" class="headerlink" title="screen（屏幕对象）"></a>screen（屏幕对象）</h4><pre><code>Screen 对象包含有关客户端显示屏幕的信息。</code></pre><h5 id="对象属性-1"><a href="#对象属性-1" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)2. availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)3. bufferDepth 设置或返回调色板的比特深度4. colorDepth 返回目标设备或缓冲器上的调色板的比特深度5. deviceXDPI 返回显示屏幕的每英寸水平点数6. deviceYDPI 返回显示屏幕的每英寸垂直点数7. fontSmoothingEnabled 返回用户是否在显示控制面板中启用了字体平滑 8. height 返回显示屏幕的高度9. logicalXDPI 返回显示屏幕每英寸的水平方向的常规点数10. logicalYDPI 返回显示屏幕每英寸的垂直方向的常规点数11. pixelDepth 返回显示屏幕的颜色分辨率（比特每像素）9 12. updateInterval 设置或返回屏幕的刷新率13. width 返回显示器屏幕的宽度。 </code></pre><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><pre><code>对象包含有关当前 URL 的信息。</code></pre><h5 id="对象属性-2"><a href="#对象属性-2" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. ash 设置或返回从井号 (#) 开始的 URL（锚）2. host 设置或返回主机名和当前 URL 的端口号3. hostname 设置或返回当前 URL 的主机名4. href 设置或返回完整的 URL`(重点)`     1. location.href;//得到当前请求的url地址。    2. location.href=&quot;你要跳转的地址,例如：www.baidu.com&quot;这样就会跳转页面5. pathname 设置或返回当前 URL 的路径部分6. port 设置或返回当前 URL 的端口号7. protocol 设置或返回当前 URL 的协议8. search 设置或返回从问号 (?) 开始的 URL（查询部分）</code></pre><h5 id="对象方法-1"><a href="#对象方法-1" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. assign() 加载新的文档2. reload() 重新加载当前文档3. replace() 用新的文档替换当前文档。 </code></pre><h4 id="history（历史）"><a href="#history（历史）" class="headerlink" title="history（历史）"></a>history（历史）</h4><pre><code>请求的url的历史记录</code></pre><h5 id="对象属性-3"><a href="#对象属性-3" class="headerlink" title="对象属性"></a>对象属性</h5><pre><code>1. length 返回浏览器历史列表中的 URL 数量</code></pre><h5 id="对象方法-2"><a href="#对象方法-2" class="headerlink" title="对象方法"></a>对象方法</h5><pre><code>1. back() 加载 history 列表中的前一个 URL  history.back()2. forward() 加载 history 列表中的下一个 URL    history.forward()3. go() 加载 history 列表中的某个具体页面</code></pre><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><pre><code>Window 对象表示浏览器中打开的窗口。包含location,navicator,history,screen对象它是一个顶层对象</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><pre><code>opener 获得创建窗口的窗口 即用a.html打开b.html，在b.html中通过window.opener获得a.html的窗口对象</code></pre><h5 id="对象方法（都要记住）"><a href="#对象方法（都要记住）" class="headerlink" title="对象方法（都要记住）"></a>对象方法（都要记住）</h5><pre><code>1. alert() 显示带有一段消息和一个确认按钮的警告框2. blur() 把键盘焦点从顶层窗口移开3. clearInterval() 取消由 setInterval() 设置的 timeout     1. window.clearInterval(id);    2. id为 setInterval()返回的id值4. clearTimeout() 取消由 setTimeout() 方法设置的 timeout    1. window.clearTimeout(id);    2. id为 setTimeout()返回的id值5. close() 关闭浏览器窗口    1. windown.close();    2. 浏览器兼容性差6. confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框    1. window.confirm(&quot;传入的消息&quot;)    2. 返回一个Boolean类型值。确定为ture，取消为false7. createPopup() 创建一个 pop-up 窗口8. focus() 把键盘焦点给予一个窗口 9. moveBy() 可相对窗口的当前坐标把它移动指定的像素10. moveTo() 把窗口的左上角移动到一个指定的坐标11. open() 打开一个新的浏览器窗口或查找一个已命名的窗口     1. window.open(URL, name, features, replace);    2. url 要打开页面的url  name 自己定,可以不要 features 窗口特征 宽高    3. window.open(&quot;www.baodu.com&quot;,&quot;&quot;,&quot;width=200,height=200&quot;);12. print() 打印当前窗口的内容 13. prompt() 显示可提示用户输入的对话框    1. window.prompt(&quot;提示输入的值&quot;,&quot;默认的文本框的内容&quot;)；    2. 现在用的少，因为不好看，还不能改样式表14. resizeBy() 按照指定的像素调整窗口的大小15. resizeTo() 把窗口的大小调整到指定的宽度和高度 16. scrollBy() 按照指定的像素值来滚动内容17. scrollTo() 把内容滚动到指定的坐标 18. setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式     1. 一般用来做定时器,有一个返回值ID，代表这个定时器    2. window.setInterval(&quot;js代码&quot;,毫秒数);    3. 1s = 1000ms    4. 例如：window.setInterval(&quot;alert(&apos;123&apos;);&quot;, 3000);19. setTimeout() 在指定的毫秒数后调用函数或计算表达式    1. 一般用来做定时器，但是只会执行一次。返回一个ID值，代表这个定时器    2. 例如：window.setTimeout(&quot;alert(&apos;123&apos;);&quot;, 4000);</code></pre><h2 id="js的dom对象"><a href="#js的dom对象" class="headerlink" title="js的dom对象"></a>js的dom对象</h2><h3 id="什么是dom"><a href="#什么是dom" class="headerlink" title="什么是dom"></a>什么是dom</h3><pre><code>dom：document object model：文档对象模型文档：超文本标记文档：html，xml对象：提供了属性和方法模型：使用属性和方法操作超文本标记型文档可以使用js里面的dom里面提供的对象，使用这些对象的属性和方法，对标记型文档进行操作想要对标记型文档进行操作，首先需要 对标记型文档里面的所有内容封装成对象，需要把HTML里面的标签，属性，文本内容都封装成对象要想对标记型文档进行操作，解析标记型文档</code></pre><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><pre><code>根据html的层级结构，在内存中分配一个属性结构，需要把html中的每部分封装成对象</code></pre><p><img src="https://i.imgur.com/T6dN6Cg.png" alt=""></p><pre><code>1. 上图中，整个蓝色框住的可以当成一个document对象，表示整个HTML文档2. 同时一个标签/元素也是一个对象，我们成为标签对象 element3. 属性对象（id属性之类的）4. 文本对象（标签括起来的数据）5. Node（节点）对象是属性，文本，标签对象的父对象</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre><code>nodeName    String        节点的名字：根据节点的类型定义nodeValue    String        节点的值：根据节点的类型而定义nodeType    Number        节点的类型常量值之一ownerDocument    Document    指向整个节点所属的文档firstChild    Node        指向在childNodes列表中的第一个节点lastChild    Node        指向在childNodes列表中的最后一个节点childNodes    NodeList    所有子节点的列表parentNode    Node        返回一个给定节点的父亲节点previousSibling    Node    指向前一个兄弟节点：如果这个节点就是第一个兄弟节点，那么值为nullnextSibling    Node        指向后一个兄弟节点hasChildNodes()    Boolean    当childNodes包含一个或多个节点时，返回真attributes    NameNodeMap    包含了代表一个元素的特性的Attr对象，仅用于Element节点appendChild(node)    Node    将node添加到childNodes的末尾removeChild(node)    Node    从childNodes中删除nodereplaceChild(newnode, node)    Node    替换insertBefore(newnode, refnode)    Node    在ChildNodes中的refnode之前插入newnode</code></pre><h3 id="DHTML"><a href="#DHTML" class="headerlink" title="DHTML"></a>DHTML</h3><pre><code>DHTML是很多技术的简称DHTML=html+css+dom+javascripthtml：封装数据css：使用属性和属性值设置样式dom：操作html文档JavaScript：专门指的是js的语法语句</code></pre><h3 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h3><pre><code>每个载入浏览器的HTML文档都会成为document对象</code></pre><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><pre><code>1. cookie 设置或返回与当前文档有关的所有 cookie2. domain 返回当前文档的域名3. lastModified 返回文档被最后修改的日期和时间4. referrer 返回载入当前文档的文档的 URL5. title 返回当前文档的标题6. URL 返回当前文档的 URL</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>1. close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据2. getElementById() 返回对拥有指定 id 的第一个对象的引用3. getElementsByName() 返回带有指定名称的对象集合4. getElementsByTagName() 返回带有指定标签名的对象集合5. open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出6. write() 向文档写 HTML 表达式 或 JavaScript 代码7. writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符</code></pre><h3 id="案例：在末尾添加节点"><a href="#案例：在末尾添加节点" class="headerlink" title="案例：在末尾添加节点"></a>案例：在末尾添加节点</h3><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;&lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1();&quot; /&gt;&lt;script&gt;    //任务是，点击按钮，添加一行 555 在 444 后面    function add1(){        var ul = document.getElementById(&quot;ulid&quot;);        var text = document.createTextNode(&quot;555&quot;);        var li = document.createElement(&quot;li&quot;);        li.appendChild(text);        ul.appendChild(li);    }&lt;/script&gt;</code></pre><h3 id="元素对象-element对象"><a href="#元素对象-element对象" class="headerlink" title="元素对象-element对象"></a>元素对象-element对象</h3><pre><code>在 HTML DOM 中，Element 对象表示 HTML 元素。Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点。NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。要操作element对象，首先必须要获取到element，使用document里面对应的方法获取</code></pre><h4 id="操作element对象的属性"><a href="#操作element对象的属性" class="headerlink" title="操作element对象的属性"></a>操作element对象的属性</h4><pre><code>1. 获取属性：getAttribute(name)方法2. 设置属性：setAttribute(name, valure)方法    例如：input1.setAttribute(&quot;class&quot;,&quot;haha&quot;);    这是 input1元素的class为haha3. 删除属性：removeAttribute(name)方法    不能删除value属性</code></pre><h4 id="获得element中的element对象"><a href="#获得element中的element对象" class="headerlink" title="获得element中的element对象"></a>获得element中的element对象</h4><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var ull = document.getElementById(&quot;ulid&quot;);    var lis = ull.childNodes;    alert(lis.length);&lt;/script&gt;</code></pre><p><code>上面的代码在IE中输出4， 在火狐中输出9</code>  </p><pre><code>因为火狐把 回车 空格 也算作数据了</code></pre><p><code>所以直接通过childNodes直接获得准确的子类是不现实的</code></p><pre><code>在Element对象的范围内，可以用来查找其他节点的唯一有效方法就是getElementsByTagName()方法。上面的例子中，直接通过 ull.getElementsByTagName(&quot;li&quot;)获得子Element对象就行了。</code></pre><h3 id="Node对象"><a href="#Node对象" class="headerlink" title="Node对象"></a>Node对象</h3><h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><pre><code>1. nodeName        节点名称2. nodeType        节点类型3. nodeValue    节点的值</code></pre><h5 id="标签节点对应的值"><a href="#标签节点对应的值" class="headerlink" title="标签节点对应的值"></a>标签节点对应的值</h5><pre><code>nodeType    1nodeName    大写的标签名称 nodeValue    null</code></pre><h5 id="属性节点对应的值"><a href="#属性节点对应的值" class="headerlink" title="属性节点对应的值"></a>属性节点对应的值</h5><pre><code>获取方法 getAttributeNode(&quot;属性名称&quot;);nodeType    2nodeName    属性名称nodeValue    属性的值</code></pre><h5 id="文本节点对应的值"><a href="#文本节点对应的值" class="headerlink" title="文本节点对应的值"></a>文本节点对应的值</h5><pre><code>获取方法 element.firstChild 或者 lastChildnodeType    3nodeName    #textnodeValue    文本内容</code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>使用dom解析html的时候，需要html里面的标签，属性和文本都封装成对象&lt;span id=&quot;spanid&quot;&gt;呵呵呵&lt;/span&gt;&lt;script&gt;    //标签节点    var span1 = document.getElementById(&quot;spanid&quot;);    alert(span1.nodeType);    //输出    1    alert(Span1.nodeName);    //输出    SPAN    alert(span1.nodeValue);    //输出    null    //属性节点    var id1 = span1.getAttributeNode(&quot;id&quot;);    alert(id1.nodeType);    //输出    2    alert(id1.nodeName);    //输出    id    alert(id1.nodeValue);    //输出    spanid    //文本节点    var text = span1.firstChild;    alert(text.nodeType);    //输出    3    alert(text.nodeName);    //输出    #text    alert(text.nodeValue);    //输出    呵呵呵&lt;/script&gt;</code></pre><h3 id="父节点，子节点，同辈节点"><a href="#父节点，子节点，同辈节点" class="headerlink" title="父节点，子节点，同辈节点"></a>父节点，子节点，同辈节点</h3><pre><code>&lt;ul id=&quot;ulid&quot;&gt;    &lt;li&gt;111&lt;/li&gt;    &lt;li&gt;222&lt;/li&gt;    &lt;li&gt;333&lt;/li&gt;    &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;ul 是 li 的父节点， li 是 ul 的子节点li 与 li 是 同辈节点，因为他们是同一级</code></pre><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><pre><code>parentNode</code></pre><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><pre><code>childNodes的到所有的子节点，但是兼容性查firstChild    第一个子节点lastChild    最后一个子节点</code></pre><h4 id="同辈节点"><a href="#同辈节点" class="headerlink" title="同辈节点"></a>同辈节点</h4><pre><code>nextSibling        下一个子节点previousSibling    前一个子节点</code></pre><h3 id="操作DOM树"><a href="#操作DOM树" class="headerlink" title="操作DOM树"></a>操作DOM树</h3><h4 id="appendChild方法"><a href="#appendChild方法" class="headerlink" title="appendChild方法"></a>appendChild方法</h4><pre><code>添加子节点到末尾特点：类似于剪切粘贴的效果</code></pre><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><h6 id="CSS内容"><a href="#CSS内容" class="headerlink" title="CSS内容"></a>CSS内容</h6><pre><code>#div1{    width:200px;    height:150px;    border:2px solid red;}#div2{    width:250px;    height:150px;    border: 5px dashed green;}</code></pre><h6 id="HTML内容"><a href="#HTML内容" class="headerlink" title="HTML内容"></a>HTML内容</h6><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;ul id=&quot;ulidll&quot;&gt;        &lt;li&gt;123&lt;/li&gt;        &lt;li&gt;456&lt;/li&gt;        &lt;li&gt;789&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;add&quot; onclick=&quot;add1()&quot; /&gt;</code></pre><h6 id="js内容"><a href="#js内容" class="headerlink" title="js内容"></a>js内容</h6><pre><code>function add1(){    var div2 = document.getElementById(&quot;div2&quot;);    var ull = document.getElementById(&quot;ulidll&quot;);    div2.appendChild(ull);}通过结果可以看到，ul 的内容 从 div1 移动到 div2 中。</code></pre><h4 id="insertBefore-newnode-oldNode-方法"><a href="#insertBefore-newnode-oldNode-方法" class="headerlink" title="insertBefore(newnode, oldNode)方法"></a>insertBefore(newnode, oldNode)方法</h4><pre><code>在oldnode节点之前插入一个新的节点1. 创建标签    li2 = document.createElement(&quot;li&quot;);2. 创建文本    text = document.createTextNode(&quot;啦啦啦啦&quot;);3. 把文本添加到标签下    li2.appendChild(text);4. 获取 oldNode    var li3=document.getElementById(&quot;li3&quot;);5. 插入    var ul = document.getElementById(&quot;ul1&quot;);//获得父节点    ul.insertBefore(li2, li3);</code></pre><h4 id="removeChilid-删除节点"><a href="#removeChilid-删除节点" class="headerlink" title="removeChilid 删除节点"></a>removeChilid 删除节点</h4><pre><code>只能通过父节点删除，不能自己删自己1. 获取要删除标签    var li3 = document.getElementById(&quot;li3&quot;);2. 获取父节点    var par = document.getElementById(&quot;ul&quot;);3. 删除    par.removeChild(li3);</code></pre><h4 id="replaceChild-newnode-oldnode-替换节点"><a href="#replaceChild-newnode-oldnode-替换节点" class="headerlink" title="replaceChild(newnode, oldnode)替换节点"></a>replaceChild(newnode, oldnode)替换节点</h4><pre><code>只能通过父节点进行替换，不能自己替换自己1. 创建新节点    var li = document.createElement(&quot;li&quot;);    var text = document.createTextNode(&quot;文本内容&quot;);    li.appenChild(text);2. 获取旧节点    var oldli = document.getElementById(&quot;oldli&quot;);3. 获取父标签    var ul = document.getElementById(&quot;ul&quot;);4. 替换标签    ul.replaceChild(li, oldli);</code></pre><h4 id="cloneNode-boolean-复制节点"><a href="#cloneNode-boolean-复制节点" class="headerlink" title="cloneNode(boolean) 复制节点"></a>cloneNode(boolean) 复制节点</h4><pre><code>//复制ul列表到另一个div中1. 获取ul    var ul = document.getElementById(&quot;ul&quot;);2. 复制ul，放到类似于剪切板里面    var copyul = ul.cloneNode(true);3. 获取新的div    var newdiv = document.getElementById(&quot;newdiv&quot;);4. 复制进去    newdiv.appendChild(copyul);            因为 copyul 是复制的新的，所以appendChild的剪贴方法并不会删除掉原 ul</code></pre><h3 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h3><pre><code>1. 浏览器几乎都支持该属性，但不是DOM标准的组成部分2. innerHTML属性可以用来读某给定元素里的HTML内容    var span1 = document.getElementById(&quot;span1&quot;);    alert(span1.innerHTML);//获取文本内容3. innerHTML属性可以用来写给定元素里的html内容    var div1 = document.getElementById(&quot;div1&quot;);    div1.innerHTML += &quot;&lt;h1&gt;AAA&lt;/h1&gt;&quot;;</code></pre><h3 id="案例：动态显示时间"><a href="#案例：动态显示时间" class="headerlink" title="案例：动态显示时间"></a>案例：动态显示时间</h3><pre><code>1. 获取当前时间：    var date = new Date();    date = date.toLocaleString();2. 需要让页每秒执行    setInterval()方法3. 用一个&lt;span&gt;来承接时间    function gettime(){        var date = new Date();        date = date.toLocaleString();        var div = document.getElementsById(&quot;time&quot;);        div.innerHtml = date;     }    //使用定时器，每秒写一次    setInterval(&quot;gettime();&quot;, 1000);</code></pre><h3 id="案例：一键全选"><a href="#案例：一键全选" class="headerlink" title="案例：一键全选"></a>案例：一键全选</h3><pre><code>&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt;    排球&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt;    篮球&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt;    足球&lt;input type=&quot;checkbox&quot; name=&quot;lova&quot; /&gt;    羽毛球&lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;setall();&quot;/&gt;&lt;input type=&quot;button&quot; value=&quot;全不选&quot; onclick=&quot;setNo();&quot;/&gt;&lt;script&gt;    // 复选框中 的 chexked = true 即为选中，反之为没选中    function setall(){        //获取复选框        var loves = document.getElementsByName(&quot;love&quot;);        //遍历 loves 数组，整体修改值        for(var i=0; i&lt;loves.length; i++)        {            var love1 = loves[i];            love1.checked = true;        }    }&lt;/script&gt;</code></pre><h3 id="案例：省市联动"><a href="#案例：省市联动" class="headerlink" title="案例：省市联动"></a>案例：省市联动</h3><pre><code>选择 湖北省的时候，只会显示湖北省的市，选择湖南省的时候，只会显示湖南省的市&lt;select id=&quot;sheng&quot; onchange=&quot;add1();&quot;&gt;    &lt;option&gt;湖北省&lt;/option&gt;    &lt;option&gt;湖南省&lt;/option&gt;    &lt;option&gt;山西省&lt;/option&gt;    &lt;option&gt;江西省&lt;/option&gt;&lt;/select&gt;&lt;select id=&quot;shi&quot;&gt;&lt;/select&gt;// onchange 是 当 select 改变的时候执行的操作&lt;script&gt;    //通过数据库，可以获得每个省份，有哪些城市    var arr = [];//arr存的读取的城市    var select = document.getElementById(&quot;shi&quot;);    //一定要先清空 select，否则第二次选择会进行二次添加    var chils = select.getElementsByTagName(&quot;option&quot;);    for(var i=child.length-1; i&gt;=0; i--){        var op = option[i];        select.removeChild(op);    }    for(int i=0; i&lt;arr.length; i++){        var opt = document.createElement(&quot;option&quot;);        var text = document.createTextNode(arr[i]);        opt.appendChild(text);        select.appendChild(opt);    }&lt;/script&gt;</code></pre><h2 id="XML文档"><a href="#XML文档" class="headerlink" title="XML文档"></a>XML文档</h2><h3 id="什么是xml"><a href="#什么是xml" class="headerlink" title="什么是xml"></a>什么是xml</h3><pre><code>eXtensible Markup Language：可扩展标记型语言1. 标记型语言：html也是标记型语言，通过使用标签来操作2. 可扩展：html里面每个标签都是固定的，有特定的含义。xml中，标签可以自定义，也可以是中文的标签3. xml技术是W3C组织发部分，目前遵循的是2000发布的XML1.0规范</code></pre><h3 id="xml的用途"><a href="#xml的用途" class="headerlink" title="xml的用途"></a>xml的用途</h3><pre><code>html用于显示数据，xml也可以用来显示数据，但是更主要的功能和目的是同来存储数据。1. 用于不同系统之间传输数据    1. 如果数据直接用 字符串 传输，接收方并不能解析数据         例如：&quot;120.0.0.1;2018.10.01;hello world&quot;发送方知道这是 &quot;ip地址，时间，内容&quot;，但是接收方并不知道    2.  &lt;message&gt;            &lt;ip&gt;120.0.0.1&lt;/ip&gt;            &lt;time&gt;2018.10.01&lt;time&gt;            &lt;content&gt;hello world&lt;/content&gt;        &lt;/message&gt;    3. 这样写接收方能懂，并且可以扩展更多标签在&lt;message&gt;中2. 同来表示生活中有关系的数据    例如：    &lt;中国&gt;        &lt;湖北&gt;            &lt;武汉&gt;&lt;/武汉&gt;                &lt;荆州&gt;&lt;/荆州&gt;        &lt;/湖北&gt;        &lt;湖南&gt;        &lt;/湖南&gt;    &lt;中国&gt;3. 经常用在配置文件    1. 用于链接数据库，例如用于存储用户密码，修改密码值用修改xml中的密码、</code></pre><h3 id="xml的语法"><a href="#xml的语法" class="headerlink" title="xml的语法"></a>xml的语法</h3><h4 id="xml的文档声明"><a href="#xml的文档声明" class="headerlink" title="xml的文档声明"></a>xml的文档声明</h4><pre><code>创建文件，后缀名为 .xml</code></pre><p>#####写一个文档声明，必须写在第一行第一列<br>    &lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p><h6 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h6><pre><code>version：xml的版本 1.0，1.1encoding：xml 编码  gbk utf-8 iso8859-1standalone：yes/no 表示xml文件是否可以独立存在</code></pre><h4 id="声明元素（标签）"><a href="#声明元素（标签）" class="headerlink" title="声明元素（标签）"></a>声明元素（标签）</h4><h5 id="标签的定义"><a href="#标签的定义" class="headerlink" title="标签的定义"></a>标签的定义</h5><pre><code>1. 标签定义有开始必须有结束：&lt;person&gt;&lt;/person&gt;2. 标签没有内容，也可以标签内结束：&lt;person /&gt;3. 标签可以嵌套，必须要合理嵌套4. 一个xml文档有且必须只有一个根标签5. 标签的包含的空格和换行会被解析成文本内容处理：&lt;person&gt;   1&lt;person&gt; 和 &lt;person&gt;1&lt;/person&gt;是不一样的6. xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致7. 标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头8. 不能包括 ‘&lt; &gt; , $’9. 标签名尽量不要出现英文冒号“:”, 除非是在使用名空间10. 标签名不能以字符“xml”等任意大小写组合开始11. 标签名不能包含空格</code></pre><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><pre><code>html是标记型文档，所以标签有属性。同理，xml也可以用属性&lt;person id1=&quot;aa&quot;&gt;&lt;/person&gt;</code></pre><h5 id="属性定义的要求"><a href="#属性定义的要求" class="headerlink" title="属性定义的要求"></a>属性定义的要求</h5><pre><code>1. 一个标签上可以有多个属性2. 同一个标签，不能有属性名相同的属性3. 属性值一定要用引号，单引号，双引号都行4. 属性名的命名规范和标签命名规范相同</code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre><code>写法&lt;!-- 注释的内容 --&gt;注释不能嵌套</code></pre><h4 id="特殊字符-amp-amp-CDATA区"><a href="#特殊字符-amp-amp-CDATA区" class="headerlink" title="特殊字符 &amp;&amp; CDATA区"></a>特殊字符 &amp;&amp; CDATA区</h4><pre><code>开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。解决方法：    1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）：        &amp;lt;       ---&gt;     &quot;&lt;&quot;   小于符号        &amp;gt;      ---&gt;     &quot;&gt;&quot;   大于符号        &amp;amp;      ---&gt;     &quot;&amp;&quot;   and符号 &amp;        &amp;apos;    ---&gt;     &quot;&apos;&quot;     英文单引号        &amp;quot;    ---&gt;     &quot;&quot;&quot;     英文双引号    2. 使用CDATA标记        在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理        实体引用也会失去作用，变成纯文本        语法：        &lt;![CDATA[文本内容]]&gt;</code></pre><h4 id="PI指令（处理指令）"><a href="#PI指令（处理指令）" class="headerlink" title="PI指令（处理指令）"></a>PI指令（处理指令）</h4><pre><code>可以在xml中设置样式，其实就是外部引入css引入css：&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt;但是，对中文的标签元素不起作用，毕竟外国人定义的东西</code></pre><h3 id="xml的约束"><a href="#xml的约束" class="headerlink" title="xml的约束"></a>xml的约束</h3><pre><code>比如定义人的信息的xml，肯定不能出现猫猫狗狗的信息，所以需要约束由于xml的标签是自定义，所以不加约束容易出现问题。</code></pre><h4 id="dtd约束"><a href="#dtd约束" class="headerlink" title="dtd约束"></a>dtd约束</h4><pre><code>创建一个后缀名为 .dtd 的dtd文件步骤：1. 查看xml中有多少个元素    例如：        &lt;message&gt;            &lt;ip&gt;120.0.0.1&lt;/ip&gt;            &lt;time&gt;2018.10.01&lt;time&gt;            &lt;content&gt;hello world&lt;/content&gt;        &lt;/message&gt;    有四个元素（标签）2. 有多少个元素，就在dtd文件中写多少个&lt;!ELEMENT&gt;3. 判断元素是简单元素还是复杂元素    1. 有子元素的元素是复杂元素        &lt;!ELEMENT 元素名称(子元素名称逗号隔开)&gt;        &lt;!ELEMENT message(ip+,time？,content*)&gt;</code></pre><p>`其中 + ? * 是选择性加上，代表子标签在根标签下出现的次数</p><pre><code>1. +    代表出现一次或多次2. ？    代表出现0次或1次 3. *    打表出现0次或多次 默认是只出现一次`  </code></pre><p><code>逗号连接子元素名称时，子元素必须按顺序出现</code><br><code>用 | 隔开时，表示只能出现范围中的一个</code>  </p><pre><code>    2. 没有子元素的元素是简单元素        &lt;!ELEMENT 元素名称 (#PCDATA)&gt;        &lt;!ELEMENT ip (#PCDATA)&gt;        &lt;!ELEMENT time (#PCDATA)&gt;        &lt;!ELEMENT content (#PCDATA)&gt;4. 在xml中引入外部dtd文件，写在&lt;xml&gt;标签行下    &lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd文件路径&quot;&gt;4. 在xml内部定义dtd    &lt;!DOCTYPE 根元素名称[        &lt;!ELEMENT 子标签 (#PCDATA)&gt;    ]&gt;    例如：        &lt;!DOCTYPE message[            &lt;!ELEMENT ip (#PCDATA)&gt;            &lt;!ELEMENT time (#PCDATA)&gt;            &lt;!ELEMENT content (#PCDATA)&gt;        ]&gt;4. 使用外部/网络的dtd文件    &lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt;用浏览器打开的时候，浏览器之校验语法，不校验约束，所以用浏览器打开不能查看是否约束上</code></pre><h5 id="使用dtd定义属性"><a href="#使用dtd定义属性" class="headerlink" title="使用dtd定义属性"></a>使用dtd定义属性</h5><pre><code>语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 属性的约束&gt;1. 属性类型有三种    1. CDATA：表示属性的取值为普通的文本字符串    2. ENUMERATED：表示枚举，只能从枚举列表中任选其一 例如：（鸡肉|鸭肉|鱼肉|牛肉）这种方法定义枚举    3. ID：表示属性的取值不能重复，只能是字母，下划线开始2. 属性的约束有三种    1. #REQUIRED：表示该属性必须出现    2. #IMPLIED：表示该属性可有可无    3. #FIXED：表示属性的取值为一个固定值    4. 直接写一个值上去：表示属性的默认值为你直接协商的值例如：&lt;!ATTLIST ip ID1 CDATA &quot;wwww&quot;&gt; 则ID1属性的值默认为www</code></pre><h4 id="schema约束"><a href="#schema约束" class="headerlink" title="schema约束"></a>schema约束</h4><pre><code>空</code></pre><h3 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h3><pre><code>xml是标记型文档js使用dom解析标记型文档    根据html的层级结构，在内存中分配一个属性结构，把html的标签属性和文本封装成对象    document对象，element对象，属性对象，文本对象，node节点对象xml的解析方式：dom 和 sax</code></pre><h4 id="dom方式解析"><a href="#dom方式解析" class="headerlink" title="dom方式解析"></a>dom方式解析</h4><pre><code>根据 xml 的层级结构在内存中分配一个树形结构，把xml的标签，属性和文本都封装成对象    缺点：如果文件过大，造成内存溢出    优点：方便实现增删改操作</code></pre><h4 id="sax方式解析"><a href="#sax方式解析" class="headerlink" title="sax方式解析"></a>sax方式解析</h4><pre><code>采用事件驱动方式，边读便解析，从上到下，一行一行的解析，解析到某个对象，返回对象名称    缺点：不能实现增删改    优点：不会造成内存溢出，方便实现查询操作</code></pre><p><img src="https://i.imgur.com/bf6pKn0.png" alt=""></p><h4 id="dom和sax方式的解析器"><a href="#dom和sax方式的解析器" class="headerlink" title="dom和sax方式的解析器"></a>dom和sax方式的解析器</h4><pre><code>不同的公司和组织提供了针对dom和sax方式的解析器，通过api方式提供    1. sun公司提供    jaxp2. dom4j组织提供    dom4j（实际开发中用的比较多）3. jdom组织提供    jdom</code></pre><h4 id="jaxp的api的查看"><a href="#jaxp的api的查看" class="headerlink" title="jaxp的api的查看"></a>jaxp的api的查看</h4><pre><code>jaxp是javase的一部分jaxp解析器在jdk的javax.xml.parsers包里面DocumentBuilder            定义API，使其从xml文档获取DOM文档实例DocumentBuilderFactory    定义工厂API，是应用程序能够从xml文档获取生成DOM对象数的解析器SAXParser                定义包装XMLReader实现类的APISAXParserFactory        定义工厂API，是应用程序能够配置和获取基于sax的解析器以解析XML文档</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Html&quot;&gt;&lt;a href=&quot;#Html&quot; class=&quot;headerlink&quot; title=&quot;Html&quot;&gt;&lt;/a&gt;Html&lt;/h2&gt;&lt;h3 id=&quot;什么是Html？&quot;&gt;&lt;a href=&quot;#什么是Html？&quot; class=&quot;headerlink&quot; title=&quot;什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux 命令大全</title>
    <link href="http://yoursite.com/2018/09/27/linux-%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2018/09/27/linux-大全/</id>
    <published>2018-09-27T08:07:26.000Z</published>
    <updated>2018-10-01T08:12:26.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><pre><code>arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS </code></pre><h2 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h2><pre><code>shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 </code></pre><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><pre><code>cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </code></pre><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><pre><code>find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \*.rpm -exec chmod 755 &apos;{}&apos; \; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 </code></pre><h2 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h2><pre><code>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </code></pre><h2 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h2><pre><code>df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &apos;%10{SIZE}t%{NAME}n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=&apos;${Installed-Size;10}t${Package}n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </code></pre><h2 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h2><pre><code>groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户 grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </code></pre><h2 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><pre><code>ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 </code></pre><h2 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h2><pre><code>chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 </code></pre><h2 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h2><pre><code>bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 </code></pre><h2 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h2><pre><code>rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </code></pre><h2 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h2><pre><code>yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 </code></pre><h2 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h2><pre><code>dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </code></pre><h2 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2><pre><code>apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </code></pre><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><pre><code>cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><pre><code>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;{print $1}&apos; 查看一行第一栏 echo a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </code></pre><h2 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h2><pre><code>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 </code></pre><h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><pre><code>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </code></pre><h2 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h2><pre><code>mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 </code></pre><h2 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h2><pre><code>mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </code></pre><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><pre><code>dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </code></pre><h2 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h2><pre><code>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </code></pre><h2 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h2><pre><code>ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &apos;eth0&apos; 网络设备 ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &apos;eth0&apos; route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &apos;192.168.0.0/16&apos; route del 0/0 gw IP_gateway remove static route echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &apos;eth0&apos; ethtool eth0 show statistics of network card &apos;eth0&apos; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;arch 显示机器的处理器架构(1) 
uname -m 显示机器的处理器架构(2) 
uname -r 显
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cocos 内存管理</title>
    <link href="http://yoursite.com/2018/09/27/Cocos-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/27/Cocos-内存管理/</id>
    <published>2018-09-27T02:09:16.000Z</published>
    <updated>2018-09-27T03:31:25.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="delete和new"><a href="#delete和new" class="headerlink" title="delete和new"></a>delete和new</h2><h3 id="new运算符使用的一般格式为"><a href="#new运算符使用的一般格式为" class="headerlink" title="new运算符使用的一般格式为 　　"></a>new运算符使用的一般格式为 　　</h3><pre><code>new 类型 [初值] 　　用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。new int;//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针) 　　new int(100);//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址　　new char[10];//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 　　new int[5][4];//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址float *p=new float (3.14159);//开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p 　　</code></pre><h3 id="delete运算符使用的一般格式为"><a href="#delete运算符使用的一般格式为" class="headerlink" title="delete运算符使用的一般格式为 　　"></a>delete运算符使用的一般格式为 　　</h3><pre><code>delete [ ]指针变量 　　例如要撤销上面用new开辟的存放单精度数的空间(上面第5个例子)，应该用 　　delete p；　　前面用“new char[10];”开辟的字符数组空间，如果把new返回的指针赋给了指针变量pt，则应该用以下形式的delete运算符撤销该空间： 　　  delete [] pt；//在指针变量前面加一对方括号，表示是对数组空间的操作 　　</code></pre><h2 id="CREATE-FUNC-函数"><a href="#CREATE-FUNC-函数" class="headerlink" title="CREATE_FUNC()函数"></a>CREATE_FUNC()函数</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code>/**  * define a create function for a specific type, such as CCLayer  * @__TYPE__ class type to add create(), such as CCLayer  */  #define CREATE_FUNC(__TYPE__) \  static __TYPE__* create() \  { \      __TYPE__ *pRet = new __TYPE__(); \  //创建传过来的东西    if (pRet &amp;&amp; pRet-&gt;init()) \      { \          pRet-&gt;autorelease(); \          return pRet; \      } \      else \      { \          delete pRet; \          pRet = NULL; \          return NULL; \      } \  }</code></pre><h3 id="什么是CREATE-FUNC"><a href="#什么是CREATE-FUNC" class="headerlink" title="什么是CREATE_FUNC()"></a>什么是CREATE_FUNC()</h3><pre><code>为类似CCLayer类的特定类增加一个create函数，我们也可以看到在宏的下面定义了一个create()函数返回到类型就是宏带入的参数&quot;__TYPE__&quot;指针类型</code></pre><h3 id="create（）函数做了什么？"><a href="#create（）函数做了什么？" class="headerlink" title="create（）函数做了什么？"></a>create（）函数做了什么？</h3><pre><code>他执行了类的构造函数，执行了init()初始化函数，最后又设置创建出的对象为自动释放内存，这样其他人在使用这个类的时候，只要是用create（）函数创建出来的对象就是不用费心区管理释放内存</code></pre><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><h3 id="什么时候引用计数"><a href="#什么时候引用计数" class="headerlink" title="什么时候引用计数"></a>什么时候引用计数</h3><pre><code>每一个对象都有一个关联的引用计数 —— 对该对象的活跃引用的数量。如果对象的引用计数是零，那么它就是垃圾（用户程序不可到达它），并可以回收。</code></pre><h2 id="Cocos2dx内存管理分为两块"><a href="#Cocos2dx内存管理分为两块" class="headerlink" title="Cocos2dx内存管理分为两块"></a>Cocos2dx内存管理分为两块</h2><pre><code>1. 通过加入 `autorelease` 来自动释放那些创建后未使用的对象1. 通过`节点管理`来保证对象在弃用后及时的删除</code></pre><h3 id="及时释放弃用的对象"><a href="#及时释放弃用的对象" class="headerlink" title="及时释放弃用的对象"></a>及时释放弃用的对象</h3><p><code>使用条件</code>：该对象是Node的子类对象<br><code>使用方法</code>：addChild，removeChild</p><h4 id="内存管理过程："><a href="#内存管理过程：" class="headerlink" title="内存管理过程："></a>内存管理过程：</h4><pre><code>addChild  添加对象后，对象可以被使用removeChild 删除对象后，对象被立刻删除（通过 delete）</code></pre><h3 id="及时释放未使用的对象"><a href="#及时释放未使用的对象" class="headerlink" title="及时释放未使用的对象"></a>及时释放未使用的对象</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><pre><code>新创建的对象如果 一帧 内不使用，就会被自动释放。（所谓一针，即是一个gameloop）</code></pre><h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><pre><code>对象通过CREAT_FUNC()宏创建或者对象使用autorelease加入了自动释放池</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>自动实现</code></pre><h4 id="管理过程"><a href="#管理过程" class="headerlink" title="管理过程"></a>管理过程</h4><h5 id="对象不使用的情况"><a href="#对象不使用的情况" class="headerlink" title="对象不使用的情况"></a>对象不使用的情况</h5><pre><code>对象创建        引用+1对象自动释放     引用-1</code></pre><h5 id="对象使用的情况"><a href="#对象使用的情况" class="headerlink" title="对象使用的情况"></a>对象使用的情况</h5><pre><code>对象创建        引用+1对象使用        引用+1//通过 addchild 使用对象对象自动释放    引用-1</code></pre><p>引用的初始值为0，如果一阵结束后对象的引用值还是0，那就会被delete掉</p><h2 id="内存管理的实现原理"><a href="#内存管理的实现原理" class="headerlink" title="内存管理的实现原理"></a>内存管理的实现原理</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p><code>Red</code>类：进行引用计数，提供加入自动释放池的接口。<br><code>AutoreleasePool</code>类：管理一个<code>vector</code>数组来存放自动释放池的对象。提供对释放池的清空操作<br><code>PoolManager</code>类：管理一个<code>vector</code>数组来存放自动释放池。默认情况下引擎只创建一个自动释放池，因此这个类是提供给开发者使用的，例如处于性能考虑添加自己的自动释放池<br><code>DisplayLinkDirector</code>类：只是一个导演类，提供游戏的主循环，实现每一帧的资源释放。这个类继承自<code>Director</code>类，也是唯一一个继承了<code>Director</code>的类，也就是说完全可以合并为一个类。</p><h4 id="Ref源码"><a href="#Ref源码" class="headerlink" title="Ref源码"></a>Ref源码</h4><pre><code>// 引用计数变量unsigned int _referenceCount;// 对象被构造后，引用计数值为 1Ref::Ref(): _referenceCount(1) //当Ref对象被创建时，引用计数的值为 1{#if CC_ENABLE_SCRIPT_BINDING    static unsigned int uObjectCount = 0;    _luaID = 0;    _ID = ++uObjectCount;    _scriptObject = nullptr;#endif#if CC_USE_MEM_LEAK_DETECTION    trackRef(this);#endif}// 引用+1void Ref::retain(){    CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;);    ++_referenceCount;}// 引用-1 。如果引用为0则释放对象void Ref::release(){    CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;);    --_referenceCount;    if (_referenceCount == 0)    {#if CC_USE_MEM_LEAK_DETECTION        untrackRef(this);#endif        delete this; // 注意这里 把对象 delete 了    }}// 提供加入自动释放池的接口。对象调用此函数即可加入自动释放池的管理。Ref* Ref::autorelease(){    PoolManager::getInstance()-&gt;getCurrentPool()-&gt;addObject(this);    return this;}//获取引用计数值unsigned int Ref::getReferenceCount() const{    return _referenceCount;}</code></pre><h4 id="AutoreleasePool源码"><a href="#AutoreleasePool源码" class="headerlink" title="AutoreleasePool源码"></a>AutoreleasePool源码</h4><pre><code>// 存放释放池对象的数组std::vector&lt;Ref*&gt; _managedObjectArray;// 往释放池添加对象void AutoreleasePool::addObject(Ref* object){    _managedObjectArray.push_back(object);}// 清空释放池，将其中的所有对象都 deletevoid AutoreleasePool::clear(){    // 释放所有对象    for (const auto &amp;obj : _managedObjectArray)    {        obj-&gt;release();    }    // 清空vector数组    _managedObjectArray.clear();}// 查看某个对象是否在释放池中bool AutoreleasePool::contains(Ref* object) const{    for (const auto&amp; obj : _managedObjectArray)    {        if (obj == object)            return true;    }    return false;}</code></pre><h4 id="PoolManager源码"><a href="#PoolManager源码" class="headerlink" title="PoolManager源码"></a>PoolManager源码</h4><pre><code>// 释放池管理器单例对象static PoolManager* s_singleInstance;// 释放池数组std::vector&lt;AutoreleasePool*&gt; _releasePoolStack;// 获取 释放池管理器的单例PoolManager* PoolManager::getInstance(){    if (s_singleInstance == nullptr)    {        // 新建一个管理器对象        s_singleInstance = new PoolManager();         // 添加一个自动释放池        new AutoreleasePool(&quot;cocos2d autorelease pool&quot;);// 内部使用了释放池管理器的push，这里的调用很微妙，读者可以动手看一看    }    return s_singleInstance;}// 获取当前的释放池AutoreleasePool* PoolManager::getCurrentPool() const{    return _releasePoolStack.back();}// 查看对象是否在某个释放池内bool PoolManager::isObjectInPools(Ref* obj) const{    for (const auto&amp; pool : _releasePoolStack)    {        if (pool-&gt;contains(obj))            return true;    }    return false;}// 添加释放池对象void PoolManager::push(AutoreleasePool *pool){    _releasePoolStack.push_back(pool);}// 释放池对象出栈void PoolManager::pop(){    CC_ASSERT(!_releasePoolStack.empty());    _releasePoolStack.pop_back();}</code></pre><h4 id="DisplayLinkDirector源码"><a href="#DisplayLinkDirector源码" class="headerlink" title="DisplayLinkDirector源码"></a>DisplayLinkDirector源码</h4><pre><code>void DisplayLinkDirector::mainLoop(){    //第一次当导演    if (_purgeDirectorInNextLoop)    {        _purgeDirectorInNextLoop = false;        purgeDirector();//进行清理工作    }    else if (! _invalid)    {        // 绘制场景，游戏主要工作都在这里完成        drawScene();        // 清空资源池        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();    }}</code></pre><h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><pre><code>首先，创建了一个 Node 对象A，Node 继承Ref，因此 Ref 的引用计数为1；然后，A通过 autorelease 将自己放入自动释放池；drawScene() 完成后，一帧结束，Director 通过释放池将池中的对象 clear()，即对 Node 对象A进行 release() 操作。A的引用计数变为0，执行 delete 释放A对象。、</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;delete和new&quot;&gt;&lt;a href=&quot;#delete和new&quot; class=&quot;headerlink&quot; title=&quot;delete和new&quot;&gt;&lt;/a&gt;delete和new&lt;/h2&gt;&lt;h3 id=&quot;new运算符使用的一般格式为&quot;&gt;&lt;a href=&quot;#new运算符使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>xml</title>
    <link href="http://yoursite.com/2018/09/26/xml/"/>
    <id>http://yoursite.com/2018/09/26/xml/</id>
    <published>2018-09-26T12:59:29.000Z</published>
    <updated>2018-09-26T13:02:49.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xml概述："><a href="#xml概述：" class="headerlink" title="xml概述："></a>xml概述：</h2><pre><code>可扩展标记语言。(Extensible Markup Language)  允许开发者自由定义标签，可以将标签和内容有效分离。  xml不再侧重于数据如何展示，二十更过的关注数据如何存储和传输。  </code></pre><h2 id="xml应用场景："><a href="#xml应用场景：" class="headerlink" title="xml应用场景："></a>xml应用场景：</h2><pre><code>1. xml把数据从HTML分离出来。那温度距离，用html注重于显示而无关数据，用xml改变数据，让html读取。  2. 简化数据共享。提供了独立于软件和硬件的存储方式。  3. 简化数据的传输。通过xml，可以在不兼容的系统之间传输数据。  4. 简化平台的变更。  </code></pre><h2 id="xml的优势："><a href="#xml的优势：" class="headerlink" title="xml的优势："></a>xml的优势：</h2><pre><code>1. 简单易用的标记预语言。xml标签可以自己自由定义。2. 严格的格式。比html标签控制更严格。3. 数据逻辑和显示逻辑分离。html注重于显示，xml注重于数据存储。</code></pre><h2 id="xml文档规则："><a href="#xml文档规则：" class="headerlink" title="xml文档规则："></a>xml文档规则：</h2><pre><code>1. 有且只有一个根元素2. 元素必须合理结束3. 元素之间必须合理嵌套4. 元素的属性必须有值</code></pre><h2 id="xml存储信息："><a href="#xml存储信息：" class="headerlink" title="xml存储信息："></a>xml存储信息：</h2><pre><code>例如：书名    作者    价格         java思想    小王    79.00          Spring指南    小李    89.00  </code></pre><h2 id="xml的写法"><a href="#xml的写法" class="headerlink" title="xml的写法"></a>xml的写法</h2><h3 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h3><pre><code>1. 简体中文：GBK 或 GB23122. 繁体中文：BIG53. 西欧字符：ISO8859-14. 通用的国际编码：Unicode5. 针对Unicode的可变长度字符编码UTF8</code></pre><h3 id="合法标签名："><a href="#合法标签名：" class="headerlink" title="合法标签名："></a>合法标签名：</h3><pre><code>xml元素由开始标签和结束标签组合，结束标签比开始标签多一条斜线xml文档区分大小写。所以，开始标签和结束标签必须绝对相同，大小写也要完全一致标签名可以字母（包括非西欧字符），数字，下划线，中划线，冒号，点号组成，但是不能以数字，中划线和点号开头不能包括 ‘&lt; &gt; , $’标签名尽量不要出现英文冒号“:”, 除非是在使用名空间标签名不能以字符“xml”等任意大小写组合开始标签名不能包含空格</code></pre><h3 id="空元素："><a href="#空元素：" class="headerlink" title="空元素："></a>空元素：</h3><pre><code>例：&lt;元素名 属性名=&quot;  &quot; /&gt;空元素不是内容为空的元素，空元素不接受子元素，也不接受字符内容&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; standalone = &quot;yes&quot; ?&gt;&lt;书籍列表&gt;    &lt;书名&gt; java思想&lt;/书名&gt;    &lt;价格&gt;79.00&lt;/价格&gt;    &lt;作者&gt;小王&lt;/作者&gt;    &lt;书名&gt;Spring指南&lt;/书名&gt;    &lt;价格&gt;89.00&lt;/价格&gt;    &lt;作者&gt;小李&lt;/作者&gt;&lt;/书籍列表&gt;那么 &lt;书籍列表&gt; 就是根元素</code></pre><h2 id="字符数据："><a href="#字符数据：" class="headerlink" title="字符数据："></a>字符数据：</h2><pre><code>开始标签和结束标签之间的文本可以是任何Unicode字符，并且其间的任何字符都重视的传递给xml处理程序但是如果中间由 &lt; 或者 &amp; 字符，容易导致辨认错误。例如： &lt;test&gt; 1 + 1 &lt; 3&lt;/test&gt;， 这样用浏览器打开就会显示错误。解决方法：    1. 使用实体应用（xml定义了五种实体引用）（记得后面要加分号）：        &amp;lt;       ---&gt;     &quot;&lt;&quot;   小于符号        &amp;gt;      ---&gt;     &quot;&gt;&quot;   大于符号        &amp;amp;      ---&gt;     &quot;&amp;&quot;   and符号 &amp;        &amp;apos;    ---&gt;     &quot;&apos;&quot;     英文单引号        &amp;quot;    ---&gt;     &quot;&quot;&quot;     英文双引号    2. 使用CDATA标记        在特殊标记CDATA下，所有的特殊字符，甚至是有效元素都将被当成简单字符处理        实体引用也会失去作用，变成纯文本        语法：        &lt;![CDATA[文本内容]]&gt;</code></pre><h2 id="换行处理："><a href="#换行处理：" class="headerlink" title="换行处理："></a>换行处理：</h2><pre><code>目前主流的操作系统，主要由3种换行符：    1. Windows平台：回车符（CR） 和 换行符 （LF） 的组合存储换行    2. Unix和Linux平台：以换行符（LF）存储换行    3. Macintosh平台：以回车符（CR）存储换行xml同一换行符（LF） 存储换行</code></pre><h2 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h2><pre><code>同一份xml文档中可能出现多个同名的元素和属性。必须添加标记判断语法：    xmlns[:prefix]= &quot;命名空间字符串&quot;    xmlns -&gt; xml namespace例如：    xmlns:hehe = &quot;http://www.***.com&quot;    &lt;hehe:name&gt;java思想&lt;/hehe:name&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xml概述：&quot;&gt;&lt;a href=&quot;#xml概述：&quot; class=&quot;headerlink&quot; title=&quot;xml概述：&quot;&gt;&lt;/a&gt;xml概述：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;可扩展标记语言。(Extensible Markup Language)  
允许开发者自由
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL命令</title>
    <link href="http://yoursite.com/2018/09/26/MySQL%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/26/MySQL命令/</id>
    <published>2018-09-26T08:30:14.000Z</published>
    <updated>2018-09-26T08:37:54.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下进入命令行"><a href="#Windows下进入命令行" class="headerlink" title="Windows下进入命令行"></a>Windows下进入命令行</h2><pre><code>ssh 用户名@ip地址  或者 mysql -h ip地址 -u root -p  然后输入密码  mysql -u 数据库用户名 -p  然后输入密码  </code></pre><h3 id="修改密码："><a href="#修改密码：" class="headerlink" title="修改密码："></a>修改密码：</h3><pre><code>`mysqladmin -u root -p 密码 password 新密码`  </code></pre><h3 id="增加用户："><a href="#增加用户：" class="headerlink" title="增加用户："></a>增加用户：</h3><pre><code>`insert into mysql.user(Host,User,Password)  values  (&quot;localhost&quot;,&quot;test&quot;,password(&quot;1234&quot;));（登陆地址，用户名，密码）  `</code></pre><h3 id="用户授权："><a href="#用户授权：" class="headerlink" title="用户授权："></a>用户授权：</h3><pre><code>`grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;;　 `   `权限包括：select,insert,update,delete，all privileges  `  `记得创建授权之后，flush privileges;//刷新系统权限表 `   </code></pre><h3 id="删除用户："><a href="#删除用户：" class="headerlink" title="删除用户："></a>删除用户：</h3><pre><code>`root权限下 Delete FROM user Where User=&apos;用户名&apos; and Host=&apos;ip地址&apos;; ``flush privileges;  `</code></pre><h3 id="修改密码：-1"><a href="#修改密码：-1" class="headerlink" title="修改密码："></a>修改密码：</h3><pre><code>`update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;test&quot; and Host=&quot;localhost&quot;;  `</code></pre><h3 id="查看数据库："><a href="#查看数据库：" class="headerlink" title="查看数据库："></a>查看数据库：</h3><pre><code>`show databases;  `</code></pre><h3 id="链接数据库："><a href="#链接数据库：" class="headerlink" title="链接数据库："></a>链接数据库：</h3><pre><code>`use 库名；  `</code></pre><h3 id="查看数据表："><a href="#查看数据表：" class="headerlink" title="查看数据表："></a>查看数据表：</h3><pre><code>`show tables;  `</code></pre><h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><pre><code>`show status like &apos;%下面变量%&apos;; ` </code></pre><hr><pre><code>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。   Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。   Connections 试图连接MySQL服务器的次数。   Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。   Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。   Delayed_writes 用INSERT DELAYED写入的行数。   Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。   Flush_commands 执行FLUSH命令的次数。   Handler_delete 请求从一张表中删除行的次数。   Handler_read_first 请求读入表中第一行的次数。   Handler_read_key 请求数字基于键读行。   Handler_read_next 请求读入基于一个键的一行的次数。   Handler_read_rnd 请求读入基于一个固定位置的一行的次数。   Handler_update 请求更新表中一行的次数。   Handler_write 请求向表中插入一行的次数。   Key_blocks_used 用于关键字缓存的块的数量。   Key_read_requests 请求从缓存读入一个键值的次数。   Key_reads 从磁盘物理读入一个键值的次数。   Key_write_requests 请求将一个关键字块写入缓存次数。       Key_writes 将一个键值块物理写入磁盘的次数。   Max_used_connections 同时使用的连接的最大数目。   Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。   Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。   Open_tables 打开表的数量。   Open_files 打开文件的数量。     Open_streams 打开流的数量(主要用于日志记载）   Opened_tables 已经打开的表的数量。     Questions 发往服务器的查询的数量。   Slow_queries 要花超过long_query_time时间的查询数量。   Threads_connected 当前打开的连接的数量。   Threads_running 不在睡眠的线程数量。   Uptime 服务器工作了多少秒。  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows下进入命令行&quot;&gt;&lt;a href=&quot;#Windows下进入命令行&quot; class=&quot;headerlink&quot; title=&quot;Windows下进入命令行&quot;&gt;&lt;/a&gt;Windows下进入命令行&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ssh 用户名@ip地址  
或者 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java的文件和时间操作</title>
    <link href="http://yoursite.com/2018/09/25/java%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/25/java的文件操作/</id>
    <published>2018-09-25T14:37:09.000Z</published>
    <updated>2018-09-25T15:55:52.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><h3 id="构造函数有："><a href="#构造函数有：" class="headerlink" title="构造函数有："></a>构造函数有：</h3><pre><code>传入相对路径（一个参数）  传入绝对路径（一个参数）  File类指定为当前文件的父级，当前文件的名称（两个参数）  </code></pre><h2 id="文件删除读写改名"><a href="#文件删除读写改名" class="headerlink" title="文件删除读写改名"></a>文件删除读写改名</h2><pre><code>File file = new File(&quot;hello.txt&quot;);//对于工程而言用相对路径，创建在根目录下。也可以用绝对路径指定文件夹  //File file = new File(&quot;bin/hello.txt&quot;);工程文件夹下的bin文件夹的hello.txt文件  //File file = new File(&quot;../hello.txt&quot;);工程文件夹的上一级文件中新建hello.txt文件  if(file.exists()){      System.out.printlen(file.isFile());//判断文件是文件      System.out.println(file.isDirectory());//判断文件是文件夹      File nameto = new File(&quot;new name .txt&quot;);      file.renameTo(nameto);//将file的名字改为nameti的名字      File nameto1 = new File(&quot;src/new name.txt&quot;);      file.renameTo(nameto1);//将文件移动到src目录下      file.delete();//删除文件  }else{      System.out.println(&quot;文件不存在&quot;);      try{          file.createNewFile();          System      }catch(IOException e){//抛出异常          e.printStackTrace();          System.out.println(&quot;文件无法创建&quot;);      }  }  </code></pre><h3 id="测试样例，用于文件的读取"><a href="#测试样例，用于文件的读取" class="headerlink" title="测试样例，用于文件的读取"></a>测试样例，用于文件的读取</h3><p>新建一个test.txt文件，内容随意。</p><pre><code>File file = new File(&quot;text.txt&quot;);if(file.exitst()){    try{        FileInputStream fis = new FileInputStream(file);//属于字节流        InputStreamReader isr = new InputStreamReader(fis. &quot;UTF-8&quot;);//属于字符流，在字节转换为字符的时候，需要指定编码，否则可能会出现乱码。        BufferedReader br = new BufferedReader(isr);//带有缓冲区的reader        String line;//用于存放临时数据        while ((line = br.readLine()) != null){            System.out.println(line);//输出读取的一行        }        关闭输入流，先打开的后关闭，后打开的先关闭。        br.close();        isr.close();        fis.close();    }catch (FileNotFoundException e){        该异常对应于 FileInputStream    }catch (UnsupportedEncodingException e){        该异常对应于 InputStreamReader    }catch (IOException e){        该异常对应于 ***.close()    }}</code></pre><h3 id="测试样例，用于写入文件"><a href="#测试样例，用于写入文件" class="headerlink" title="测试样例，用于写入文件"></a>测试样例，用于写入文件</h3><pre><code>File newfile = new File(&quot;newtest.txt&quot;);try{    FileOutPutStream fos = new FileOutputStream(newfile);    OutPutStreamWriter osw = new OutPutStream(fos, &quot;UTF-8&quot;);    BufferedWriter bw = new BufferedWriter(osw);    bw.write(&quot;你要写入的内容&quot;);    。。。。。。。    bw.close();    osw.close();    fos.close();    //同样，先打开的后关闭，后打开的先关闭。}</code></pre><h2 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h2><pre><code>File类可以表示文件或者文件夹，但是两者之间的是有区别的File folder = new File(&quot;my new folder&quot;);// folder.createNewFile()  使用该方法创建的是一个文件，只是文件没有后缀罢了folder.mkdir();//创建一个文件夹，返回值是一个bool类型，true为创建成功，false为失败//如果 已经存在 名为 “my new folder”的文件夹，则创建失败。也就是说不能出现同名的文件或者文件夹</code></pre><p><code>如果使用mkdir()，那么创建的文件夹必须是物理上存在的文件夹，也就是说，如果创建“one/two/test”这样的文件夹，但是 不存在one文件夹，那么是不会自动补全路径的。这时候我们就需要用 mkdirs()，也就是 file.mkdirs()这个语句。</code></p><pre><code>//文件夹给名字的方法跟文件改名字的方法类似File folder = new File(&quot;my new folder&quot;);File newfolder = new File(&quot;new folder&quot;);folder.renameTo(newfolder);//返回的是一个bool类型的值，可以通过if判断是否修改成功//用这种方式修改文件夹的名字forlder.delete();//删除文件夹，但是只能删除空文件夹</code></pre><p><code>在windows中，千万注意移动文件夹不要跨盘移动，否则失败。因为Windows的文件系统是森林格式，而Linux和Mac系统是数状的</code></p><h2 id="一些判断获取语句"><a href="#一些判断获取语句" class="headerlink" title="一些判断获取语句"></a>一些判断获取语句</h2><pre><code>File file = new File(&quot;test.txt&quot;);//判断文件是否存在    file.exists();//读取文件名称    file.getName();//读取文件相对路径    file.getPath();//读取文件的绝对路径    file.getAbsolutePath();//读取文件父级路径    file.getParent();//读取文件大小（字节）    file.length();//判断文件是否被隐藏（Linux和unix中，文件以 &quot; . &quot;开头代表隐藏）    file.isHidden();//判断文件是否可读    file.canRead();//判断文件是否可写    file.canWrite();//判断文件是否为文件夹    file.isDirectory();//当程序退出时将文件删除    file.deleteOnExit();</code></pre><h2 id="设置文件属性："><a href="#设置文件属性：" class="headerlink" title="设置文件属性："></a>设置文件属性：</h2><pre><code>File file = new File(&quot;test.file&quot;);//设置为可写    file.setWritable(true);//传入 true 则设置文件可写，否则设置为不可写//设置为可读    file.setReadable(true);//与上述相同。//设置为只读    file.setReadOnly();</code></pre><h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><pre><code>public static void printfFiles(File dir){{    if( dir.isDirectory() ){        File next[] = dir.listFiles();        for( int i = 0; i&lt;next.length; i++){            if( next[i].ifFile() ){//输出文件的名字                System.out.println(next[i].name);            }else{//递归的输出文件的名字                printfFiles(next[i]);            }        }    }}</code></pre><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><p>Date表示时间，日期。但是更新jdk之后就不推荐使用了。<br>官方解释是 使用Date类<code>不利于国际化</code>。所以jdk1.1版本后推荐使用Calendar类。使用DateFormat类进行时间日期的格式化。Long类型表示时间类型。String类型表示时间日期类的显示。 </p><pre><code>Date.getTime();//获取Date对象的时间  Date.setTime(long time);//设置Date的时间  Calendar rightnow = Calendar.getInstance();//获取当前时间  long now = System.currentTimeMillis();//获得系统的当前时间，但是这个时间只有机器能读懂Date d1 = new Date(now);// 获取人能够读懂的时间  Calendar c1 = Calendar .getInstance();  System.out.print(c1.getTime().toString());//获得人能够读懂的时间  </code></pre><p><code>String -&gt; 时间  &amp;&amp; 时间 -&gt; String</code></p><pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//指定日期的格式  sdf.format(date);//将Date类型转换为指定格式的String类型，返回的是一个String类型  sdf.parse(&quot;2015-06-01&quot;);//将String转换为Date类型，返回的是一个Date类型  //SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); 时间格式为 年月日  时分秒  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;File-类&quot;&gt;&lt;a href=&quot;#File-类&quot; class=&quot;headerlink&quot; title=&quot;File 类&quot;&gt;&lt;/a&gt;File 类&lt;/h2&gt;&lt;h3 id=&quot;构造函数有：&quot;&gt;&lt;a href=&quot;#构造函数有：&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2018/09/25/Git/"/>
    <id>http://yoursite.com/2018/09/25/Git/</id>
    <published>2018-09-25T07:47:09.511Z</published>
    <updated>2018-09-25T08:15:03.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git的起源"><a href="#Git的起源" class="headerlink" title="Git的起源"></a>Git的起源</h2><p>linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bitkeep说开源社区中的一个成员对bitkeep的协议进行逆向工程。因此，自己写了git。</p><p><code>SVN</code>-&gt;<code>集中式版本控制系统</code>：只有中央服务器有版本的数据库，其他电脑没有，所有版本控制都要通过中央服务器进行交互。（要是中央服务器当机离线，则就出大问题了）<br><code>git</code>-&gt;<code>分布式版本控制</code>：每一个台电脑上面都有一个版本的database。由于每台电脑都有数据库，所以大多数操作可以离线进行。支持比较多的控制模式-也可以安装一个中央服务器。  </p><ol><li>git每个版本存储的都是当前版本的所有内容，不需要与其他版本进行差异比较之后再进行文件的合成。  </li><li>git可以离线完成大部分操作。  </li><li>git有更优雅的分支和合并实现。  </li><li>git有更强大撤销修改和修改版本历史的能力。  </li><li>git速度更快，效率更高。</li></ol><h2 id="为什么学习git："><a href="#为什么学习git：" class="headerlink" title="为什么学习git："></a>为什么学习git：</h2><p>研究GitHub<br>越来越多的公司通过git调整</p><h2 id="git如何存储文件，历史记录："><a href="#git如何存储文件，历史记录：" class="headerlink" title="git如何存储文件，历史记录："></a>git如何存储文件，历史记录：</h2><p><code>git通过40个16进制字符的SHA-1 Hash 来唯一标识对象</code> 例如：     e98757d0598ab6eeaf1df0d87dd00826048bd80b<br>git有<code>四种对象</code>：  </p><pre><code>1. blob：文本文件或者二进制文件或者链接文件  2. tree：目录  3. commit：历史提交      4. tag：指向固定的历史提交  (-&gt;）指向的意思  </code></pre><p><code>tag</code>  <code>-&gt;</code>  <code>commit</code>  <code>-&gt;</code>  <code>tree</code>  <code>-&gt;</code>  <code>多个tree对象或者多个blob对象</code><br>对工作区的这些内容进行SHA-1 Hash 之后，就可以得到唯一标识。<br>如果两个文件内容是相同的，则他们指向同一个blob对象。而文件名这种信息会存在tree对象中。  </p><p>有了git对象之后，需要git仓库去存储对象，和操作对象。<br>git init   git clone  两种方法获取仓库。<br><img src="https://i.imgur.com/InyuRGB.png" alt=""><br>cd 到.git 文件夹中 （GIT_DIR!）-&gt; git工作区间     用 ls 查看git需要的文件<br>再退出来<br>用init方法创建一个裸仓库。然后查看仓库中有什么。<br>git init –bare git_bare_repo<br>通过–bare 方法创建一个 git_bare_repo 文件夹。这个文件夹只有git工作需要的文件。<br>git clone 克隆出一个仓库 一般来说需要远程裸仓库的地址<br>git clone git_bare_repo/ git_clone_repo （复制之前创建的本地仓库，并创建在文件夹  git_clone_repo中）  </p><h2 id="git分为三个区域："><a href="#git分为三个区域：" class="headerlink" title="git分为三个区域："></a>git分为三个区域：</h2><blockquote><ol><li>working directory（工作区，日常编辑代码的地方）  </li><li>staging area（暂存区，工作区与历史提交的缓存，维护的是虚拟的树形结构）  </li><li>history repository（历史仓库）   </li></ol></blockquote><p>（1）工作区  添加文件到  暂存区  提交整个暂存区的状态   历史纪录区<br>（2）历史记录区   检出文件到   暂存区和工作区<br>大部分时间我们都在做第一个工作<br>对应的就是 <code>git add（到暂存区）</code>  和  <code>git commit（到历史记录区）</code><br>    git status（查看工作区和暂存区的区别，确保提交是我们所需要的）<br>    git rm（从暂存区删掉我们不需要的东西）<br>    git mv（移动文件）<br>    gitignore（确保不想添加到暂存区和历史纪录区的文件不被添加）  </p><blockquote><p>先 创建  a b 两个文件<br>    touch a<br>    touch b<br>然后添加到暂存区<br>    git add a b<br>查看一下<br>    git status<br>提交到历史纪录<br>    git commit -m “initial commit” （加入一个提交的历史信息）<br>修改一下a<br>    vim a（加入一些文字信息）<br>再看一下 git status<br>    提示 a 修改了 但是没有提交到暂存区<br>提交a到暂存区中<br>    git add a<br>再status 看一下<br>    git status<br>再提交 a 就行<br>    git commit -m “modify a”<br>删除a，会删除 工作区 ，暂存区中的a<br>    git rm a<br>还原一下a<br>    git checkout a<br>如何只删除暂存区的文件，不删除工作目录的文件<br>    git rm –cached a  </p></blockquote><p><hr><br><img src="https://i.imgur.com/tAGY09M.png" alt=""></p><blockquote><p>git status 看看就会提示有一个没有跟踪的文件<br>git mv a c （将a名字命名为c）（这个命令是一系列操作的总和）<br>    如果直接再工作区修改文件名<br>        mv a c （工作目录直接 修改名字）<br>    再 git status<br>        提示 a 被删除了 ， 有个c 的文件没有被跟踪<br>    再 git add a c（添加a c 到文件中）<br>        提示文件 a 被更改为 c<br>git add -A 添加整个工作区都暂存区<br>git .gitignore    在顶层目录下创建一个.gitignore文件<br><em>.[oa]通过通配符提示git，以 o 和 a 结尾的文件不要添加到git仓库中<br>例如：加入了  </em>.~, *.pyc ， 但是如果以.pyc为后缀的文件，有一个要加到仓库，这个时候就要在文件名上加  !test.pyc，告诉 test.pyc 不要被忽略。如果需要ingore文件名第一个字符就是“！”，就要加上”\”转义字符。<br>**/res 匹配 res，所有路径下的res，任何文件夹下的res。<br>git add .gitignore<br>git commit -m “add ingore”//添加到仓库中，用于整个仓库的共享  </p></blockquote><h2 id="git暂存区"><a href="#git暂存区" class="headerlink" title="git暂存区"></a>git暂存区</h2><blockquote><p>.git/objects 对象库<br>当执行 git add 命令时，.git 目录下多了一个index文件，整个index文件就是暂存区，每条索引有个的四十位的十六进制的SHA-1 Hash，文件模式，权限，时间戳等。每个索引都对应对象库中的某个对象对应。<br>除了索引之外，还维护了提前计算好的tree对象的内容。当我们提交的时候，可以直接通过提前计算好的，直接生成索引等内容。<br>当文件名更改时，根据文件内容所计算出来的SHA-1 也不会变。<br>暂存区索引每次更新的时候，都会重新计算index 和暂存区的内容。  </p></blockquote><h2 id="git本地分支与合并"><a href="#git本地分支与合并" class="headerlink" title="git本地分支与合并"></a>git本地分支与合并</h2><pre><code>git branch（创建分支)  git tag（给commit做标记）  git checkout（分支之间的切换）  git stash（切换分支之前保存本地修改）  git merge（合并分支）</code></pre><blockquote><p>例如：git branch test  新建分支 test。但是只是新建，要切换过去才能使用<br>git checkout test 切换到test分支。<br>test分支做的修改，不会影响到master分区的工作。也就是说分支互不影响。</p></blockquote><pre><code>tag 分 轻量级 本地引用  和 annotady 带注解的tag通过 git log --online --decorate --graph -all 查看hash值，以及提交，查看历史示意图  git tag &quot;v0&quot; a1abda30   （a1abda30 就是上述命令查出的hash值）  git tag -a &quot;INITAL_COMMIT&quot; a1abda30   标注tag，提示输出tag信息。  git tag 查看以有的设置过的tag  git config --global alias.lol &quot;log --oneline --decorate --graph --all&quot; 用 git lol 代替 log --oneline --decorate --graph --all  git show v0 （v0是一个tag的名字）  </code></pre><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>提供个人或者企业的代码托管。可以查看其他的开源项目托管。<br><img src="https://i.imgur.com/qDXMcAv.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git的起源&quot;&gt;&lt;a href=&quot;#Git的起源&quot; class=&quot;headerlink&quot; title=&quot;Git的起源&quot;&gt;&lt;/a&gt;Git的起源&lt;/h2&gt;&lt;p&gt;linux内核源代码一直在 bitkeep 上托管，但是bitkeep 突然收回对linux的授权，因为bi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <link href="http://yoursite.com/2018/09/25/ACM-Icpc-%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B/"/>
    <id>http://yoursite.com/2018/09/25/ACM-Icpc-徐州网络赛/</id>
    <published>2018-09-25T05:38:47.873Z</published>
    <updated>2018-09-25T06:54:20.219Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time Limit: 1000ms       Memory Limit: 262144KB</span><br></pre></td></tr></table></figure><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p> Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256, which can transit a string into just 256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string s, s[i] represents the i th character in the string)we calculates the value(|(int) L – s[i]|), and write down the number(keeping leading zero. The length of each answer equals to 2 because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(s)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “11 45 14”.  It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p> First line a integer T, the number of test cases(T &lt;= 10)  For each test case:  First line contains a integer N and a character z, (N &lt;= 1000000)  Second line contains a string with length N. Problem makes sure that all characters referred in the problem are only letters. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p> A single number which gives the answer. </p><h3 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h3><p>2<br>3 z<br>oMl<br>6 Y<br>YJSNPI </p><h3 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h3><p>6<br>10 </p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mur喜欢哈希算法，他有时加密另一个人的名字，然后用加密值给他打电话。例如，他打电</span><br><span class="line">话给Kimura KMR，并打电话给Suzuki YJSNPI。有一天，他读了一本关于SHA-256的</span><br><span class="line">书，它可以将字符串转换成256位。 Mur认为这很酷，他想出了一个新的算法来完成类似的</span><br><span class="line">工作。算法以这种方式工作：首先我们选择单个字母L作为种子，对于输入（您可以将输入</span><br><span class="line">视为字符串s，s [i]表示字符串中的第i个字符）我们计算值（ |（int）L - s [i] </span><br><span class="line">|），并记下数字（保持前导零。每个答案的长度等于2，因为字符串只包含字母和数字）。</span><br><span class="line">数字从左到右写入，最后将所有数字转换为单个整数（不带前导零）。例如，如果我们选</span><br><span class="line">择&apos;z&apos;作为种子，则字符串“oMl”变为“11 45 14”。很容易发现该算法无法将任何输入字</span><br><span class="line">符串转换为相同的长度。虽然在绝望中，Mur仍然想知道算法产生的答案的长度。由于穆尔</span><br><span class="line">的愚蠢，他甚至无法弄清楚这一点，所以你被分配了计算答案的工作。</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p> 第一行是整数T，测试用例数（T &lt;= 10）对于每个测试用例：第一行包含整数N和字符z，（N &lt;= 1000000）第二行包含长度为N的字符串。确保问题中提到的所有字符都只是字母。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p> 一个数字给出了答案。</p><h3 id="样本输入"><a href="#样本输入" class="headerlink" title="样本输入"></a>样本输入</h3><p>2<br>3 z<br>oMl<br>6 Y<br>YJSNPI</p><h3 id="样本输出"><a href="#样本输出" class="headerlink" title="样本输出"></a>样本输出</h3><p>6<br>10</p><blockquote><p>水题，但是特别坑。<br>这里先讲第二个样例： 减出来的结果是  00  15  06  11  09  16<br>这样去除前面的0，得出来的结果就是1506110916，这10位<br>如果全部都是0呢 比如 <br>4 z<br>zzzz<br> 这个时候就要输出 1 而不是 0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">int len;</span><br><span class="line">char Seed, s;</span><br><span class="line">cin &gt;&gt; len &gt;&gt; Seed;</span><br><span class="line">        bool flag = false, fir = true;</span><br><span class="line">for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">int t = Seed - s;</span><br><span class="line">t = abs(t);</span><br><span class="line">            if(t != 0)</span><br><span class="line">                flag = true;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">                if(fir)&#123;</span><br><span class="line">                    if(t &gt;= 1 &amp;&amp; t &lt;= 9)</span><br><span class="line">                        sum += 1;</span><br><span class="line">                    else </span><br><span class="line">                        sum += 2;</span><br><span class="line">                    fir = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else sum += 2;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        if(flag == false)</span><br><span class="line">            sum = 1;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p> Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge a[i]. Unfortunately, the longer he learns, the fewer he gets. That means, if he reads books from l to r, he will get a[l]<em>L+a[l+1]</em>(L-1)+…+a[r1]*2+a[r] (L is the length of [l, r] that equals to r-l+1).  Now Ryuji has q questions, you should answer him: 1. If the question type is 1, you should answer how much knowledge he will get after he reads books [l, r] 2. If the question type is 2, Ryuji will change the ith book’s knowledge to a new value. </p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p> First line contains two integers n and q (n, q &lt;= 100000).  The next line contains n integers represent a<a href="a[i] &lt;= 1e9">i</a>  Then in next q line each line contains three integers a, b, c, if a = 1, it means question type is 1, and b, c represents [l, r]. if a = 2, it means question type is 2, and b, c means Ryuji changes the bth book’ knowledge to c. </p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p> For each question, output one line with one integer represent the answer.<br>Sample Input<br>5 3<br>1 2 3 4 5<br>1 1 3<br>2 5 0<br>1 4 5 </p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>10<br>8 </p><h2 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译"></a>翻译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Ryuji不是一个好学生，他不想学习。 但他应该学习n本书，每本书都有自己的知识[i]。 不幸的是，他学的越久，得到的就越少。</span><br><span class="line">   这意味着，如果他从l到r读书，他将获得a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]（L 是[l，r]的长度，等于r-l + 1）。 现在Ryuji有q问题.</span><br><span class="line">   你应该回答他： </span><br><span class="line">    1。如果问题类型是1，你应该回答他读书后会得到多少知识[l，r]</span><br><span class="line">    2.如果问题类型是2，Ryuji会改变 ith书对新价值的认识。</span><br><span class="line"> </span><br><span class="line">输入</span><br><span class="line">  第一行包含两个整数n和q（n，q &lt;= 100000）。 </span><br><span class="line">  下一行包含n个整数表示a [i]（a [i] &lt;= 1e9） </span><br><span class="line">  然后在下一个q行中每行包含三个整数a，b，c， </span><br><span class="line">  如果a = 1，则表示问题类型为1，b ，c代表[l，r]。 </span><br><span class="line">  如果a = 2，则表示问题类型为2，b，c表示Ryuji将bth book的知识更改为c。</span><br></pre></td></tr></table></figure><p>这里我维护的两个数组。一个是输入的数组x，另一个是数组z。<br>定义数组<code>z[i] = x[i] * (n-i+1)（i从1开始）</code><br>然后定义两个数组 y 和 shu。其中 y数组用于维护x，shu数组用于维护z。<br>这个解释一下z数组的用途，以及如何维护z数组。<br>题目求的是<code>a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]</code>，如果暴力求解绝对超时。所以有个z数组。<br>用样例来说：<br>输入的 1 2 3 4 5<br>那么 x 数组中就是  1 2 3 4 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z 数组中就是 5 8 9 8 5<br>求 1~3 的和。那么如果直接加上 z[1~3] ，那么就是a[1]<em>5 + a[2]</em>4 + a[3]<em>3。但是题目要求的是  a[1]</em>3+a[2]<em>2+a[3]</em>1，也就是减去2倍的(a[1]+a[2]+a[3])。而这个2倍其实就是 区间 （l，r）中r距离尾部的单位值。这里是5 - 3 = 2。<br>上面的例子很容易发现 z 数组的用途，提前预处理了题目要求的<code>a[l] * L + a [l + 1] *（L-1）+ ... + a [r1] * 2 + a [r]</code>。如此一来就可以用0（1）的时间求出要求的值，而不需要遍历。<br>再来看，题目有两种状态一个是区间求和，另一个是修改值。碰到这种题目很容易想到的就是树状数组或者线段树，我这里用的是树状数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sm = 400000+10;</span><br><span class="line">long long int x[sm];</span><br><span class="line">long long int n, q;</span><br><span class="line">long long int z[sm];// x存n个数，z ai*(n-i) i 从0 开始 </span><br><span class="line">long long int y[sm], shu[sm];// y 求区间和， 树状数组</span><br><span class="line"></span><br><span class="line">long long int lowbit(int x)&#123;</span><br><span class="line">return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long find_sum(long long int i, long long zu[])&#123;//区间求和 </span><br><span class="line">long long int ret =0 ;</span><br><span class="line">for(; i&gt;0 ; ret += zu[i], i -= lowbit(i));</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(long long int i, long long int val, long long zu[])&#123;//建树, 更新值 </span><br><span class="line">for(;i &lt;= n; zu[i] += val, i += lowbit(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">for(int i =1 ; i&lt;=n; i++)</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">update(i, x[i], y);//建立y，维护x数组</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">z[i] = x[i] * (n-i+1);</span><br><span class="line">for(int i=1; i&lt;=n; i++)</span><br><span class="line">update(i, z[i], shu);//建立shu，维护z数组</span><br><span class="line"></span><br><span class="line">for(int i=1; i&lt;=q; i++)</span><br><span class="line">&#123;</span><br><span class="line">long long int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">if(t == 1)&#123;</span><br><span class="line">long long int l, r, suml, sumr;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">long long int s1 = find_sum(r, shu) - find_sum(l-1, shu);//获得z数组的区间和</span><br><span class="line">long long int s2 = find_sum(r, y) - find_sum(l-1, y);//获取x数组的区间和</span><br><span class="line">cout &lt;&lt; s1 - s2*(n-r) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if(t == 2)&#123;</span><br><span class="line">long long int new_num, where;</span><br><span class="line">cin &gt;&gt; where &gt;&gt; new_num;//where代表位置，new_num代表值</span><br><span class="line">long long int mid = new_num - x[where]; </span><br><span class="line">update(where, mid, y);//更新y数组</span><br><span class="line">update(where, mid*(n - where + 1), shu);//更新shu数组</span><br><span class="line">x[where] = new_num;//更新x数组中的值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>！！！！着重强调，如果用我这种方法做的人，一定要用`</code>long long<code></code> ！！！！`<br>本来觉得部分数据不大可以部分不用long long，结果不知道那块就是卡住了死交不过去，wa了四五发都是因为这个。</p><p>ACM本就是逆天而行，死在路上很正常。真的，看到别人大佬一队AK了，我才做了两题，就感觉对不起队友，对不起老师。天赋上的差距没办法，自己还是很菜，再加上最近在搭建服务器，导致算法上面没用心，最后一年了，好好搞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cocos 2d游戏——I wanna save the princess</title>
    <link href="http://yoursite.com/2018/09/25/cocos2dx/"/>
    <id>http://yoursite.com/2018/09/25/cocos2dx/</id>
    <published>2018-09-25T03:13:41.577Z</published>
    <updated>2018-09-27T02:14:04.750Z</updated>
    
    <content type="html"><![CDATA[<h2 style="text-align: center;">基于cocos-2dx的游戏制作——I wanna save the princess</h2><p><b>在进行了两周的cocos学习之后，可以开始进行游戏的创作了。<br>I wanna主要复杂的地方在于地图的设计以及逻辑实现。下面依次进行介绍。（使用c++）</b></p><p></p><h3 style="text-align: left">一．    瓦片地图——tile map</h3><p></p><h4 style="text-align: left">1.    地图整体的大小。</h4><p>配合电脑可以全屏显示，设置为1080X1920的大小。<br><img src="https://i.imgur.com/nxXJgh7.png" alt=""></p><h4 style="text-align: left">2.    图块的大小。</h4><br><img src="https://i.imgur.com/PIXpNM7.png" alt=""><br>使用Tile map制作地图，因为它非常方便，可以将图片素材直接放到图块中，并且大小可以随意调节。<br><img src="https://i.imgur.com/XM4Csd9.png" alt=""><br><br><br><br>比如：所有的地图图块设置为30X30像素，因此普通的土块和草地都是30X30的大小。<br><img src="https://i.imgur.com/ApNK9MW.png" alt=""><br><br>但是在下面的场景中，因为水是直接在tile map中显示的，所以设置为了1920X900的大小。<br><img src="https://i.imgur.com/wUayzYq.png" alt=""><br><br><br><h4 style="text-align: left">3.    图层的设置。</h4><p>在这个界面中，可以新建多个图层，将不同属性的图块放入。<br><img src="https://i.imgur.com/yWCTAQL.png" alt=""></p><p>比如：土块和刺是分开的两个图层。<br><img src="https://i.imgur.com/ZdfvPzJ.png" alt=""></p><p><img src="https://i.imgur.com/XNNeWdU.png" alt=""><br>每一个形状的刺分别的一个图层。<br>向上的刺。<br><img src="https://i.imgur.com/F1SWGPV.png" alt=""></p><p>向左的刺。<br><img src="https://i.imgur.com/9ExyVbC.png" alt=""></p><p>隐藏的刺与可以触发的刺也是不同的图层。<br>地图上直接可见的，向上的刺。<br><img src="https://i.imgur.com/c439TCn.png" alt=""><br>并非直接可见，需要触发条件的，向上的刺。<br><img src="https://i.imgur.com/ADV21xM.png" alt=""></p><p>在图层的设置中，可以将同一属性的图层用一个新的图层覆盖，并且设置不可穿透的属性，这样在导入图层的时候会比较方便。<br><img src="https://i.imgur.com/P0Z1Y5h.png" alt=""><br>在所有不可穿透的图层中，覆盖了一层红色图层，在vs中导入的同时，设置为不可穿透。<br><img src="https://i.imgur.com/DSlwma2.png" alt=""><br>（不可穿透是利用下文中掩码的作用。）</p><h4 style="text-align: left">4.    人物图层。</h4><p>在建立图层的时候，选择添加对象层，然后选择建立矩形，在地图上的任一个地方画出任意大小的矩形，代表人物。<br><img src="https://i.imgur.com/tsLqFmW.png" alt=""><br>（相应操作在图上用红色方框表示。）</p><h4 style="text-align: left">5.    特殊图层。</h4><p>因为I wanna游戏的特殊，经常有不同的隐藏刺。这个部分首先需要在不同的图层中实现，然后需要一个对应的触发图层。</p><p>观察红色方框中图层的顺序，现在的位置是游戏地图中正常图层的位置，即土块将隐藏刺遮住了。<br><img src="https://i.imgur.com/2GKSLCB.png" alt=""></p><p>调整顺序后可以看到隐藏刺。<br><img src="https://i.imgur.com/zQZWbdh.png" alt=""></p><p>地图中红色图层的作用是，判断人物当前的位置x坐标是否与此图层中的某一个相同，相同则触发刺向上飞的事件。<br><img src="https://i.imgur.com/yf5xcJK.png" alt=""></p><p>这个触发图层的作用是，在地图中，人物在触碰到这个图层的同时，触发对应tag中的事件，比如让刺飞出，或是在踩到触发图层时冒出。</p><p><img src="https://i.imgur.com/gGIJNJK.png" alt=""><br>导入的图层为上一张图片中的yincang图层，设置tag为4。<br><img src="https://i.imgur.com/8UA4TaN.png" alt=""></p><p>人物的tag为1，当两个物体的tag分别为1和4的时候，触发事件。<br><img src="https://i.imgur.com/Tjxnvns.png" alt=""></p><p>在导入隐藏刺的同时设置冒出的移动，当人物与刺所在的图块接触，刺冒出。<br><img src="https://i.imgur.com/LSQgR0s.png" alt=""></p><p>触发刺飞出的事件。<br><img src="https://i.imgur.com/cUsSdHQ.png" alt=""></p><p></p><h3 style="text-align: left">二．    物理引擎</h3><p></p><h4 style="text-align: left">1．    建立物理世界。</h4><br><img src="https://i.imgur.com/I2FgNHO.png" alt=""><br><br><br><br><h4 style="text-align: left">2．    重力的添加以及改变。</h4><p>添加在创建物理世界时写入。<br>在第三个场景的水中，需要更改重力的大小。<br><img src="https://i.imgur.com/U22rqfa.png" alt=""></p><h4 style="text-align: left">3．    添加不同的刚体。</h4><p>普通的刚体，是矩形的。<br><img src="https://i.imgur.com/mHgHJV6.png" alt=""></p><p>因为刺是三角形的，所以需要建立一个数组存储三角形的三个顶点坐标，然后再附给物体，这样就是一个三角形的刚体。<br><img src="https://i.imgur.com/lAvxPE3.png" alt=""></p><h4 style="text-align: left">4．    介绍三种掩码。</h4><p>类别掩码setCategoryBitMask，接触检测掩码setContactTestBitmask，碰撞掩码setCollisionBitmask。<br>分别将两个物体的类别掩码与接触检测掩码进行逻辑与运算，可以判断是否触发接触事件，类似的，可以判断是否穿透或者碰撞。</p><p>人物的三种掩码。<br><img src="https://i.imgur.com/Osfqstw.png" alt=""></p><h4 style="text-align: left">5．    重新开始。</h4><p>将当前场景舍弃，重新生成一个新的场景，进行替换。<br><img src="https://i.imgur.com/X5PN8wP.png" alt=""></p><h4 style="text-align: left">6．    键盘事件。</h4><p>人物可以进行向左前进，向右前进，跳跃这三种动作，在此函数中，按下不同的键实现不同的事件。<br><img src="https://i.imgur.com/HsIWwV6.png" alt=""></p><p><img src="https://i.imgur.com/TUX2A2C.png" alt=""></p><h4 style="text-align: left">7．    标签的添加。</h4><p>在导入图层的时候就分别设置不同的tag，以便于在函数中进行相应的判断。<br><img src="https://i.imgur.com/lSDe7rU.png" alt=""></p><p>人物与刺碰撞，触发游戏结束的事件，在界面中添加游戏结束的图片，并且取消键盘事件，但可以按R键重新开始。（所有的刺tag都为3）<br><img src="https://i.imgur.com/k7Cmekz.png" alt=""></p><p>在最后切换场景时，有一个被隐藏了的触发图层，在人物接触到的同时进行tag的比较，从而可以切换场景。<br><img src="https://i.imgur.com/FONa3EU.png" alt=""><br><img src="https://i.imgur.com/uuU7qTS.png" alt=""><br><img src="https://i.imgur.com/MmH6mhx.png" alt=""></p><h4 style="text-align: left">8．    计时器函数</h4><p>进行场景中物理引擎的手动更新。<br><img src="https://i.imgur.com/lVQVhFL.png" alt=""></p><h4 style="text-align: left">9．    碰撞检测。</h4><p>利用三种掩码进行判断。<br>人物与土块。（人物的掩码在上方，三个都是7）<br><img src="https://i.imgur.com/dCYH27I.png" alt=""><br>（这个图层就是上方介绍过的覆盖图层）<br>进行判断后为不可穿透。</p><p>人物与水。<br><img src="https://i.imgur.com/VYZNULt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 style=&quot;text-align: center;&quot;&gt;基于cocos-2dx的游戏制作——I wanna save the princess&lt;/h2&gt;

&lt;p&gt;&lt;b&gt;在进行了两周的cocos学习之后，可以开始进行游戏的创作了。&lt;br&gt;I wanna主要复杂的地方在于地图
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/25/hello-world/"/>
    <id>http://yoursite.com/2018/09/25/hello-world/</id>
    <published>2018-09-25T00:51:53.263Z</published>
    <updated>2018-09-25T00:51:53.263Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
